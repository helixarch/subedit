#!/usr/bin/bash


#	Copyright 2016-2017 George Savvidis, Odysseas Raftopoulos

#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 2 of the License, or
#	(at your option) any later version.

#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.

#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Define colors and bold letters
green=$(tput setaf 2)
cyan=$(tput setaf 6)
bold=$(tput bold)
normal=$(tput sgr0)

# Check if dos2unix, unix2dos, iconv, file and uchardet programs exist.
if ! [[ -x "$(command -v dos2unix)" ]]; then
	echo "Error: \"dos2unix\" is not installed. Exiting."; exit 1
fi

if ! [[ -x "$(command -v unix2dos)" ]]; then
	echo "Error: \"unix2dos\" is not installed. Exiting."; exit 1
fi

if ! [[ -x "$(command -v iconv)" ]]; then
	echo "Error: \"iconv\" is not installed. Exiting."; exit 1
fi

if ! [[ -x "$(command -v file)" ]]; then
	echo "Error: \"file\" is not installed. Exiting."; exit 1
fi

if ! [[ -x "$(command -v uchardet)" ]]; then
	echo "Warning: \"uchardet\" is not installed. Uchardet improves input file's encoding detection but is not mandatory for subedit to run."
fi

# Define carriage return and new line
cr=$(echo -e "\r")
nl=$(echo -e "\n")

# Define regular expressions
regexinteger="^([0-9]+)$cr$"
regextime="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9]) --> ([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$cr$"
regexsub="^\{([0-9]+)\}\{([0-9]+)\}(.+)$cr$"
regexsub1="^\{[1]\}\{[1]\}(.+)$cr$"
regexemptyline="^($cr$nl|$nl|$cr)$"


# Help
get_help ()
{
case $((10#$(date +%S)%2)) in
	0) authors[0]="George Savvidis (stargr@gmail.com)"; authors[1]="Odysseas Raftopoulos" ;;
	1) authors[0]="Odysseas Raftopoulos"; authors[1]="George Savvidis (stargr@gmail.com)" ;;
esac

text1="
${cyan}NAME${normal}
  subedit


${cyan}DESCRIPTION${normal}
  Command line srt subtitle editor.

  The script generally works with srt (SubRip) but a few parameters work with sub (MicroDVD) subtitle files too.


${cyan}PARAMETERS${normal}
  ${bold}-i \"Input file\"${normal}
      Subtitle file to process. Accepts srt or sub files, depending on what other parameter is used.
      Does not work with -D parameter (synchronize with directory) and -r parameter (recurse).

  ${bold}-d \"Input directory\"${normal}
      Directory containing subtitle files to process. Can contain srt, sub or both subtitle types.
      Works with all parameters except with -y (synchronize with file) and -j (join two srt subtitles).
      Instead of Synchronize with file you can use Synchronize with directory (-D parameter).

  ${bold}-r [Switch]${normal}
      Searches recursively for subtitle files in directory given with -d parameter.

  ${bold}-b [Switch]${normal}
      Backup input file. Makes a copy of the input file in the same directory with the .bak sufix.
      If the backup already exists, it does nothing. If -b is not set and the backup file exists, it is removed.
      Can be used with any other parameter.

  ${bold}-s (+/-/a/z)hh:mm:ss,fff${normal}
      Shift time. Plus sign (or no sign at all) adds time, where the minus sign subtracts time.
      \"a\" and \"z\" indicate absolute time value for the beginning and end time of the subtitle file
      respectively. In this case the shifting time will be calculated.

  ${bold}-p [Switch]${normal}
      Change the fps from NTSC (23.976/29.970) to PAL (25).

  ${bold}-n [Switch]${normal}
      Change the fps from PAL (25) to NTSC (23.976/29.970).

  ${bold}-a (+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff${normal}
      Adjust time. Beginning and end time will be set to these values and the rest will be adjusted proportionally.
      The time value is absolute if you don't use the +/- and will be shifted if you do use either sign.

  ${bold}-1 (+/-)hh:mm:ss,fff${normal}
      Adjust time. Beginning time will be set to this value and the rest will be adjusted proportionally.
      The time value is absolute if you don't use the +/- and will be shifted if you do use either sign.

  ${bold}-2 (+/-)hh:mm:ss,fff${normal}
      Adjust time. End time will be set to this value and the rest will be adjusted proportionally.
      The time value is absolute if you don't use the +/- and will be shifted if you do use either sign.

  ${bold}-y \"Input file\"${normal}
      Synchronize with file. The subtitle times of the srt given with -i parameter will be adjusted with
      beginning and end time of this srt.

  ${bold}-D \"Input directory\"${normal}
      Synchronize with directory. To be used only with -d parameter.
      This directory contains srt subtitle files with correct times.
      The two directories (given with -d and -D parameters) must contain srt subtitle files with the same names.
      Synchronizes each srt subtitle file in the input directory (-d) with the srt subtitle file with the
      same name that's in the directory (-D).

  ${bold}-Y [Switch]${normal}
      Synchronize subtitle times one by one. Optional switch to be used with -y and -D. Replaces times of file
      to be synchronized with times of synchronization file, respectively.

  ${bold}-f \"Find text\"${normal}
      Search, case insensitive. The double quotes are necessary. Works with srt and sub.

  ${bold}-F \"Find text\"${normal}
      Search, case sensitive. The double quotes are necessary. Works with srt and sub.

  ${bold}-e \"Text to be replaced\" \"New text\"${normal}
      Replace, case insensitive. The double quotes are necessary. Works with srt and sub.

  ${bold}-E \"Text to be replaced\" \"New text\"${normal}
      Replace, case sensitive. The double quotes are necessary. Works with srt and sub.

  ${bold}-t film${normal} or ${bold}ntsc${normal} or ${bold}pal${normal} or ${bold}custom fps${normal}
      Convert sub to srt. Pal = 25, film = 23.976, ntsc = 29.970. Custom fps can be integer or float number.
      Works only with sub subtitle files.

  ${bold}-u film${normal} or ${bold}ntsc${normal} or ${bold}pal${normal} or ${bold}custom fps${normal}
      Convert srt to sub. Pal = 25, film = 23.976, ntsc = 29.970. Custom fps can be integer or float number.
      Any srt tags that cannot be converted to sub tags will pass to the .sub file. For example, a tag that
      includes one word in a sentence.

  ${bold}-U film${normal} or ${bold}ntsc${normal} or ${bold}pal${normal} or ${bold}custom fps${normal}
      Convert srt to sub. Pal = 25, film = 23.976, ntsc = 29.970. Custom fps can be integer or float number.
      Same as the -u parameter above but also ignores any srt tags that were not converted to respective
      sub tags. This is the behavior that you'd expect from other subtitle edit programs.

  ${bold}-j \"Input file\"${normal}
      Join two srt subtitles. This srt will be appended to the srt given with -i parameter.

  ${bold}-J hh:mm:ss,fff${normal}
      Join time. Optional parameter, to be used with -j. Shifts the time after beginning of the second srt
      in the output file.

  ${bold}-x (+/-)hh:mm:ss,fff${normal} or ${bold}(+/-)SUB_INTEGER${normal} or ${bold}(+/-)INTEGER:INTEGERt${normal} or ${bold}(+/-)INTEGER:INTEGERn${normal}
      Split srt subtitle. Can take 4 different syntaxes:
        i)   (+/-)hh:mm:ss,fff:     splitting time.
        ii)  (+/-)SUB_INTEGER:      splitting subtitle integer.
        iii) (+/-)INTEGER:INTEGERt: fraction where we split the subtitle file according to total time.
        iv)  (+/-)INTEGER:INTEGERn: fraction where we split the subtitle file according to number of subtitles.
      The minus sign means that counting begins from the end of the subtitle file.
      The plus sign means that counting begins from the beginning. (Equivalent of using no sign at all).

  ${bold}-X [Switch]${normal}
      Split time. Optional switch, to be used with -x. Makes the second generated srt begin with time 00:00:00,000.
      Can be used with any -x syntax.

  ${bold}-c [Switch]${normal}
      Clean trash. Replace multiple whitespaces with one, clean beginning and trailing spaces, replace two single
      quotes with a double quote, replace 2 or more \".\" with \"...\", capitalize the first letter after '.', '!'
      and '?' and many more common errors usually found in subtitles.
      Removes subtitles with zero duration.
      Also removes subtitles that contain the key words or key phrases (case insensitive) in /etc/subeditrc.
      /etc/subeditrc is a text file that you can edit and add key words or key phrases.
      If ~/.subeditrc exists (you have to create it manually), then it will be used instead of /etc/subeditrc.
      Works with srt and sub.

  ${bold}-k '([{?mM'${normal}
      Delete text for hearing impaired.
      The ([{? characters are the symbols that the text for the hearing impaired is enclosed by.
      \"m\" and \"M\" are for music symbols. With \"m\" only the music symbols are deleted. With \"M\" the text that
      is enclosed by the music symbols is deleted too.
      Use only the symbol(s) that are needed for each subtitle file.
      The single quotes are necessary.
      Works with srt and sub.

  ${bold}-h [Switch]${normal}
      Display help.

  ${bold}-H [Switch]${normal}
      Display help with more information and examples.\n\n\n"

examplecounter=1

text2="${cyan}NOTES${normal}
  • If the argument is a subtitle file you can give a relative or absolute path or a filename in the working directory.
  • Filenames must be enclosed in quotes if they contain spaces or other special characters (including wildcards).
  • Do not use \"~\" or \"\$HOME\" to symbolize the home directory. Write the text instead (/home/yourname).
  • -i (input file) or -d (input directory) is required in every case.
  • If only -i parameter is used then the subtitle goes through a basic clean-up (empty subtitles are removed etc.)
  • -1 and -2 parameters (adjust time) can be combined (equivalent of using just the -a parameter).
  • -f, -F (find), -e, -E (replace), -c (clean trash) and -k (delete text for HI) parameters work with
  both srt and sub subtitle files.
  • You can put different parameters in the same command and they'll run one after the other.
  • Bellow you'll find examples for every parameter.\n\n\n"


text2+="${cyan}EXAMPLES${normal}
  ${bold}Basic clean-up (purify)${normal}

  ${bold}${green}Example $((exmpl=examplecounter++))${normal}
  subedit -i foo.srt
  Removes empty subtitles, duplicate subtitles and extra empty lines, fixes subtitles' indexes, etc.\n\n"


text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i \"*.srt\"
  Same as above, but applies to all .srt files.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -b
  Same as Example $exmpl, but creates a backup before processing the subtitle.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory
  Runs Basic clean-up for all subtitle files in directory \"foo_directory\".\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -r
  Same as above, but also processes subtitles found in subdirectories (unlimited depth) as well.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d \"Season*\" -b
  Runs Basic clean-up for all subtitles found in all folders that begin with \"Season\" and
  creates a backup for each subtitle.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d \"Season [1-3,5]\"
  Runs Basic clean-up for all subtitles found in the folders \"Season 1\", \"Season 2\", \"Season 3\" and \"Season 5\".\n\n\n"


text2+="  ${bold}Shift time${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -s 00:00:03,100
  Shifts time by 3.1 seconds.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -s +00:00:03,100
  The same as above.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -s -00:00:02,500
  Shifts time by -2.5 seconds.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -s a00:00:11,530
  Calculates and applies the appropriate shift time value so that the first subtitle starts at 00:00:11,530.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -s z01:38:32,600
  Calculates and applies the appropriate shift time value so that the last subtitle starts at 01:38:32,600.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i \"*.srt\" -s 00:00:02,000
  Shifts time by 2.0 seconds in all .srt subtitle files.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -s 00:00:01,700
  Shifts time by 1.7 seconds in all .srt subtitle files in directory \"foo_directory\".\n\n\n"


text2+="  ${bold}Convert NTSC to PAL${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -p\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i \"*.srt\" -p
  Converts the fps in all .srt subtitle files.\n\n\n"


text2+="  ${bold}Convert PAL to NTSC${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -n\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -n
  Converts the fps in all .srt subtitle files in directory \"foo_directory\" from PAL to NTSC.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -r -n
  Same as above, but also processes subtitles found in subdirectories (unlimited depth) as well.\n\n\n"


text2+="  ${bold}Adjust time${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -a 00:00:17,360 00:48:02,200
  Sets beginning time to 00:00:17,360 and end time to 00:48:02,200.
  Both times are absolute.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -a +00:00:02,600 -00:00:05,920
  Shifts beginning time by +00:00:02,600 and end time by -00:00:05,920.
  Both times are relative.\n\n"

text2+="  ${bold}${green}Example $((exmpl=examplecounter++))${normal}
  subedit -i foo.srt -a 00:00:17,360 -00:00:05,920
  Sets beginning time to 00:00:17,360 and shifts end time by -00:00:05,920.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -1 00:00:17,360
  Sets beginning time to 00:00:17,360.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -2 +00:00:03,810
  Shifts end time by 00:00:03,810.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -1 00:00:17,360 -2 -00:00:05,920
  This has the same result as Example $exmpl.\n\n\n"


text2+="  ${bold}Synchronize with file${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -y boo.srt
  Synchronizes foo.srt with boo.srt. Subtitle times of foo.srt
  will be adjusted with the beginning and end time of boo.srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -y boo.srt -Y
  Synchronizes foo.srt with boo.srt. Subtitle times of foo.srt
  will be replaced with the times of boo.srt.\n\n\n"


text2+="  ${bold}Synchronize with directory${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -D boo_directory
  Synchronizes each srt subtitle file in the directory \"foo_directory\" with the srt subtitle file
  that has the same name that's in the directory \"boo_directory\".\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -D boo_directory -Y
  Synchronizes each srt subtitle file's times in the directory \"foo_directory\" with the srt
  subtitle file's times that has the same name that's in the directory \"boo_directory\",
  respectively.\n\n\n"


text2+="  ${bold}Find text${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -f \"Whatever you want\"
  Searches text \"whatever you want\" (case insensitive) and prints the lines that contain it.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -F \"Name, please.\"
  Searches text \"Name, please.\" (case sensitive) and prints the lines that contain it.\n\n\n"


text2+="  ${bold}Replace text${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -e \"George Smlth\" \"George Smith\"
  Replaces text \"george smlth\" (case insensitive) with \"George Smith\".\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -E \"i'm\" \"I'm\"
  Replaces text \"i'm\" (case sensitive) with \"I'm\".\n\n\n"


text2+="  ${bold}Convert sub to srt${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.sub -t pal
  Assumes that foo.sub is in 25 fps and creates a new file foo.srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.sub -t film
  Assumes that foo.sub is in 23.976 fps and creates a new file foo.srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.sub -t ntsc
  Assumes that foo.sub is in 29.970 fps and creates a new file foo.srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.sub -t 15.338
  Assumes that foo.sub is in 15.338 fps and creates a new file foo.srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i \"*.sub\" -t film
  Assumes that all .sub subtitle files are in 23.976 fps and converts them to srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -t film
  Assumes that all .sub subtitle files in \"foo_directory\" are in 23.976 fps and converts them to srt.\n\n\n"


text2+="  ${bold}Convert srt to sub${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -u pal
  Creates a new file foo.sub that's in 25 fps.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -U pal
  Same as above but any srt tags that were not converted to sub tags will not pass to the .sub file.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -u film
  Creates a new file foo.sub that's in 23.976 fps.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -u ntsc
  Creates a new file foo.sub that's in 29.970 fps.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -u 12
  Creates a new file foo.sub that's in 12 fps.\n\n\n"


text2+="  ${bold}Join two srt${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -j boo.srt
  Joins foo.srt and boo.srt to a new file foo_join.srt.
  The subtitle times in boo.srt are added unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -j boo.srt -J 00:48:05,956
  Joins foo.srt and boo.srt to a new file foo_join.srt.
  The subtitle times in boo.srt are shifted by 00:48:05,956 before added.\n\n\n"


text2+="  ${bold}Split srt to two files${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x 01:02:39,000
  Splits foo.srt at 01:02:39,000 to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x -00:59:14,000
  Splits foo.srt at 00:59:14,000 (counting from the end) to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x 431
  Splits foo.srt at subtitle number 431 to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x -399
  Splits foo.srt at subtitle number 399 (counting from the end) to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x 1:2t
  Splits foo.srt at 1/2 of total time to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x -2:3t
  Splits foo.srt at 2/3 of total time (counting from the end) to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x 3:4n
  Splits foo.srt at 3/4 of total subtitles to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x -1:5n
  Splits foo.srt at 1/5 of total subtitles (counting from the end) to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x 01:02:39,000 -X
  Splits foo.srt at 01:02:39,000 to two files foo_1.srt and foo_2.srt.
  foo_2.srt begins with time 00:00:00,000.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x -399 -X
  Splits foo.srt at subtitle number 399 (counting from the end) to two files foo_1.srt and foo_2.srt.
  foo_2.srt begins with time 00:00:00,000.\n\n\n"


text2+="  ${bold}Clean trash${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -c
  Cleans foo.srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i \"*\" -c -b
  Cleans all subtitle files and creates a backup for each one before processing them.
  Files that are not subtitle files are not processed.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -c -b
  Cleans all subtitle files in directory \"foo_directory\", and creates a backup for each one
  before processing them.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -c -r -b
  Same as above, but also processes subtitles found in subdirectories (unlimited depth) as well.\n\n\n"


text2+="  ${bold}Delete text for hearing impaired${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -k '('
  Deletes text for hearing impaired that's enclosed in parentheses.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -k '['
  Deletes text for hearing impaired that's enclosed in brackets.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -k '([{?'
  Deletes text for hearing impaired that's enclosed in all ([{? symbols.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -k 'm'
  Deletes the music symbols ¶♪♫.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -k 'M'
  Deletes text that's enclosed in the music symbols ¶♪♫.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -k '{M'
  Deletes text that's enclosed in braces and the music symbols ¶♪♫.\n\n\n"


text2+="${cyan}ABOUT${normal}
  Authors:      ${authors[0]}
                ${authors[1]}

  This program is licensed under GPLv2.\n\n"

printf "$text1"
if [[ $longhelp ]]; then
	printf "$text2"
fi
exit 0
}


# If no parameter is given then exit
if ( ! getopts ":i:d:rbs:pna:1:2:y:D:Yf:F:e:E:t:u:U:j:J:x:Xck:hH" opt); then
	echo "Try 'subedit -h' for more information."; exit 1;
fi

# Processing parameters
while getopts ":i:d:rbs:pna:1:2:y:D:Yf:F:e:E:t:u:U:j:J:x:Xck:hH" parameter; do
	case "$parameter" in
		i) inputfilename=$OPTARG ;;
		d) inputdirectory=$OPTARG ;;
		r) recurse="True" ;;
		b) backup="True" ;;
		s) shifttime=$OPTARG ;;
		p) ntsc2pal="True" ;;
		n) pal2ntsc="True" ;;
		a)	eval "adjustfirst=\$$((OPTIND-1))"
			eval "adjustlast=\$$((OPTIND))"
			((OPTIND++)) ;;
		1) adjustonlyfirst=$OPTARG ;;
		2) adjustonlylast=$OPTARG ;;
		y) synchronizefile=$OPTARG ;;
		D) synchronizedirectory=$OPTARG ;;
		Y) synchronizetimebytime="True" ;;
		f) findci=$OPTARG ;;
		F) findcs=$OPTARG ;;
		e)	eval "replace1=\$$((OPTIND-1))"
			eval "replace2=\$$((OPTIND))"
			((OPTIND++)) ;;
		E)	eval "replace3=\$$((OPTIND-1))"
			eval "replace4=\$$((OPTIND))"
			((OPTIND++)) ;;
		t) sub2srt=$OPTARG ;;
		u) srt2sub=$OPTARG ;;
		U) srt2sub=$OPTARG ; srt2sub_delsrttags="True" ;;
		j) joinsrt=$OPTARG ;;
		J) jointime=$OPTARG ;;
		x) splitsrt=$OPTARG ;;
		X) splittime="True" ;;
		c) cleantrash="True" ;;
		k) deletetextsforHI=$OPTARG ;;
		h) get_help ;;
		H) longhelp="True"; get_help ;;
		?) echo -e "Parameter -$OPTARG is unknown or an argument is missing.\nTry 'subedit -h' for more information."; exit 1 ;;
	esac
done


### Helper functions
check_file ()
{
	if ! [[ -f "$1" ]]; then
		echo "Error: \"$1\" not found."
		return 1
	fi

	if ! [[ -r "$1" ]]; then
		echo "Error: \"$1\" is not readable."
		return 1
	fi

	encoding=$(file -b --mime-encoding "$1")
	if [[ $encoding == "binary" ]] || ! [[ $(file -b "$1") == *"text"* ]] && ! [[ $(file -b "$1") == *"Bio-Rad .PIC Image File"* ]]; then
		echo "Error: \"$1\" is not a text file or it is UTF-16 without BOM"
		return 1
	fi

	# Check the file extension and create backup if it's not srt or sub
	extension="${1##*.}"
	if [[ "${extension,,}" != "srt" ]] && [[ "${extension,,}" != "sub" ]]; then
		cp "$1" "$1.bak" 2> /dev/null
	fi

	# Backup input file
	if [[ $backup ]] && [[ "$1" == "$inputfilename" ]] && ! [[ -f "$1.bak" ]]; then
		cp "$1" "$1.bak" 2> /dev/null
	fi

	# Detect encoding of input file
	# We use both file and uchardet (if it is available) because no one is perfect.
	# file doesn't get right some non-unicode encodings but for UTF-16 is preferable
	# than uchardet because the latter doesn't specify if it is UTF-16BE or UTF-16LE.
	# uchardet doesn't exist for Cygwin but one place you can find a Windows binary is here:
	# https://sourceforge.net/projects/cbadvanced/files/Repo/
	# For subedit to be able to use uchardet put uchardet.exe inside /bin directory in the Cygwin installation folder.
	# This uchardet has 2 problems: It needs windows-style path and it produces windows-style line endings.
	# We work around them in subedit, but keep them in mind if you use this uchardet in the console.
	if [[ $encoding == "utf-16"* ]] || [[ $encoding == *"ascii"* ]]; then
		:
	elif [[ -x /usr/bin/uchardet ]]; then
		cd "$(dirname "$1")"
		encoding=$(uchardet "$(basename "$1")" | tr -d '\r')
		cd - &> /dev/null
	fi

	# If the encoding is detected as ISO-8859-7, make it CP1253
	if [[ ${encoding^^} == "ISO-8859-7" ]]; then
		encoding="CP1253"
	fi

	# If text file is UTF-16 convert it to UTF-8
	if [[ $encoding == "utf-16"* ]]; then
		tempvar="$(cat "$1" | iconv -f $encoding -t utf-8)"
		printf "%s\n" "$tempvar" > "$1"
		encoding="utf-8"
		unset tempvar
	fi
}


read_srt ()
{
	# Make all line endings dos-like
	if ! [[ $subtitleis ]]; then
		dos2unix -q "$1" 2> /dev/null
		temptext=$(cat "$1")
		echo "$temptext" | tr '\r' '\n' > "$1"
		unix2dos -q "$1" 2> /dev/null
	fi

	# Delete tags that contain no text
	# The -b parameter open files in binary mode (CR+LFs are not processed specially) and makes sed behave in Cygwin like in Linux. In Linux it is ignored
	sed -b -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -i "$1"

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	temp1arraysrt=()
	for line in $(iconv -f $encoding -t utf-8 "$1" 2> /dev/null); do
		temp1arraysrt+=($line)
	done


	# Remove any empty lines between the integer and the time and add integer if it doesn't exist
	temp2arraysrt=()
	regexemptyorblank="^[[:blank:]]*$cr$"
	for ((i=0; i<=${#temp1arraysrt[@]}; i++)); do
		temp2arraysrt+=(${temp1arraysrt[$i]})
		if [[ ${temp1arraysrt[((i+1))]} =~ $regextime ]]; then 
			if [[ ${temp1arraysrt[$i]} =~ $regexemptyorblank ]]; then
				while :; do
					if [[ ${temp2arraysrt[-1]} =~ $regexemptyorblank ]]; then
						unset temp2arraysrt[-1]
					else
						break
					fi
				done

				if ! [[ ${temp2arraysrt[-1]} =~ $regexinteger ]]; then
					temp2arraysrt+=("$cr")
					temp2arraysrt+=("0$cr")
				fi
			fi
			if ! [[ ${temp2arraysrt[-1]} =~ $regexinteger ]]; then
				temp2arraysrt+=("$cr")
				temp2arraysrt+=("0$cr")
			fi
		fi
	done

	unset temp1arraysrt


	# If a line ends with an opening tag, move it to the beginning of the next line
	# If a line begins with a closing tag, move it to the end of the preceding line
	regexendswithopentag="^(.*)((<[ibus]>)|(<font[^>]*>))($cr)$"
	regexstartswithclosetag="^((</[ibus]>)+|(</font>)+)(.*)($cr)$"
	temp3arraysrt=()
	for ((i=0; i<=${#temp2arraysrt[@]}; i++)); do
		if [[ ${temp2arraysrt[((i+1))]} =~ $regextime ]]; then
			temp3arraysrt+=(${temp2arraysrt[$i]})
		else
			temp3arraysrt+=($tobecarriedover1e$tobecarriedover1d$tobecarriedover1c$tobecarriedover1b$tobecarriedover1a${temp2arraysrt[$i]})
		fi

		unset tobecarriedover1a tobecarriedover1b tobecarriedover1c tobecarriedover1d tobecarriedover1e

		if [[ ${temp3arraysrt[-1]} =~ $regexendswithopentag ]]; then
			unset temp3arraysrt[-1]
			temp3arraysrt+=(${BASH_REMATCH[1]}${BASH_REMATCH[5]})
			tobecarriedover1a=${BASH_REMATCH[2]}
		fi

		if [[ ${temp3arraysrt[-1]} =~ $regexendswithopentag ]]; then
			unset temp3arraysrt[-1]
			temp3arraysrt+=(${BASH_REMATCH[1]}${BASH_REMATCH[5]})
			tobecarriedover1b=${BASH_REMATCH[2]}
		fi

		if [[ ${temp3arraysrt[-1]} =~ $regexendswithopentag ]]; then
			unset temp3arraysrt[-1]
			temp3arraysrt+=(${BASH_REMATCH[1]}${BASH_REMATCH[5]})
			tobecarriedover1c=${BASH_REMATCH[2]}
		fi

		if [[ ${temp3arraysrt[-1]} =~ $regexendswithopentag ]]; then
			unset temp3arraysrt[-1]
			temp3arraysrt+=(${BASH_REMATCH[1]}${BASH_REMATCH[5]})
			tobecarriedover1d=${BASH_REMATCH[2]}
		fi

		if [[ ${temp3arraysrt[-1]} =~ $regexendswithopentag ]]; then
			unset temp3arraysrt[-1]
			temp3arraysrt+=(${BASH_REMATCH[1]}${BASH_REMATCH[5]})
			tobecarriedover1e=${BASH_REMATCH[2]}
		fi

		if [[ ${temp3arraysrt[-1]} =~ $regexstartswithclosetag ]]; then
			unset temp3arraysrt[-1]
			temp3arraysrt+=(${BASH_REMATCH[4]}${BASH_REMATCH[5]})
		fi

		if ! [[ $tobecarriedover1a ]] && ! [[ ${temp2arraysrt[$i]} =~ $regextime ]] && [[ ${temp2arraysrt[((i+1))]} =~ $regexstartswithclosetag ]]; then
			tobecarriedover2=${BASH_REMATCH[1]}
			[[ ${temp3arraysrt[-1]} =~ (.*)($cr)$ ]]
			tobecarriedover3=${BASH_REMATCH[1]}
			unset temp3arraysrt[-1]
			temp3arraysrt+=($tobecarriedover3$tobecarriedover2$cr)
			unset tobecarriedover2
			unset tobecarriedover3
		fi
	done

	unset temp2arraysrt


	# Delete tags that contain no text. Again.
	temp4arraysrt=( $(printf "%s\n" "${temp3arraysrt[@]}" | sed -b -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" | iconv -f utf-8 -t $encoding) )


	# Remove any empty lines between the time and the first dialog line
	temp5arraysrt=()
	for ((i=0; i<=${#temp4arraysrt[@]}; i++)); do
		temp5arraysrt+=(${temp4arraysrt[$i]})
		if (( ${#temp5arraysrt[@]} > 1)) && [[ ${temp5arraysrt[-2]} =~ $regextime ]]; then 
			if [[ ${temp5arraysrt[-1]} =~ $regexemptyorblank ]]; then
				unset temp5arraysrt[-1]
			fi
		fi
	done

	unset temp4arraysrt


	# Remove empty subtitles, remove duplicate subtitles and remove extra empty lines before each integer
	buffer=()
	buffer_old=()	# This is used to search for duplicate subtitles
	arraysrt=()
	regexnotonlyblank="^[[:blank:]]+[^[:blank:]]+.+"
	regexblank="^[[:blank:]]+$cr$"

	# This was put inside a function because it needs to run twice
	srtcleaning ()
	{
		while :; do
			if [[ $buffer ]] && [[ ${buffer[-1]} =~ $regexemptyline ]]; then
				unset buffer[-1]
			elif [[ $buffer ]] && [[ ${buffer[-1]} =~ $regexnotonlyblank ]]; then
				break
			elif [[ $buffer ]] && [[ ${buffer[-1]} =~ $regexblank ]]; then
				unset buffer[-1]
			else
				break
			fi
		done

		if [[ $buffer_old ]] && (( ${#buffer_old[@]} == ${#buffer[@]} )); then
			check=1
			for ((j=1; j<=${#buffer_old[@]}-1; j++)); do
				if [[ ${buffer_old[$j],,} == ${buffer[$j],,} ]]; then
					((check++))
				else
					break
				fi
			done
			if (( $check == ${#buffer_old[@]} )); then
				duplicatefound="True"
			fi
		fi

		if ! [[ $duplicatefound ]] && [[ $buffer ]] && ! [[ ${buffer[-1]} =~ $regextime ]]; then
			arraysrt+=("${buffer[@]}")
			arraysrt+=("$cr")
		fi
	}

	for ((i=0; i<=${#temp5arraysrt[@]}; i++)); do
		if [[ ${temp5arraysrt[$i]} =~ $regexinteger ]] && [[ ${temp5arraysrt[((i+1))]} =~ $regextime ]]; then
			srtcleaning

			unset duplicatefound
			buffer_old=()
			buffer_old+=("${buffer[@]}")
			buffer=()
		fi
		buffer+=(${temp5arraysrt[$i]})
	done

	unset temp5arraysrt

	# Everything inside the previous for-loop must run one last time for the last subtitle
	srtcleaning

	IFS=$old_IFS		# restore default field separator

	# Re-create the subtitle array with new counter
	subcounter=0
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		if [[ ${arraysrt[$i]} =~ $regexinteger ]] && [[ ${arraysrt[((i+1))]} =~ $regextime ]]; then
			((subcounter++))
			arraysrt[$i]="$subcounter$cr"
		fi
	done

	# Remove an empty line at the end
	if [[ $arraysrt ]] && [[ ${arraysrt[-1]} =~ $regexemptyline ]]; then
		unset arraysrt[-1]
	fi
}


read_sub ()
{
	# Make all line endings dos-like
	if ! [[ $subtitleis ]]; then
		dos2unix -q "$1" 2> /dev/null
		temptext=$(cat "$1")
		echo "$temptext" | tr '\r' '\n' > "$1"
		unix2dos -q "$1" 2> /dev/null
	fi

	# Remove any empty subtitle lines before the first non-empty dialog line
	sed -b s'/^\({[0-9]\+}{[0-9]\+}\)\(\({[CSFPY]:[^}]*}\)*\)\([|[:blank:]]*[|]*\({[csfy]:[^}]*}\)*[|[:blank:]]*[|]\)*\(.*\)/\1\2\6/'g -i "$1"

	# Regular expressions for multiple tags that need to become one
	color_size_TAGS="((\{[S]:[0-9]+\})?(\{[C]:[$][A-F0-9]{6}\})?(\{[S]:[0-9]+\})?)"
	color_size_tags="((\{[s]:[0-9]+\})?(\{[c]:[$][A-F0-9]{6}\})?(\{[s]:[0-9]+\})?)"
	regex_merge_Y_tags="^(\{[0-9]+\}\{[0-9]+\}$color_size_TAGS)$color_size_tags({Y:([ibus]+)})?$color_size_TAGS$color_size_tags({Y:([ibus]+)})?$color_size_TAGS$color_size_tags({Y:([ibus]+)})?$color_size_TAGS$color_size_tags({Y:([ibus]+)})?(.*)$"
	regex_merge_y_tags1="^(\{[0-9]+\}\{[0-9]+\}$color_size_TAGS({Y:[ibus]+})?$color_size_tags)({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?(.*)$"
	regex_merge_y_tags2="^($color_size_tags)({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?(.*)$"

	# Read text file to array and delete empty and duplicate subs
	arraysub=()
	regexemptysub="^\{([0-9]+)\}\{([0-9]+)\}(\{[cCsSfFPyY]:[^}]*\})*([|[:blank:]]*)$cr$"
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(iconv -f $encoding -t utf-8 "$1" 2> /dev/null); do
		if [[ $line =~ $regexsub1 ]]; then
			arraysub+=($line)
		fi
		break
	done

	for line in $(iconv -f $encoding -t utf-8 "$1" 2> /dev/null); do
		if ! [[ $line =~ $regexemptysub ]] && ! [[ $line =~ $regexsub1 ]] && [[ $line =~ $regexsub ]] && [[ ${line,,} != ${arraysub[-1],,} ]]; then
			# Merge multiple Y tags
			if [[ $line =~ $regex_merge_Y_tags ]] && [[ ${BASH_REMATCH[10]} ]]; then
				ibus_matches=${BASH_REMATCH[11]}${BASH_REMATCH[21]}${BASH_REMATCH[31]}${BASH_REMATCH[41]}
				tag_values=""
				if [[ $ibus_matches == *"i"* ]]; then tag_values+="i"; fi
				if [[ $ibus_matches == *"b"* ]]; then tag_values+="b"; fi
				if [[ $ibus_matches == *"u"* ]]; then tag_values+="u"; fi
				if [[ $ibus_matches == *"s"* ]]; then tag_values+="s"; fi
				line="${BASH_REMATCH[1]}${BASH_REMATCH[12]}${BASH_REMATCH[22]}${BASH_REMATCH[32]}{Y:$tag_values}${BASH_REMATCH[6]}${BASH_REMATCH[16]}${BASH_REMATCH[26]}${BASH_REMATCH[36]}${BASH_REMATCH[42]}"
			fi

			IFS=$'|'
			read -r -a split_line <<< "$line"
			# Merge multiple y tags in the first line
			if [[ ${split_line[0]} =~ $regex_merge_y_tags1 ]] && [[ ${BASH_REMATCH[11]} ]]; then
				ibus_matches=${BASH_REMATCH[12]}${BASH_REMATCH[18]}${BASH_REMATCH[24]}${BASH_REMATCH[30]}
				tag_values=""
				if [[ $ibus_matches == *"i"* ]]; then tag_values+="i"; fi
				if [[ $ibus_matches == *"b"* ]]; then tag_values+="b"; fi
				if [[ $ibus_matches == *"u"* ]]; then tag_values+="u"; fi
				if [[ $ibus_matches == *"s"* ]]; then tag_values+="s"; fi
				split_line[0]="${BASH_REMATCH[1]}${BASH_REMATCH[13]}${BASH_REMATCH[19]}${BASH_REMATCH[25]}{y:$tag_values}${BASH_REMATCH[31]}"
			fi
			line_new=${split_line[0]}

			# Merge multiple y tags in the rest of the lines
			for ((i=1; i<=${#split_line[@]}-1; i++)); do
				if [[ ${split_line[$i]} =~ $regex_merge_y_tags2 ]] && [[ ${BASH_REMATCH[6]} ]]; then
					ibus_matches=${BASH_REMATCH[7]}${BASH_REMATCH[13]}${BASH_REMATCH[19]}${BASH_REMATCH[25]}
					tag_values=""
					if [[ $ibus_matches == *"i"* ]]; then tag_values+="i"; fi
					if [[ $ibus_matches == *"b"* ]]; then tag_values+="b"; fi
					if [[ $ibus_matches == *"u"* ]]; then tag_values+="u"; fi
					if [[ $ibus_matches == *"s"* ]]; then tag_values+="s"; fi
					split_line[$i]="${BASH_REMATCH[1]}${BASH_REMATCH[8]}${BASH_REMATCH[14]}${BASH_REMATCH[20]}{y:$tag_values}${BASH_REMATCH[26]}"
				fi
				line_new+="|${split_line[$i]}"
			done
			IFS=$'\n'

			arraysub+=($line_new$cr)
		fi 2> /dev/null
	done

	IFS=$old_IFS		# restore default field separator
}


check_srt ()
{
	# Check the file extension
	extension="${1##*.}"
	if [[ "${extension,,}" != "srt" ]]; then
		echo "Warning: \"$1\" does not have '.srt' extension"
	fi

	srtok=""
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		if [[ ${arraysrt[$i]} =~ $regextime ]]; then
			if [[ $2 ]]; then echo $2; fi
			srtok="true"
			break
		fi
	done

	if ! [[ $srtok ]]; then
		if ! [[ -r "$1.bak" ]]; then
			echo "Warning: \"$1.bak\" is not readable"
		fi
		if [[ $backup ]]; then
			cp "$1.bak" "$1" 2> /dev/null
		else
			mv "$1.bak" "$1" 2> /dev/null
		fi
		echo "Error: \"$1\" is not a valid srt file"
		return 1
	elif ! [[ $backup ]]; then
		rm -f "$1.bak" 2> /dev/null
	fi
}


check_sub ()
{
	# Check the file extension
	extension="${1##*.}"
	if [[ "${extension,,}" != "sub" ]]; then
		echo "Warning: \"$1\" does not have '.sub' extension"
	fi

	subok=""
	for ((i=0; i<=${#arraysub[@]}; i++)); do
		line=${arraysub[$i]}

		if ! [[ $line =~ $regexsub1 ]] && [[ $line =~ $regexsub ]]; then
			if [[ $2 ]]; then echo $2; fi
			subok="true"
			break
		fi
	done

	if ! [[ $subok ]]; then
		if ! [[ -r "$1.bak" ]]; then
			echo "Warning: \"$1.bak\" is not readable"
		fi
		if [[ $backup ]]; then
			cp "$1.bak" "$1" 2> /dev/null
		else
			mv "$1.bak" "$1" 2> /dev/null
		fi
		echo "Error: \"$1\" is not a valid sub file"
		return 1
	elif ! [[ $backup ]]; then
		rm -f "$1.bak" 2> /dev/null
	fi
}


check_srt_and_sub ()
{
	# Make all line endings dos-like
	dos2unix -q "$1" 2> /dev/null
	temptext=$(cat "$1")
	echo "$temptext" | tr '\r' '\n' > "$1"
	unix2dos -q "$1" 2> /dev/null

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	array=()
	for line in $(iconv -f $encoding -t utf-8 "$1" 2> /dev/null); do
		array+=($line)
	done

	IFS=$old_IFS		# restore default field separator

	subtitleis=""
	for ((i=0; i<=${#array[@]}; i++)); do
		if ! [[ ${array[$i]} =~ $regexsub1 ]] && [[ ${array[$i]} =~ $regexsub ]]; then
			if [[ $2 ]]; then echo $2; fi
			subtitleis="sub"
			# Check the file extension
			extension="${1##*.}"
			if [[ "${extension,,}" != "sub" ]]; then
				echo "Warning: \"$1\" does not have '.sub' extension"
			fi
			break
		elif [[ ${array[$i]} =~ $regextime ]]; then
			if [[ $2 ]]; then echo $2; fi
			subtitleis="srt"
			# Check the file extension
			extension="${1##*.}"
			if [[ "${extension,,}" != "srt" ]]; then
				echo "Warning: \"$1\" does not have '.srt' extension"
			fi
			break
		fi
	done

	if ! [[ $subtitleis ]]; then
		mv "$1.bak" "$1" 2> /dev/null
		echo "Error: \"$1\" is not a valid srt or sub file"
		return 1
	elif ! [[ $backup ]]; then
		rm -f "$1.bak" 2> /dev/null
	fi
}


### Main functions
basic_clean_up ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the srt or sub is OK
	check_srt_and_sub "$inputfilename" "Purifying \"$inputfilename\""

	# Exit this function if the return code of check_srt_and_sub is not 0
	if (($? != 0)); then
		return 1
	fi

	case "$subtitleis" in
		"srt") read_srt "$inputfilename"; printf "%s\n" "${arraysrt[@]}" > "$inputfilename" ;;
		"sub") read_sub "$inputfilename"; printf "%s\n" "${arraysub[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename" ;;
	esac

	unset subtitleis
}


shift_time ()
{
	# Calculate the time to move the subs
	regexshift="^([az+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

	if [[ $shifttime =~ $regexshift ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-/a/z)hh:mm:ss,fff'"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )); then
		echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
	fi

	givenms=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))


	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	check_srt "$inputfilename" "Shifting time of \"$inputfilename\" by $shifttime..."

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi


	# Find shift milliseconds
	if [[ $sign == "a" ]]; then
		# Find the first subtitle time
		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h1a="${BASH_REMATCH[1]}"
				m1a="${BASH_REMATCH[2]}"
				s1a="${BASH_REMATCH[3]}"
				f1a="${BASH_REMATCH[4]}"

				break
			fi
		done

		# Time in milliseconds of the start time of the first subtitle
		pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

		# Shift milliseconds
		((p=givenms-pa))
	elif [[ $sign == "z" ]]; then
		# Find the last subtitle time
		for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h1b="${BASH_REMATCH[1]}"
				m1b="${BASH_REMATCH[2]}"
				s1b="${BASH_REMATCH[3]}"
				f1b="${BASH_REMATCH[4]}"

				break
			fi
		done

		# Time in milliseconds of the start time of the last subtitle
		pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))

		# Shift milliseconds
		((p=givenms-pb))
	else
		# Shift milliseconds
		p=$sign$givenms
	fi


	# Process the array
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p1 + $p))
			p2_new=$(($p2 + $p))

			if (( $p1_new < 0 )) || (( $p2_new < 0 )); then
				echo "Error: Negative time not allowed. Check the shifting value."; return 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new$cr
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


change_fps ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	if [[ $pal2ntsc ]]; then
		check_srt "$inputfilename" "Changing fps of \"$inputfilename\" from PAL (25) to NTSC (23.976 or 29.970)..."
	elif [[ $ntsc2pal ]]; then
		check_srt "$inputfilename" "Changing fps of \"$inputfilename\" from NTSC (23.976 or 29.970) to PAL (25)..."
	fi

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Process the array
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			if [[ $pal2ntsc ]]; then
				p1_new=$(($p1 * 1001 / 960))
				p2_new=$(($p2 * 1001 / 960))
			elif [[ $ntsc2pal ]]; then
				p1_new=$(($p1 * 960 / 1001))
				p2_new=$(($p2 * 960 / 1001))
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new$cr
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


adjust_time ()
{
	# Calculate the time to move the subs
	regexadjust="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

	if [[ $adjustfirst =~ $regexadjust ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff'"; exit 1
	fi

	if [[ $adjustlast =~ $regexadjust ]]; then
		sign_="${BASH_REMATCH[1]}"
		h_="${BASH_REMATCH[2]}"
		m_="${BASH_REMATCH[3]}"
		s_="${BASH_REMATCH[4]}"
		f_="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff'"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
		echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	check_srt "$inputfilename" "Adjusting time of \"$inputfilename\"..."

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the file has only 1 subtitle
	if ((subcounter == 1)); then
		echo "Error: File has only 1 subtitle. Use Shift time (-s parameter) instead."; return 1
	fi


	# Find the first and last subtitle time
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	# Time in milliseconds of the start time of the first subtitle
	pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in milliseconds of the start time of the last subtitle
	pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Calculate the NEW first and last subtitle
	if [[ $sign ]]; then
		p=$(($pa $sign $(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))))
	else
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
	fi

	if [[ $sign_ ]]; then
		p_=$(($pb $sign_ $(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))))
	else
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))
	fi


	if (( $pa == $pb )); then
		echo "Error: Cannot process the file. The first subtitle starts at the same time as the last subtitle"; return 1
	elif (( $pa > $pb )); then
		echo "Error: Cannot process the file. The first subtitle starts after the last subtitle"; return 1
	fi

	if (( $p == $p_ )); then
		echo "Error: The first subtitle cannot start at the same time as the last subtitle"; return 1
	elif (( $p > $p_ )); then
		echo "Error: The first subtitle cannot start after the last subtitle"; return 1
	fi


	# Process the array
	diff1=$(($p_ - $p))
	diff2=$(($pb - $pa))

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
			p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

			if (( $p1_new < 0 )) || (( $p2_new < 0 )); then
				echo "Error: Negative time not allowed. Check the adjusting values."; return 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new$cr
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


adjust_time_v2 ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	check_srt "$inputfilename" "Adjusting time of \"$inputfilename\"..."

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the file has only 1 subtitle
	if ((subcounter == 1)); then
		echo "Error: File has only 1 subtitle. Use Shift time (-s parameter) instead."; return 1
	fi


	# Find the first and last subtitle time
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	if (( 10#$m1a >= 60 )) || (( 10#$s1a >= 60 )) || (( 10#$m1b >= 60 )) || (( 10#$s1b >= 60 )); then
		echo "Error: The first or last subtitle time is invalid."; return 1
	fi

	# Time in milliseconds of the start time of the first subtitle
	pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in milliseconds of the start time of the last subtitle
	pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Calculate the time to move the subs
	regexadjust="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

	if ! [[ $adjustonlyfirst ]]; then
		h=$h1a
		m=$m1a
		s=$s1a
		f=$f1a
	elif [[ $adjustonlyfirst =~ $regexadjust ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff'"; exit 1
	fi

	if ! [[ $adjustonlylast ]]; then
		h_=$h1b
		m_=$m1b
		s_=$s1b
		f_=$f1b
	elif [[ $adjustonlylast =~ $regexadjust ]]; then
		sign_="${BASH_REMATCH[1]}"
		h_="${BASH_REMATCH[2]}"
		m_="${BASH_REMATCH[3]}"
		s_="${BASH_REMATCH[4]}"
		f_="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff'"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
		echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
	fi


	# Calculate the NEW first and last subtitle
	if [[ $sign ]]; then
		p=$(($pa $sign $(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))))
	else
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
	fi

	if [[ $sign_ ]]; then
		p_=$(($pb $sign_ $(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))))
	else
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))
	fi


	if (( $pa == $pb )); then
		echo "Error: Cannot process the file. The first subtitle starts at the same time as the last subtitle"; return 1
	elif (( $pa > $pb )); then
		echo "Error: Cannot process the file. The first subtitle starts after the last subtitle"; return 1
	fi

	if (( $p == $p_ )); then
		echo "Error: The first subtitle cannot start at the same time as the last subtitle"; return 1
	elif (( $p > $p_ )); then
		echo "Error: The first subtitle cannot start after the last subtitle"; return 1
	fi


	# Process the array
	diff1=$(($p_ - $p))
	diff2=$(($pb - $pa))

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
			p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

			if (( $p1_new < 0 )) || (( $p2_new < 0 )); then
				echo "Error: Negative time not allowed. Check the adjusting values."; return 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new$cr
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


synchronize_with_file ()
{
	if [[ $synchronizedirectory ]]; then
		synchronizefile="$synchronizedirectory/$(basename "$inputfilename")"
		if ! [[ -f "$synchronizefile" ]]; then
			echo "Error: \"$synchronizefile\" not found."
			return 1
		fi

		if ! [[ -r "$synchronizefile" ]]; then
			echo "Error: \"$synchronizefile\" is not readable."
			return 1
		fi
	fi

	# Check if the synchronize file is a text
	check_file "$synchronizefile"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read file to synchronize to
	read_srt "$synchronizefile"

	# Check if the srt is OK
	check_srt "$synchronizefile"

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi


	if ! [[ $synchronizetimebytime ]]; then
		# Find the first and last subtitle time of the file to synchronize to
		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h="${BASH_REMATCH[1]}"
				m="${BASH_REMATCH[2]}"
				s="${BASH_REMATCH[3]}"
				f="${BASH_REMATCH[4]}"

				break
			fi
		done

		for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h_="${BASH_REMATCH[1]}"
				m_="${BASH_REMATCH[2]}"
				s_="${BASH_REMATCH[3]}"
				f_="${BASH_REMATCH[4]}"

				break
			fi
		done

		if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
			echo "Error: The first or last subtitle time of the subtitle you want to synchronize with, is invalid."; return 1
		fi

		# Calculate the NEW first and last subtitle
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))

		if (( $p == $p_ )); then
			echo "Error: The first subtitle cannot start at the same time as the last subtitle"; return 1
		elif (( $p > $p_ )); then
			echo "Error: The first subtitle cannot start after the last subtitle"; return 1
		fi


		# Check if the input file is a text
		check_file "$inputfilename"

		# Exit this function if the return code of check_file is not 0
		if (($? != 0)); then
			return 1
		fi

		# Read text file to arraysrt
		read_srt "$inputfilename"

		# Check if the srt is OK
		check_srt "$inputfilename" "Synchronizing \"$inputfilename\" with \"$synchronizefile\"..."

		# Exit this function if the return code of check_srt is not 0
		if (($? != 0)); then
			return 1
		fi

		# Check if the file has only 1 subtitle
		if ((subcounter == 1)); then
			echo "Error: File has only 1 subtitle. Use Shift time (-s parameter) instead."; return 1
		fi


		# Find the first and last subtitle time
		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h1a="${BASH_REMATCH[1]}"
				m1a="${BASH_REMATCH[2]}"
				s1a="${BASH_REMATCH[3]}"
				f1a="${BASH_REMATCH[4]}"

				break
			fi
		done

		for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h1b="${BASH_REMATCH[1]}"
				m1b="${BASH_REMATCH[2]}"
				s1b="${BASH_REMATCH[3]}"
				f1b="${BASH_REMATCH[4]}"

				break
			fi
		done

		# Time in milliseconds of the start time of the first subtitle
		pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

		# Time in milliseconds of the start time of the last subtitle
		pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))

		if (( $pa == $pb )); then
			echo "Error: Cannot process the file. The first subtitle starts at the same time as the last subtitle"; return 1
		elif (( $pa > $pb )); then
			echo "Error: Cannot process the file. The first subtitle starts after the last subtitle"; return 1
		fi


		# Process the array
		diff1=$(($p_ - $p))
		diff2=$(($pb - $pa))

		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				h2="${BASH_REMATCH[5]}"
				m2="${BASH_REMATCH[6]}"
				s2="${BASH_REMATCH[7]}"
				f2="${BASH_REMATCH[8]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
				p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

				p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
				p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

				if (( $p1_new < 0 )) || (( $p2_new < 0 )); then
					echo "Error: Negative time not allowed. Check the adjusting values."; return 1
				fi

				j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
				j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

				line_new="$j1 --> $j2"

				arraysrt[$i]=$line_new$cr
			fi
		done
	else
		# Copy the times of arraysrt to arraysynchronize
		arraysynchronize=()

		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			if [[ ${arraysrt[$i]} =~ $regextime ]]; then
				arraysynchronize+=("${arraysrt[$i]}")
			fi
		done

		# Check if the input file is a text
		check_file "$inputfilename"

		# Exit this function if the return code of check_file is not 0
		if (($? != 0)); then
			return 1
		fi

		# Read text file to arraysrt
		read_srt "$inputfilename"

		# Check if the srt is OK
		check_srt "$inputfilename" "Synchronizing \"$inputfilename\" with \"$synchronizefile\"..."

		# Exit this function if the return code of check_srt is not 0
		if (($? != 0)); then
			return 1
		fi

		counter=0
		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			if [[ ${arraysrt[$i]} =~ $regextime ]]; then
				if [[ ${arraysynchronize[$counter]} ]]; then
					arraysrt[$i]="${arraysynchronize[$counter]}"
					((counter++))
				else
					break
				fi
			fi
		done
	fi

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


find_text ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	if [[ $findci ]]; then
		find=$findci
	elif [[ $findcs ]]; then
		find=$findcs
	fi

	# Check if the srt or sub is OK
	check_srt_and_sub "$inputfilename"
	echo -e "Finding \"$find\" in file \"$inputfilename\""

	# Exit this function if the return code of check_srt_and_sub is not 0
	if (($? != 0)); then
		return 1
	fi

	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	if [[ $findci ]]; then
		iconv -f $encoding -t utf-8 "$inputfilename" 2> /dev/null | grep $find -ni | sed s'/:/: /' | while read -r line; do echo "line $line"; done
	else
		iconv -f $encoding -t utf-8 "$inputfilename" 2> /dev/null | grep $find -n | sed s'/:/: /' | while read -r line; do echo "line $line"; done
	fi

	IFS=$old_IFS		# restore default field separator
}


replace_text ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	if [[ $replace3 ]]; then
		replace1=$replace3
		replace2=$replace4
	fi

	# Define forbitten and allowed regex
	regexforbittensynbols="^[0-9<>\/:{}\$=#-,]+$"
	regexallowedtimes="^[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$"
	regexallowedframes="^\{[0-9]+\}\{[0-9]+\}$"
	regexallowedtime="^[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$"
	regexallowedframe="^\{[0-9]+\}$"

	if ! [[  $replace1 =~  $regexallowedtimes ]] && ! [[  $replace1 =~  $regexallowedframes ]] && ! [[  $replace1 =~  $regexallowedtime ]] && ! [[  $replace1 =~  $regexallowedframe ]] && [[ $replace1 =~ $regexforbittensynbols ]]; then
		echo "Error: You cannot replace this"; exit 1
	fi

	# Check if the srt or sub is OK
	check_srt_and_sub "$inputfilename" "Replacing \"$replace1\" with \"$replace2\" in file \"$inputfilename\""

	# Exit this function if the return code of check_srt_and_sub is not 0
	if (($? != 0)); then
		return 1
	fi

	IFS=$'\n'			# new field separator, the end of line

	if [[ $replace3 ]]; then
		case "$subtitleis" in
			"srt")
				read_srt "$inputfilename"
				temparray=( $(printf "%s\n" "${arraysrt[@]}" | iconv -f $encoding -t utf-8 | sed -b s"/$replace1/$replace2/g") )
				# If the conversion from UTF-8 to the original encoding isn't possible, keep the UTF-8
				printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding &> /dev/null
				if (($? == 0)); then
					printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
				else
					printf "%s\n" "${temparray[@]}" > "$inputfilename"
					echo "Warning: \"$inputfilename\" has been saved with UTF-8 encoding"
				fi
				unset temparray ;;
			"sub")
				read_sub "$inputfilename"
				temparray=( $(printf "%s\n" "${arraysub[@]}" | sed -b s"/$replace1/$replace2/g") )
				# If the conversion from UTF-8 to the original encoding isn't possible, keep the UTF-8
				printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding &> /dev/null
				if (($? == 0)); then
					printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
				else
					printf "%s\n" "${temparray[@]}" > "$inputfilename"
					echo "Warning: \"$inputfilename\" has been saved with UTF-8 encoding"
				fi
				unset temparray ;;
		esac
	else
		case "$subtitleis" in
			"srt")
				read_srt "$inputfilename"
				temparray=( $(printf "%s\n" "${arraysrt[@]}" | iconv -f $encoding -t utf-8 | sed -b s"/$replace1/$replace2/ig") )
				# If the conversion from UTF-8 to the original encoding isn't possible, keep the UTF-8
				printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding &> /dev/null
				if (($? == 0)); then
					printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
				else
					printf "%s\n" "${temparray[@]}" > "$inputfilename"
					echo "Warning: \"$inputfilename\" has been saved with UTF-8 encoding"
				fi
				unset temparray ;;
			"sub")
				read_sub "$inputfilename"
				temparray=( $(printf "%s\n" "${arraysub[@]}" | sed -b s"/$replace1/$replace2/ig") )
				# If the conversion from UTF-8 to the original encoding isn't possible, keep the UTF-8
				printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding &> /dev/null
				if (($? == 0)); then
					printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
				else
					printf "%s\n" "${temparray[@]}" > "$inputfilename"
					echo "Warning: \"$inputfilename\" has been saved with UTF-8 encoding"
				fi
				unset temparray ;;
		esac
	fi

	IFS=$old_IFS		# restore default field separator
}


sub2_srt ()
{
	if [[ $sub2srt == "pal" ]]; then ratio=1; fps=25025
	elif [[ $sub2srt == "film" ]]; then ratio=1; fps=24000
	elif [[ $sub2srt == "ntsc" ]]; then ratio=1; fps=30000
	elif [[ $sub2srt =~ ^[0-9]+$ ]]; then ratio=1; fps=$(($sub2srt * 1001))
	elif [[ $sub2srt =~ ^[0-9]+\.[0-9]*$ ]]; then fpsint=${sub2srt%.*}; fpsdecimal=${sub2srt##*.}; decimallength=${#fpsdecimal}; if (( $decimallength == 0 )); then ratio=1; else ratio=1$(eval printf '0%.0s' {1..$decimallength}); fi; fps=$(($(echo $fpsint$fpsdecimal) * 1001))
	else echo -e "Error: The sub2srt parameter only accepts the arguments pal, film, ntsc or a custom framerate.\n       Pal = 25, film = 23.976 and ntsc = 29.970"; exit 1
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraysub
	read_sub "$inputfilename"

	# Check if the sub is OK
	newfilename="${inputfilename%.*}.srt"
	check_sub "$inputfilename" "Converting \"$inputfilename\" to \"$newfilename\"..."

	# Exit this function if the return code of check_sub is not 0
	if (($? != 0)); then
		return 1
	fi

	# Process the arraysub and at the same time create the arraysrt
	arraysrt=()
	linecounter=0
	IFS=$'|'			# new field separator, the new line character in sub file
	tag="\{(c|C|s|S|f|F|P|y|Y):[0-9a-zA-Z$,]+\}"
	regextags="^($tag){1}($tag)?($tag)?($tag)?($tag)?($tag)?($tag)?($tag)?(.+)$"

	for ((i=0; i<=${#arraysub[@]}-1; i++)); do
		line=${arraysub[$i]}

		if ! [[ $line =~ $regexsub1 ]] && [[ $line =~ $regexsub ]]; then
			framesstart="${BASH_REMATCH[1]}"
			framesend="${BASH_REMATCH[2]}"
			subs="${BASH_REMATCH[3]}"

			p1=$((1001000 * $ratio * $framesstart / $fps))
			p2=$((1001000 * $ratio * $framesend / $fps))

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1 / 3600000)) $(($(($p1 % 3600000)) / 60000)) $(($(($p1 % 60000)) / 1000)) $(($p1 % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2 / 3600000)) $(($(($p2 % 3600000)) / 60000)) $(($(($p2 % 60000)) / 1000)) $(($p2 % 1000)))

			read -r -a arraysubs <<< "$subs"

			for ((j=0; j<=${#arraysubs[@]}-1; j++)); do
				text=${arraysubs[$j]}

				if [[ $text =~ $regextags ]]; then
					tagvalue1="${BASH_REMATCH[1]}"
					tag1="${BASH_REMATCH[2]}"
					tagvalue2="${BASH_REMATCH[3]}"
					tag2="${BASH_REMATCH[4]}"
					tagvalue3="${BASH_REMATCH[5]}"
					tag3="${BASH_REMATCH[6]}"
					tagvalue4="${BASH_REMATCH[7]}"
					tag4="${BASH_REMATCH[8]}"
					tagvalue5="${BASH_REMATCH[9]}"
					tag5="${BASH_REMATCH[10]}"
					tagvalue6="${BASH_REMATCH[11]}"
					tag6="${BASH_REMATCH[12]}"
					tagvalue7="${BASH_REMATCH[13]}"
					tag7="${BASH_REMATCH[14]}"
					tagvalue8="${BASH_REMATCH[15]}"
					tag8="${BASH_REMATCH[16]}"
					justtext="${BASH_REMATCH[17]}"

					# Remove tags that are in-between the text.
					unnecessarytags="(.*)\{(c|C|s|S|f|F|P|y|Y):[0-9a-zA-Z$,]+\}(.*)"
					while [[ $justtext =~ $unnecessarytags ]]; do
						justtext=${BASH_REMATCH[1]}${BASH_REMATCH[3]}
					done

					# Remove tags that are ignored (position, font).
					arraysubs[$j]=$justtext

					# In YYY we gather the tags that affect all lines and in yyy the tags that affect only one line.
					YYY=""
					yyy=""

					if [[ $tag1 == "Y" ]]; then YYY+=$tagvalue1; fi
					if [[ $tag2 == "Y" ]]; then YYY+=$tagvalue2; fi
					if [[ $tag3 == "Y" ]]; then YYY+=$tagvalue3; fi
					if [[ $tag4 == "Y" ]]; then YYY+=$tagvalue4; fi
					if [[ $tag5 == "Y" ]]; then YYY+=$tagvalue5; fi
					if [[ $tag6 == "Y" ]]; then YYY+=$tagvalue6; fi
					if [[ $tag7 == "Y" ]]; then YYY+=$tagvalue7; fi
					if [[ $tag8 == "Y" ]]; then YYY+=$tagvalue8; fi

					if [[ $tag1 == "y" ]]; then yyy+=$tagvalue1; fi
					if [[ $tag2 == "y" ]]; then yyy+=$tagvalue2; fi
					if [[ $tag3 == "y" ]]; then yyy+=$tagvalue3; fi
					if [[ $tag4 == "y" ]]; then yyy+=$tagvalue4; fi
					if [[ $tag5 == "y" ]]; then yyy+=$tagvalue5; fi
					if [[ $tag6 == "y" ]]; then yyy+=$tagvalue6; fi
					if [[ $tag7 == "y" ]]; then yyy+=$tagvalue7; fi
					if [[ $tag8 == "y" ]]; then yyy+=$tagvalue8; fi

					suffix=""
					case ${YYY,,} in
						*"s"*) justtext="<s>"$justtext; arraysubs[$j]=$justtext; suffix+="</s>" ;;&
						*"u"*) justtext="<u>"$justtext; arraysubs[$j]=$justtext; suffix+="</u>" ;;&
						*"b"*) justtext="<b>"$justtext; arraysubs[$j]=$justtext; suffix+="</b>" ;;&
						*"i"*) justtext="<i>"$justtext; arraysubs[$j]=$justtext; suffix+="</i>" ;;
					esac
					arraysubs[-1]+=$suffix
					if ((${#arraysubs[@]} == 1)); then
						justtext+=$suffix
					fi
					suffix=""

					case ${yyy,,} in
						*"s"*) justtext="<s>"$justtext"</s>"; arraysubs[$j]=$justtext ;;&
						*"u"*) justtext="<u>"$justtext"</u>"; arraysubs[$j]=$justtext ;;&
						*"b"*) justtext="<b>"$justtext"</b>"; arraysubs[$j]=$justtext ;;&
						*"i"*) justtext="<i>"$justtext"</i>"; arraysubs[$j]=$justtext ;;
					esac

					# COLOR is the tag that affect all lines and color the tag that affect only one line.
					COLOR=""
					color=""

					if [[ $tag1 == "C" ]]; then COLOR=$tagvalue1; fi
					if [[ $tag2 == "C" ]]; then COLOR=$tagvalue2; fi
					if [[ $tag3 == "C" ]]; then COLOR=$tagvalue3; fi
					if [[ $tag4 == "C" ]]; then COLOR=$tagvalue4; fi
					if [[ $tag5 == "C" ]]; then COLOR=$tagvalue5; fi
					if [[ $tag6 == "C" ]]; then COLOR=$tagvalue6; fi
					if [[ $tag7 == "C" ]]; then COLOR=$tagvalue7; fi
					if [[ $tag8 == "C" ]]; then COLOR=$tagvalue8; fi

					if [[ $tag1 == "c" ]]; then color=$tagvalue1; fi
					if [[ $tag2 == "c" ]]; then color=$tagvalue2; fi
					if [[ $tag3 == "c" ]]; then color=$tagvalue3; fi
					if [[ $tag4 == "c" ]]; then color=$tagvalue4; fi
					if [[ $tag5 == "c" ]]; then color=$tagvalue5; fi
					if [[ $tag6 == "c" ]]; then color=$tagvalue6; fi
					if [[ $tag7 == "c" ]]; then color=$tagvalue7; fi
					if [[ $tag8 == "c" ]]; then color=$tagvalue8; fi


					regexsubcolor="[$]([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})"
					if [[ $COLOR =~ $regexsubcolor ]]; then
						COLOR="\"#${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}\""
						COLOR=${COLOR,,}
					else
						COLOR=""
					fi

					if [[ $color =~ $regexsubcolor ]]; then
						color="\"#${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}\""
						color=${color,,}
					else
						color=""
					fi

					# SIZE is the tag that affect all lines and size the tag that affect only one line.
					SIZE=""
					size=""

					if [[ $tag1 == "S" ]]; then SIZE=$tagvalue1; fi
					if [[ $tag2 == "S" ]]; then SIZE=$tagvalue2; fi
					if [[ $tag3 == "S" ]]; then SIZE=$tagvalue3; fi
					if [[ $tag4 == "S" ]]; then SIZE=$tagvalue4; fi
					if [[ $tag5 == "S" ]]; then SIZE=$tagvalue5; fi
					if [[ $tag6 == "S" ]]; then SIZE=$tagvalue6; fi
					if [[ $tag7 == "S" ]]; then SIZE=$tagvalue7; fi
					if [[ $tag8 == "S" ]]; then SIZE=$tagvalue8; fi

					if [[ $tag1 == "s" ]]; then size=$tagvalue1; fi
					if [[ $tag2 == "s" ]]; then size=$tagvalue2; fi
					if [[ $tag3 == "s" ]]; then size=$tagvalue3; fi
					if [[ $tag4 == "s" ]]; then size=$tagvalue4; fi
					if [[ $tag5 == "s" ]]; then size=$tagvalue5; fi
					if [[ $tag6 == "s" ]]; then size=$tagvalue6; fi
					if [[ $tag7 == "s" ]]; then size=$tagvalue7; fi
					if [[ $tag8 == "s" ]]; then size=$tagvalue8; fi

					regexsubsize="([0-9]+)"
					if [[ $SIZE =~ $regexsubsize ]]; then
						SIZE="\"${BASH_REMATCH[1]}\""
					else
						SIZE=""
					fi

					if [[ $size =~ $regexsubsize ]]; then
						size="\"${BASH_REMATCH[1]}\""
					else
						size=""
					fi


					if [[ $COLOR ]] && [[ $SIZE ]] ; then
						justtext="<font color=$COLOR size=$SIZE>"$justtext
						arraysubs[$j]=$justtext
						suffix+="</font>"
						arraysubs[-1]+=$suffix
					elif [[ $COLOR ]]; then
						justtext="<font color=$COLOR>"$justtext
						arraysubs[$j]=$justtext
						suffix+="</font>"
						arraysubs[-1]+=$suffix
					elif [[ $SIZE ]] ; then
						justtext="<font size=$SIZE>"$justtext
						arraysubs[$j]=$justtext
						suffix+="</font>"
						arraysubs[-1]+=$suffix
					fi

					if [[ $color ]] && [[ $size ]] ; then
						justtext="<font color=$color size=$size>"$justtext"</font>"
						arraysubs[$j]=$justtext
					elif [[ $color ]]; then
						justtext="<font color=$color>"$justtext"</font>"
						arraysubs[$j]=$justtext
					elif [[ $size ]] ; then
						justtext="<font size=$size>"$justtext"</font>"
						arraysubs[$j]=$justtext
					fi
				fi
			done

			((linecounter++))
			arraysrt+=("$linecounter")
			arraysrt+=("$j1 --> $j2")
			arraysrt+=("${arraysubs[@]}")
			arraysrt+=("")
		fi
	done

	IFS=$old_IFS		# restore default field separator

	# Remove an empty line at the end
	if [[ ${arraysrt[-1]} =~ $regexemptyline ]]; then
		unset arraysrt[-1]
	fi

	# Write to the txt file the contents of array.
	if (( ${#arraysrt[@]} > 2 )); then
		printf "%s\r\n" "${arraysrt[@]}" | iconv -f utf-8 -t $encoding > "$newfilename"
	else
		echo "Error: Not a valid sub file"; return 1
	fi
}


srt2_sub ()
{
	if [[ $srt2sub == "pal" ]]; then ratio=1; fps=25025; firstline="{1}{1}25.000"
	elif [[ $srt2sub == "film" ]]; then ratio=1; fps=24000; firstline="{1}{1}23.976"
	elif [[ $srt2sub == "ntsc" ]]; then ratio=1; fps=30000; firstline="{1}{1}29.970"
	elif [[ $srt2sub =~ ^[0-9]+$ ]]; then ratio=1; fps=$(($srt2sub * 1001)); firstline="{1}{1}$srt2sub.000"
	elif [[ $srt2sub =~ ^[0-9]+\.[0-9]*$ ]]; then fpsint=${srt2sub%.*}; fpsdecimal=${srt2sub##*.}; decimallength=${#fpsdecimal}; if (( $decimallength == 0 )); then ratio=1; trizero="000"; firstline="{1}{1}$srt2sub$trizero"; else ratio=1$(eval printf '0%.0s' {1..$decimallength}); firstline="{1}{1}$srt2sub"; fi; fps=$(($(echo $fpsint$fpsdecimal) * 1001))
	else echo -e "Error: The srt2sub parameter only accepts the arguments pal, film, ntsc or a custom framerate.\n       Pal = 25, film = 23.976 and ntsc = 29.970"; exit 1
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# The encoding must be UTF-8
	IFS=$'\n'
	temparraysrt=( $(printf "%s\n" "${arraysrt[@]}" | iconv -f $encoding -t utf-8) )
	unset arraysrt
	arraysrt+=("${temparraysrt[@]}")
	unset temparraysrt

	# Check if the srt is OK
	newfilename="${inputfilename%.*}.sub"
	check_srt "$inputfilename" "Converting \"$inputfilename\" to \"$newfilename\"..."

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Remove non necessary lines
	newarraysrt=()
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		if [[ ${arraysrt[$(($i + 1))]} =~ $regextime ]] || [[ ${arraysrt[$(($i + 2))]} =~ $regextime ]]; then
			:
		else
			newarraysrt+=(${arraysrt[$i]})
		fi
	done


	# Assosiative array of color names converted to values used by the sub subtitles
	declare -A colornames

	colornames[indianred]="\$5C5CCD"
	colornames[lightcoral]="\$8080F0"
	colornames[salmon]="\$7280FA"
	colornames[darksalmon]="\$7A96E9"
	colornames[lightsalmon]="\$7AA0FF"
	colornames[crimson]="\$3C14DC"
	colornames[red]="\$0000FF"
	colornames[firebrick]="\$2222B2"
	colornames[darkred]="\$00008B"
	colornames[pink]="\$CBC0FF"
	colornames[lightpink]="\$C1B6FF"
	colornames[hotpink]="\$B469FF"
	colornames[deeppink]="\$9314FF"
	colornames[mediumvioletred]="\$8515C7"
	colornames[palevioletred]="\$9370DB"
	colornames[lightsalmon]="\$7AA0FF"
	colornames[coral]="\$507FFF"
	colornames[tomato]="\$4763FF"
	colornames[orangered]="\$0045FF"
	colornames[darkorange]="\$008CFF"
	colornames[orange]="\$00A5FF"
	colornames[gold]="\$00D7FF"
	colornames[yellow]="\$00FFFF"
	colornames[lightyellow]="\$E0FFFF"
	colornames[lemonchiffon]="\$CDFAFF"
	colornames[lightgoldenrodyellow]="\$D2FAFA"
	colornames[papayawhip]="\$D5EFFF"
	colornames[moccasin]="\$B5E4FF"
	colornames[peachpuff]="\$B9DAFF"
	colornames[palegoldenrod]="\$AAE8EE"
	colornames[khaki]="\$8CE6F0"
	colornames[darkkhaki]="\$6BB7BD"
	colornames[lavender]="\$FAE6E6"
	colornames[thistle]="\$D8BFD8"
	colornames[plum]="\$DDA0DD"
	colornames[violet]="\$EE82EE"
	colornames[orchid]="\$D670DA"
	colornames[fuchsia]="\$FF00FF"
	colornames[magenta]="\$FF00FF"
	colornames[mediumorchid]="\$D355BA"
	colornames[mediumpurple]="\$DB7093"
	colornames[rebeccapurple]="\$993366"
	colornames[blueviolet]="\$E22B8A"
	colornames[darkviolet]="\$D30094"
	colornames[darkorchid]="\$CC3299"
	colornames[darkmagenta]="\$8B008B"
	colornames[purple]="\$800080"
	colornames[indigo]="\$82004B"
	colornames[slateblue]="\$CD5A6A"
	colornames[darkslateblue]="\$8B3D48"
	colornames[mediumslateblue]="\$EE687B"
	colornames[greenyellow]="\$2FFFAD"
	colornames[chartreuse]="\$00FF7F"
	colornames[lawngreen]="\$00FC7C"
	colornames[lime]="\$00FF00"
	colornames[limegreen]="\$32CD32"
	colornames[palegreen]="\$98FB98"
	colornames[lightgreen]="\$90EE90"
	colornames[mediumspringgreen]="\$9AFA00"
	colornames[springgreen]="\$7FFF00"
	colornames[mediumseagreen]="\$71B33C"
	colornames[seagreen]="\$578B2E"
	colornames[forestgreen]="\$228B22"
	colornames[green]="\$008000"
	colornames[darkgreen]="\$006400"
	colornames[yellowgreen]="\$32CD9A"
	colornames[olivedrab]="\$238E6B"
	colornames[olive]="\$008080"
	colornames[darkolivegreen]="\$2F6B55"
	colornames[mediumaquamarine]="\$AACD66"
	colornames[darkseagreen]="\$8BBC8F"
	colornames[lightseagreen]="\$AAB220"
	colornames[darkcyan]="\$8B8B00"
	colornames[teal]="\$808000"
	colornames[aqua]="\$FFFF00"
	colornames[cyan]="\$FFFF00"
	colornames[lightcyan]="\$FFFFE0"
	colornames[paleturquoise]="\$EEEEAF"
	colornames[aquamarine]="\$D4FF7F"
	colornames[turquoise]="\$D0E040"
	colornames[mediumturquoise]="\$CCD148"
	colornames[darkturquoise]="\$D1CE00"
	colornames[cadetblue]="\$A09E5F"
	colornames[steelblue]="\$B48246"
	colornames[lightsteelblue]="\$DEC4B0"
	colornames[powderblue]="\$E6E0B0"
	colornames[lightblue]="\$E6D8AD"
	colornames[skyblue]="\$EBCE87"
	colornames[lightskyblue]="\$FACE87"
	colornames[deepskyblue]="\$FFBF00"
	colornames[dodgerblue]="\$FF901E"
	colornames[cornflowerblue]="\$ED9564"
	colornames[mediumslateblue]="\$EE687B"
	colornames[royalblue]="\$E16941"
	colornames[blue]="\$FF0000"
	colornames[mediumblue]="\$CD0000"
	colornames[darkblue]="\$8B0000"
	colornames[navy]="\$800000"
	colornames[midnightblue]="\$701919"
	colornames[cornsilk]="\$DCF8FF"
	colornames[blanchedalmond]="\$CDEBFF"
	colornames[bisque]="\$C4E4FF"
	colornames[navajowhite]="\$ADDEFF"
	colornames[wheat]="\$B3DEF5"
	colornames[burlywood]="\$87B8DE"
	colornames[tan]="\$8CB4D2"
	colornames[rosybrown]="\$8F8FBC"
	colornames[sandybrown]="\$60A4F4"
	colornames[goldenrod]="\$20A5DA"
	colornames[darkgoldenrod]="\$0B86B8"
	colornames[peru]="\$3F85CD"
	colornames[chocolate]="\$1E69D2"
	colornames[saddlebrown]="\$13458B"
	colornames[sienna]="\$2D52A0"
	colornames[brown]="\$2A2AA5"
	colornames[maroon]="\$000080"
	colornames[white]="\$FFFFFF"
	colornames[snow]="\$FAFAFF"
	colornames[honeydew]="\$F0FFF0"
	colornames[mintcream]="\$FAFFF5"
	colornames[azure]="\$FFFFF0"
	colornames[aliceblue]="\$FFF8F0"
	colornames[ghostwhite]="\$FFF8F8"
	colornames[whitesmoke]="\$F5F5F5"
	colornames[seashell]="\$EEF5FF"
	colornames[beige]="\$DCF5F5"
	colornames[oldlace]="\$E6F5FD"
	colornames[floralwhite]="\$F0FAFF"
	colornames[ivory]="\$F0FFFF"
	colornames[antiquewhite]="\$D7EBFA"
	colornames[linen]="\$E6F0FA"
	colornames[lavenderblush]="\$F5F0FF"
	colornames[mistyrose]="\$E1E4FF"
	colornames[gainsboro]="\$DCDCDC"
	colornames[lightgray]="\$D3D3D3"
	colornames[silver]="\$C0C0C0"
	colornames[darkgray]="\$A9A9A9"
	colornames[gray]="\$808080"
	colornames[dimgray]="\$696969"
	colornames[lightslategray]="\$998877"
	colornames[slategray]="\$908070"
	colornames[darkslategray]="\$4F4F2F"
	colornames[black]="\$000000"


	# Process the newarraysrt and at the same time create the arraysub
	IFS=$'\r'
	elementsub=()
	stringsub=()
	framesub=""
	arraysub=()
	arraysub+=($firstline)

	# Regular expression of srt color code
	regexsrtcolor="([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})"

	# Regular expressions for srt tags. They contain possible sub tags because inside the loop they co-exist
	regex_tag_i="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[bus]>)*(<font[^>]*>)*(<[bus]>)*)<i>(.*)</i>((</[bus]>)*(</font>)*(</[bus]>)*)$"
	regex_tag_b="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ius]>)*(<font[^>]*>)*(<[ius]>)*)<b>(.*)</b>((</[ius]>)*(</font>)*(</[ius]>)*)$"
	regex_tag_u="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibs]>)*(<font[^>]*>)*(<[ibs]>)*)<u>(.*)</u>((</[ibs]>)*(</font>)*(</[ibs]>)*)$"
	regex_tag_s="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibu]>)*(<font[^>]*>)*(<[ibu]>)*)<s>(.*)</s>((</[ibu]>)*(</font>)*(</[ibu]>)*)$"
	regex_tag_font_color="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*color[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*#?[[:blank:]]*([^> \"]*)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"
	regex_tag_font_size="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*size[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*([0-9]+)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"
	regex_tag_font_color_size="^(\|?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*color[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*#?[[:blank:]]*([^> \"]*)[[:blank:]]*\"?[[:blank:]]*size[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*([0-9]+)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"
	regex_tag_font_size_color="^(\|?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*size[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*([0-9]+)[[:blank:]]*\"?[[:blank:]]*color[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*#?[[:blank:]]*([^> \"]*)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"

	# Regular expressions for multiple tags that need to become one
	regex_merge_y_tags="^(\|?(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?)({y:([ibus])})?({y:([ibus])})?({y:([ibus])})?({y:([ibus])})?(.*)$"
	regex_merge_Y_tags="^((\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?)({Y:([ibus])})?({Y:([ibus])})?({Y:([ibus])})?({Y:([ibus])})?(.*)$"

	# Regular expression for removing the remaining srt tags
	regexremove="(.*)<[/]?([ibus]|font[^>]*)>(.*)"

	# This was put inside a function because it needs to run twice
	add_arraysub_element ()
	{
		for j in "${elementsub[@]}"; do
			# Search for "<font color ... size>" and "</font>", remove them from the text and add {C:$xxxxxx}{S:xx} if the subtitle is 1 line or {c:$xxxxxx}{s:xx} if it's more
			if [[ $j =~ $regex_tag_font_color_size ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
				srtcolor=${BASH_REMATCH[5]}
				size=${BASH_REMATCH[6]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

				for colorname in "${!colornames[@]}"; do
					if [[ $colorname == ${srtcolor,,} ]]; then
						colornamefound=$colorname
						break
					fi
				done

				if [[ $colornamefound ]]; then
					subcolor=${colornames[$colornamefound]}
					unset colornamefound
				elif [[ $srtcolor =~ $regexsrtcolor ]]; then
					subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
					subcolor=${subcolor^^}
				else
					subcolor=""
				fi

				if [[ $subcolor ]] && [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}{S:$size}$temptext2"
					else
						j="$temptext1{c:$subcolor}{s:$size}$temptext2"
					fi
				elif [[ $subcolor ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}$temptext2"
					else
						j="$temptext1{c:$subcolor}$temptext2"
					fi
				elif [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font size ... color>" and "</font>", remove them from the text and add {C:$xxxxxx}{S:xx} if the subtitle is 1 line or {c:$xxxxxx}{s:xx} if it's more
			if [[ $j =~ $regex_tag_font_size_color ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
				size=${BASH_REMATCH[5]}
				srtcolor=${BASH_REMATCH[6]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

				for colorname in "${!colornames[@]}"; do
					if [[ $colorname == ${srtcolor,,} ]]; then
						colornamefound=$colorname
						break
					fi
				done

				if [[ $colornamefound ]]; then
					subcolor=${colornames[$colornamefound]}
					unset colornamefound
				elif [[ $srtcolor =~ $regexsrtcolor ]]; then
					subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
					subcolor=${subcolor^^}
				else
					subcolor=""
				fi

				if [[ $subcolor ]] && [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}{S:$size}$temptext2"
					else
						j="$temptext1{c:$subcolor}{s:$size}$temptext2"
					fi
				elif [[ $subcolor ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}$temptext2"
					else
						j="$temptext1{c:$subcolor}$temptext2"
					fi
				elif [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font size>" and "</font>", remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
			# This runs below a second time - not a mistake
			if [[ $j =~ $regex_tag_font_size ]]; then
				size=${BASH_REMATCH[8]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

				if [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font color>" and "</font>", remove them from the text and add {C:$xxxxxx} if the subtitle is 1 line or {c:$xxxxxx} if it's more
			if [[ $j =~ $regex_tag_font_color ]]; then
				srtcolor=${BASH_REMATCH[8]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

				for colorname in "${!colornames[@]}"; do
					if [[ $colorname == ${srtcolor,,} ]]; then
						colornamefound=$colorname
						break
					fi
				done

				if [[ $colornamefound ]]; then
					subcolor=${colornames[$colornamefound]}
					unset colornamefound
				elif [[ $srtcolor =~ $regexsrtcolor ]]; then
					subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
					subcolor=${subcolor^^}
				else
					subcolor=""
				fi

				if [[ $subcolor ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}$temptext2"
					else
						j="$temptext1{c:$subcolor}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font size>" and "</font>", remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
			if [[ $j =~ $regex_tag_font_size ]]; then
				size=${BASH_REMATCH[8]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

				if [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<i>" and "</i>", remove them from the text and add {Y:i} if the subtitle is 1 line or {y:i} if it's more
			if [[ $j =~ $regex_tag_i ]] && ! [[ ${BASH_REMATCH[10]} == *"<i>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</i>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:i}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:i}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Search for "<b>" and "</b>", remove them from the text and add {Y:b} if the subtitle is 1 line or {y:b} if it's more
			if [[ $j =~ $regex_tag_b ]] && ! [[ ${BASH_REMATCH[10]} == *"<b>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</b>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:b}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:b}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Search for "<u>" and "</u>", remove them from the text and add {Y:u} if the subtitle is 1 line or {y:u} if it's more
			if [[ $j =~ $regex_tag_u ]] && ! [[ ${BASH_REMATCH[10]} == *"<u>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</u>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:u}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:u}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Search for "<s>" and "</s>", remove them from the text and add {Y:s} if the subtitle is 1 line or {y:s} if it's more
			if [[ $j =~ $regex_tag_s ]] && ! [[ ${BASH_REMATCH[10]} == *"<s>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</s>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:s}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:s}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Merge multiple y tags
			if [[ $j =~ $regex_merge_y_tags ]] && [[ ${BASH_REMATCH[4]} ]]; then
				j="${BASH_REMATCH[1]}{y:${BASH_REMATCH[5]}${BASH_REMATCH[7]}${BASH_REMATCH[9]}${BASH_REMATCH[11]}}${BASH_REMATCH[12]}"
			fi

			stringsub=${stringsub:+$stringsub}$j
		done

		# Search for "<s>" and "</s>" that enclose all lines, remove them from the text and add {Y:s}
		if [[ $stringsub =~ $regex_tag_s ]] && ! [[ ${BASH_REMATCH[10]} == *"<s>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</s>"* ]]; then
			stringsub="{Y:s}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<u>" and "</u>" that enclose all lines, remove them from the text and add {Y:u}
		if [[ $stringsub =~ $regex_tag_u ]] && ! [[ ${BASH_REMATCH[10]} == *"<u>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</u>"* ]]; then
			stringsub="{Y:u}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<b>" and "</b>" that enclose all lines, remove them from the text and add {Y:b}
		if [[ $stringsub =~ $regex_tag_b ]] && ! [[ ${BASH_REMATCH[10]} == *"<b>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</b>"* ]]; then
			stringsub="{Y:b}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<i>" and "</i>" that enclose all lines, remove them from the text and add {Y:i}
		if [[ $stringsub =~ $regex_tag_i ]] && ! [[ ${BASH_REMATCH[10]} == *"<i>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</i>"* ]]; then
			stringsub="{Y:i}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<font color ... size>" and "</font>" that enclose all lines, remove them from the text and add {C:$xxxxxx}{S:xx}
		if [[ $stringsub =~ $regex_tag_font_color_size ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
			srtcolor=${BASH_REMATCH[5]}
			size=${BASH_REMATCH[6]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

			for colorname in "${!colornames[@]}"; do
				if [[ $colorname == ${srtcolor,,} ]]; then
					colornamefound=$colorname
					break
				fi
			done

			if [[ $colornamefound ]]; then
				subcolor=${colornames[$colornamefound]}
				unset colornamefound
			elif [[ $srtcolor =~ $regexsrtcolor ]]; then
				subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
				subcolor=${subcolor^^}
			else
				subcolor=""
			fi

			if [[ $subcolor ]] && [[ $size ]]; then
				stringsub="{C:$subcolor}{S:$size}$temptext"
			elif [[ $subcolor ]]; then
				stringsub="{C:$subcolor}$temptext"
			elif [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font size ... color>" and "</font>" that enclose all lines, remove them from the text and add {C:$xxxxxx}{S:xx}
		if [[ $stringsub =~ $regex_tag_font_size_color ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
			size=${BASH_REMATCH[5]}
			srtcolor=${BASH_REMATCH[6]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

			for colorname in "${!colornames[@]}"; do
				if [[ $colorname == ${srtcolor,,} ]]; then
					colornamefound=$colorname
					break
				fi
			done

			if [[ $colornamefound ]]; then
				subcolor=${colornames[$colornamefound]}
				unset colornamefound
			elif [[ $srtcolor =~ $regexsrtcolor ]]; then
				subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
				subcolor=${subcolor^^}
			else
				subcolor=""
			fi

			if [[ $subcolor ]] && [[ $size ]]; then
				stringsub="{C:$subcolor}{S:$size}$temptext"
			elif [[ $subcolor ]]; then
				stringsub="{C:$subcolor}$temptext"
			elif [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font size>" and "</font>" that enclose all lines, remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
		# This runs below a second time - not a mistake
		if [[ $stringsub =~ $regex_tag_font_size ]]; then
			size=${BASH_REMATCH[8]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

			if [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font color>" and "</font>" that enclose all lines, remove them from the text and add {C:$xxxxxx}
		if [[ $stringsub =~ $regex_tag_font_color ]]; then
			srtcolor=${BASH_REMATCH[8]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}
			for colorname in "${!colornames[@]}"; do
				if [[ $colorname == ${srtcolor,,} ]]; then
					colornamefound=$colorname
					break
				fi
			done

			if [[ $colornamefound ]]; then
				subcolor=${colornames[$colornamefound]}
				unset colornamefound
			elif [[ $srtcolor =~ $regexsrtcolor ]]; then
				subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
				subcolor=${subcolor^^}
			else
				subcolor=""
			fi

			if [[ $subcolor ]]; then
				stringsub="{C:$subcolor}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font size>" and "</font>" that enclose all lines, remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
		if [[ $stringsub =~ $regex_tag_font_size ]]; then
			size=${BASH_REMATCH[8]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

			if [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Merge multiple Y tags
		if [[ $stringsub =~ $regex_merge_Y_tags ]] && [[ ${BASH_REMATCH[4]} ]]; then
			stringsub="${BASH_REMATCH[1]}{Y:${BASH_REMATCH[5]}${BASH_REMATCH[7]}${BASH_REMATCH[9]}${BASH_REMATCH[11]}}${BASH_REMATCH[12]}"
		fi

		# Remove the remaining srt tags
		if [[ $srt2sub_delsrttags ]]; then
			while [[ $stringsub =~ $regexremove ]]; do
				stringsub=${BASH_REMATCH[1]}${BASH_REMATCH[3]}
			done
		fi

		arraysub+=($framesub$stringsub)
	}

	for ((i=0; i<${#newarraysrt[@]}; i++)); do
		line=${newarraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			framesstart=$(($fps * $p1 / (($ratio * 1001000))))
			framesend=$(($fps * $p2 / (($ratio * 1001000))))

			add_arraysub_element

			unset elementsub
			stringsub=""

			framesub="{$framesstart}{$framesend}"

		elif [[ $elementsub ]]; then
			elementsub+=(\|$line)
		else
			elementsub+=($line)
		fi
	done

	# Run for the last subtitle
	add_arraysub_element

	# Write to the txt file the contents of array.
	if (( ${#arraysub[@]} >= 1 )); then
		printf "%s\r\n" "${arraysub[@]}" | iconv -f utf-8 -t $encoding > "$newfilename"
	else
		echo "Error: Not a valid srt file"; return 1
	fi
	IFS=$old_IFS		# restore default field separator
}


join_srt ()
{
	# Check if the input file is a text
	check_file "$joinsrt"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Encoding of the join file
	encodingjoin=$encoding

	# Read text file to arraysrt
	read_srt "$joinsrt"

	# Check if the srt is OK
	check_srt "$joinsrt"

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Create arraysrtjoin from arraysrt
	arraysrtjoin+=("${arraysrt[@]}")


	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Encoding of the input file
	encodinginput=$encoding

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	check_srt "$inputfilename"

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi


	# Compare the encodings of the two files and convert to UTF-8 if necessary
	if [[ ${encodinginput,,} != ${encodingjoin,,} ]]; then
		IFS=$'\n'
		echo "Warning: The two files have different encodings (${encodinginput^^} and ${encodingjoin^^}). The output file will be UTF-8."
		if [[ ${encodinginput,,} != "utf-8" ]]; then
			temparraysrt=( $(printf "%s\n" "${arraysrt[@]}" | iconv -f $encodinginput -t utf-8) )
			unset arraysrt
			arraysrt+=("${temparraysrt[@]}")
			unset temparraysrt
		fi

		if [[ ${encodingjoin,,} != "utf-8" ]]; then
			temparraysrtjoin=( $(printf "%s\n" "${arraysrtjoin[@]}" | iconv -f $encodingjoin -t utf-8) )
			unset arraysrtjoin
			arraysrtjoin+=("${temparraysrtjoin[@]}")
			unset temparraysrtjoin
		fi
		IFS=$old_IFS
	fi


	# Add an empty line
	arraysrt+=("$cr")

	if ! [[ $jointime ]]; then
		echo "Joining \"$inputfilename\" with \"$joinsrt\"..."
		# Re-create the second subtitle array with new counter
		for ((i=0; i<=${#arraysrtjoin[@]}; i++)); do
			if [[ ${arraysrtjoin[$((i+1))]} =~ $regextime ]] && [[ ${arraysrtjoin[$i]} =~ $regexinteger ]]; then
				((subcounter++))
				arraysrtjoin[$i]="$subcounter$cr"
			fi
		done
	else
		# Calculate the time of the end time of the last subtitle of the first file
		for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h2b="${BASH_REMATCH[5]}"
				m2b="${BASH_REMATCH[6]}"
				s2b="${BASH_REMATCH[7]}"
				f2b="${BASH_REMATCH[8]}"

				break
			fi
		done

		# Time in milliseconds of the end time of the last subtitle of the first file
		p2b=$(($(($((10#$h2b)) * 3600000)) + $(($((10#$m2b)) * 60000)) + $(($((10#$s2b)) * 1000)) + $((10#$f2b))))


		# Calculate the time to shift the second subtitle
		regexjoin="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

		if [[ $jointime =~ $regexjoin ]]; then
			h="${BASH_REMATCH[1]}"
			m="${BASH_REMATCH[2]}"
			s="${BASH_REMATCH[3]}"
			f="${BASH_REMATCH[4]}"
		else
			echo "Error: Syntax must be like 'hh:mm:ss,fff'"; exit 1
		fi

		if (( 10#$m >= 60 )) || (( 10#$s >= 60 )); then
			echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
		fi

		# Time in milliseconds of jointime
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))


		# Compare jointime with the end time of the last subtitle of the first file
		if ((p < p2b)); then
			echo "Error: The duration of the first video (-J parameter) cannot be less than the first subtitle"; exit 1
		else
			echo "Joining \"$inputfilename\" with \"$joinsrt\"..."
		fi


		# Process the array of the second subtitle
		for ((i=0; i<=${#arraysrtjoin[@]}; i++)); do
			line=${arraysrtjoin[$i]}

			if [[ $line =~ $regextime ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				h2="${BASH_REMATCH[5]}"
				m2="${BASH_REMATCH[6]}"
				s2="${BASH_REMATCH[7]}"
				f2="${BASH_REMATCH[8]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
				p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

				p1_new=$(($p1 + $p))
				p2_new=$(($p2 + $p))

				j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
				j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

				line_new="$j1 --> $j2"

				arraysrtjoin[$i]=$line_new
			fi
		done

		# Re-create the second subtitle array with new counter
		for ((i=0; i<=${#arraysrtjoin[@]}; i++)); do
			if [[ ${arraysrtjoin[$((i+1))]} =~ $regextime ]] && [[ ${arraysrtjoin[$i]} =~ $regexinteger ]]; then
				((subcounter++))
				arraysrtjoin[$i]="$subcounter$cr"
			fi
		done
	fi


	# Add the second array to the first
	arraysrt+=("${arraysrtjoin[@]}")

	# Write to the txt file the contents of array.
	basename=${inputfilename%.*}
	j="_join.srt"
	printf "%s\n" "${arraysrt[@]}" > "$basename$j"
}


split_srt ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	check_srt "$inputfilename" "Splitting \"$inputfilename\"..."

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Find the first and last subtitle time
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	# Time in milliseconds of the start time of the first subtitle
	p1a=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in milliseconds of the start time of the last subtitle
	p1b=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Initialize the variables
	splitsubfound=""
	split2counter=0
	arraysrtsplit1=()
	arraysrtsplit2=()

	# Calculate the time to split the subtitle
	regexsplit1="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"
	regexsplit2="^([+-]?)([0-9]+)$"
	regexsplit3="^([+-]?)([0-9]+)[:]([0-9]+)[t]$"
	regexsplit4="^([+-]?)([0-9]+)[:]([0-9]+)[n]$"

	if [[ $splitsrt =~ $regexsplit1 ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"

		if (( 10#$m >= 60 )) || (( 10#$s >= 60 )); then
			echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
		fi

		# Time in milliseconds to split the subtitle
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
		if [[ $sign == "-" ]]; then
			p=$(($p1b - $p))
		fi

		if ((p < p1a)); then
			echo "Error: Split time cannot precede the start time of the first subtitle."; return 1
		fi

		if ((p > p1b)); then
			echo "Error: Split time cannot exceed the start time of the last subtitle."; return 1
		fi

		# Find the subtitle to make the split
		for ((i=0; i<=${#arraysrt[@]}-1; i++)); do
			line=${arraysrt[$i]}
			nextline=${arraysrt[((i+1))]}

			if ! [[ $splitsubfound ]] && [[ $nextline =~ $regextime ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))

				if ((p1 >= p)); then
					splitsubfound="True"
				fi
			fi

			if ! [[ $splitsubfound ]]; then
				arraysrtsplit1[$i]=$line
			else
				arraysrtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	elif [[ $splitsrt =~ $regexsplit2 ]]; then
		sign="${BASH_REMATCH[1]}"
		splitinteger="${BASH_REMATCH[2]}"

		if [[ $sign == "-" ]]; then
			splitinteger=$(($subcounter - $splitinteger))
		fi

		# Check if the given integer is OK
		if ((splitinteger == 0)) || ((splitinteger > ((subcounter-1)))); then
			echo "Error: The number of subtitles in the file are $subcounter. The given integer must be between or equal to 1 and $((subcounter-1))."; return 1
		fi

		# Create the two new subtitle arrays
		for ((i=0; i<=${#arraysrt[@]}-1; i++)); do
			line=${arraysrt[$i]}
			nextline=${arraysrt[((i+1))]}

			if ! [[ $splitsubfound ]] && [[ $nextline =~ $regextime ]] && [[ $line =~ $regexinteger ]]; then
				if ((${BASH_REMATCH[1]} > splitinteger)); then
					splitsubfound="True"
				fi
			fi

			if ! [[ $splitsubfound ]]; then
				arraysrtsplit1[$i]=$line
			else
				arraysrtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	elif [[ $splitsrt =~ $regexsplit3 ]]; then
		sign="${BASH_REMATCH[1]}"
		numerator="${BASH_REMATCH[2]}"
		denominator="${BASH_REMATCH[3]}"

		if ((numerator == 0)) || ((denominator == 0)) || ((numerator >= denominator)); then
			echo "Error: The numerator must be less than the denominator and both must not be 0."; exit 1
		fi

		# Time in milliseconds to split the subtitle
		if [[ $sign == "-" ]]; then
			p=$((p1b*((denominator - numerator))/denominator))
		else
			p=$((p1b*numerator/denominator))
		fi

		if ((p < p1a)); then
			echo "Error: Split time cannot precede the start time of the first subtitle."; return 1
		fi

		# Find the subtitle to make the split
		for ((i=0; i<=${#arraysrt[@]}-1; i++)); do
			line=${arraysrt[$i]}
			nextline=${arraysrt[((i+1))]}

			if ! [[ $splitsubfound ]] && [[ $nextline =~ $regextime ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))

				if ((p1 >= p)); then
					splitsubfound="True"
				fi
			fi

			if ! [[ $splitsubfound ]]; then
				arraysrtsplit1[$i]=$line
			else
				arraysrtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	elif [[ $splitsrt =~ $regexsplit4 ]]; then
		sign="${BASH_REMATCH[1]}"
		numerator="${BASH_REMATCH[2]}"
		denominator="${BASH_REMATCH[3]}"

		if ((numerator == 0)) || ((denominator == 0)) || ((numerator >= denominator)); then
			echo "Error: The numerator must be less than the denominator and both must not be 0."; exit 1
		fi

		if [[ $sign == "-" ]]; then
			if ((subcounter%2 == 1)) && ((denominator/numerator == 2)); then
				splitinteger=$((1 + subcounter*((denominator - numerator))/denominator))
			else
				splitinteger=$((subcounter*((denominator - numerator))/denominator))
			fi
		else
			if ((subcounter%2 == 1)) && ((denominator/numerator == 2)); then
				splitinteger=$((1 + subcounter*numerator/denominator))
			else
				splitinteger=$((subcounter*numerator/denominator))
			fi
		fi

		# Check if the integer is OK
		if ((splitinteger == 0)); then
			echo "Error: The fraction is too small. Exiting..."; exit 1
		fi

		# Create the two new subtitle arrays
		for ((i=0; i<=${#arraysrt[@]}-1; i++)); do
			line=${arraysrt[$i]}
			nextline=${arraysrt[((i+1))]}

			if ! [[ $splitsubfound ]] && [[ $nextline =~ $regextime ]] && [[ $line =~ $regexinteger ]]; then
				if ((${BASH_REMATCH[1]} > splitinteger)); then
					splitsubfound="True"
				fi
			fi

			if ! [[ $splitsubfound ]]; then
				arraysrtsplit1[$i]=$line
			else
				arraysrtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff' or '(+/-)SUB_INTEGER' or '(+/-)INTEGER:INTEGERt' or '(+/-)INTEGER:INTEGERn'"; exit 1
	fi


	# Re-create the second subtitle array with new counter
	subcounter=0
	for ((i=0; i<=${#arraysrtsplit2[@]}-1; i++)); do
		if [[ ${arraysrtsplit2[((i+1))]} =~ $regextime ]] && [[ ${arraysrtsplit2[$i]} =~ $regexinteger ]]; then
			((subcounter++))
			arraysrtsplit2[$i]="$subcounter$cr"
		fi
	done


	# Remove an empty line at the end
	if [[ ${arraysrtsplit1[-1]} =~ $regexemptyline ]]; then
		unset arraysrtsplit1[-1]
	fi


	# Write to the txt file the contents of the two arrays.
	basename=${inputfilename%.*}
	firstfile="_1.srt"
	secondfile="_2.srt"
	printf "%s\n" "${arraysrtsplit1[@]}" > "$basename$firstfile"
	printf "%s\n" "${arraysrtsplit2[@]}" > "$basename$secondfile"


	# If -X (splittime) exists:
	unset arraysrt
	if [[ $splittime ]]; then
		# Find the first subtitle time of the second file
		for ((i=0; i<=${#arraysrtsplit2[@]}; i++)); do
			line=${arraysrtsplit2[$i]}

			if [[ $line =~ $regextime ]]; then
				h1a="${BASH_REMATCH[1]}"
				m1a="${BASH_REMATCH[2]}"
				s1a="${BASH_REMATCH[3]}"
				f1a="${BASH_REMATCH[4]}"

				break
			fi
		done

	shifttime="-$h1a:$m1a:$s1a,$f1a"
	inputfilename="$basename$secondfile"
	shift_time
	unset shifttime
	fi
}


clean_trash ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the srt or sub is OK
	check_srt_and_sub "$inputfilename" "Cleaning \"$inputfilename\""

	# Exit this function if the return code of check_srt_and_sub is not 0
	if (($? != 0)); then
		return 1
	fi

	# If subeditrc exists...
	unset subeditrcfullpath
	if [[ -r "$HOME/.subeditrc" ]] && [[ $(grep -a -v "^#\|^$" "$HOME/.subeditrc") ]]; then
		subeditrcfullpath="$HOME/.subeditrc"
	elif [[ -r /etc/subeditrc ]] && [[ $(grep -a -v "^#\|^$" /etc/subeditrc) ]]; then
		subeditrcfullpath="/etc/subeditrc"
	fi

	if [[ $subeditrcfullpath ]]; then
		# Detect encoding of subeditrc
		encodingrc=$(file -b --mime-encoding "$subeditrcfullpath")
		if [[ $encodingrc == "utf-16"* ]] || [[ $encodingrc == *"ascii"* ]]; then
			:
		elif [[ -x /usr/bin/uchardet ]]; then
			cd "$(dirname "$subeditrcfullpath")"
			encodingrc=$(uchardet "$(basename "$subeditrcfullpath")" | tr -d '\r')
			cd - &> /dev/null
		fi

		# Read subeditrc to an array
		old_IFS=$IFS		# save the field separator
		IFS=$'\n'			# new field separator, the end of line
		subeditrcarray=()
		if ! [[ -x /usr/bin/uchardet ]]; then
			# Create subeditrcarray and a copy
			for line in "$(grep -a -v "^#\|^$" "$subeditrcfullpath")"; do
				subeditrcarray+=($line)
				subeditrcarraycopy+=($line)
			done

			# Re-create subeditrcarray if the encodings aren't the same
			if [[ ${encodingrc^^} != "UTF-8" ]]; then
				subeditrcarray=()
				for ((i=0; i<=${#subeditrcarraycopy[@]}-1; i++)); do
					iconvresult=""
					iconvresult=$(iconv -f $encodingrc -t utf-8 -c <<< ${subeditrcarraycopy[$i]})
					if (( ${#iconvresult} >= 2 )); then
						subeditrcarray+=($iconvresult)
					fi
				done
			fi
		else
			for line in "$(grep -a -v "^#\|^$" "$subeditrcfullpath" | iconv -f $encodingrc -t utf-8 -c)"; do
				subeditrcarray+=($line)
			done
		fi

		IFS=$old_IFS		# restore default field separator
	fi


	if [[ $subtitleis == "srt" ]]; then
		# Replace multiple whitespaces with one,
		# remove spaces between tags and text,
		# clean beginning and trailing spaces,
		# replace two single quotes with a double quote,
		# replace multiple quotes with one,
		# replace two single less-than/greater-that signs with double angle quotation mark,
		# remove spaces between double quotes and text (not in the middle of the sentence),
		# replace … with ...,
		# replace english characters with same-looking greek characters when necessary (x2),
		# remove spaces before punctuation marks (only for latin/greek text, when appropriate),
		# insert spaces after punctuation marks (only for latin/greek text, when appropriate),
		# remove unneded periods,
		# fix missing '[',
		# capitalize the first letter after '.', '!' and '?',
		# capitalize the first letter, if it's greek, after ';',
		# replace 2 or more ',' with '...',
		# replace 2 or more '.' with '...',
		# replace ',...' and '...,' with '...',
		# replace various marks that are often used by ocr instead of greek tonos with single quote,
		# replace single quote + greek capital vowel with the same accented capital vowel,
		# replace double quotes with double angle quotation marks if the quoted text is greek,
		# replace '?' with the greek question mark ';', if it proceeds a greek letter
		# NOTE: Needs the system locale to be utf-8
		# If the file is not utf-8 then sed won't work OK so we convert to utf-8 first
		tempvar="$(cat "$inputfilename" | iconv -f $encoding -t utf-8 | sed -b -e s"/[[:blank:]]\{1,\}/ /g"\
		-e s"/\(<i>\|<b>\|<u>\|<s>\|<font[^>]*>\) / \1/g"\
		-e s"/\(<i>\|<b>\|<u>\|<s>\|<font[^>]*>\) / \1/g"\
		-e s"/\(<i>\|<b>\|<u>\|<s>\|<font[^>]*>\) / \1/g"\
		-e s"/\(<i>\|<b>\|<u>\|<s>\|<font[^>]*>\) / \1/g"\
		-e s"/\(<i>\|<b>\|<u>\|<s>\|<font[^>]*>\) / \1/g"\
		-e s"/\(<i>\|<b>\|<u>\|<s>\|<font[^>]*>\) / \1/g"\
		-e s"/ \(<\/i>\|<\/b>\|<\/u>\|<\/s>\|<\/font>\)/\1 /g"\
		-e s"/ \(<\/i>\|<\/b>\|<\/u>\|<\/s>\|<\/font>\)/\1 /g"\
		-e s"/ \(<\/i>\|<\/b>\|<\/u>\|<\/s>\|<\/font>\)/\1 /g"\
		-e s"/ \(<\/i>\|<\/b>\|<\/u>\|<\/s>\|<\/font>\)/\1 /g"\
		-e s"/ \(<\/i>\|<\/b>\|<\/u>\|<\/s>\|<\/font>\)/\1 /g"\
		-e s"/ \(<\/i>\|<\/b>\|<\/u>\|<\/s>\|<\/font>\)/\1 /g"\
		-e s"/()\|\[\]\|{}//g"\
		-e s"/ \{1,\}/ /g"\
		-e s"/^[ ]//g"\
		-e s"/[ ]\($cr\)$/\1/g"\
		-e s"/[ʼ’΄\`ˋ´ˊˈ`´′]/'/g"\
		-e s"/''/\"/g"\
		-e s"/\"\{2,\}/\"/g"\
		-e s"/<</«/g"\
		-e s"/>>/»/g"\
		-e s"/«\{2,\}/«/g"\
		-e s"/»\{2,\}/»/g"\
		-e s"/«»//g"\
		-e s"/  / /g"\
		-e s"/…/.../g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)A/\1Α/g"\
		-e s"/A\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)B/\1Β/g"\
		-e s"/B\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Β\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)E/\1Ε/g"\
		-e s"/E\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ε\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Z/\1Ζ/g"\
		-e s"/Z\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ζ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)H/\1Η/g"\
		-e s"/H\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)I/\1Ι/g"\
		-e s"/I\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)K/\1Κ/g"\
		-e s"/K\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)M/\1Μ/g"\
		-e s"/M\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Μ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)N/\1Ν/g"\
		-e s"/N\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)O/\1Ο/g"\
		-e s"/O\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)P/\1Ρ/g"\
		-e s"/P\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)T/\1Τ/g"\
		-e s"/T\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Τ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Y/\1Υ/g"\
		-e s"/Y\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)X/\1Χ/g"\
		-e s"/X\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)a/\1α/g"\
		-e s"/a\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)n/\1η/g"\
		-e s"/n\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)h/\1η/g"\
		-e s"/h\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)i/\1ι/g"\
		-e s"/i\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)k/\1κ/g"\
		-e s"/k\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)o/\1ο/g"\
		-e s"/o\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)v/\1ν/g"\
		-e s"/v\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)p/\1ρ/g"\
		-e s"/p\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)u/\1υ/g"\
		-e s"/u\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)x/\1χ/g"\
		-e s"/x\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)s/\1ς/g"\
		-e s"/s\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ς\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)H\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4Η\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)H\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Η\4 \7/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)H\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4Ο\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)O\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Ο\4 \7/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)n\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4η\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)n\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1η\4 \7/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)o\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4ο\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)o\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1ο\4 \7/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)A/\1Α/g"\
		-e s"/A\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)B/\1Β/g"\
		-e s"/B\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Β\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)E/\1Ε/g"\
		-e s"/E\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ε\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Z/\1Ζ/g"\
		-e s"/Z\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ζ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)H/\1Η/g"\
		-e s"/H\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)I/\1Ι/g"\
		-e s"/I\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)K/\1Κ/g"\
		-e s"/K\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)M/\1Μ/g"\
		-e s"/M\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Μ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)N/\1Ν/g"\
		-e s"/N\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)O/\1Ο/g"\
		-e s"/O\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)P/\1Ρ/g"\
		-e s"/P\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)T/\1Τ/g"\
		-e s"/T\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Τ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Y/\1Υ/g"\
		-e s"/Y\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)X/\1Χ/g"\
		-e s"/X\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)a/\1α/g"\
		-e s"/a\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)n/\1η/g"\
		-e s"/n\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)h/\1η/g"\
		-e s"/h\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)i/\1ι/g"\
		-e s"/i\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)k/\1κ/g"\
		-e s"/k\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)o/\1ο/g"\
		-e s"/o\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)v/\1ν/g"\
		-e s"/v\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)p/\1ρ/g"\
		-e s"/p\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)u/\1υ/g"\
		-e s"/u\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)x/\1χ/g"\
		-e s"/x\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)s/\1ς/g"\
		-e s"/s\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ς\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)H\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4Η\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)H\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Η\4 \7/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)H\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4Ο\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)O\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Ο\4 \7/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)n\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4η\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)n\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1η\4 \7/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)o\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4ο\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)o\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1ο\4 \7/g"\
		-e s"/^\([.,:;\!¡·?¿_|@°%‰\\-]\{0,\}\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@°%‰\\-]\{0,\}\)\([\"]\)\(\(<[^>]*>\)\{0,\}\) /\1\3\4/g"\
		-e s"/[«]\(\(<[^>]*>\)\{0,\}\) /«\1/g"\
		-e s"/ \([.,:;\!¡·?¿_|@&°%‰\\-]\{0,\}\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\-]\{0,\}\)\([\"]\)\([.,:;\!¡·?¿_|@&°%‰\\-]\{0,\}\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\-]\{0,\}\)\($cr\)$/\1\3\4\6/g"\
		-e s"/ \([.,:;\!¡·?¿_|@°%‰\\-]\{0,\}\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@°%‰\\-]\{0,\}\)[»]/\1»/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ][,:;\!¡·?¿]\{1,\}\)\.\([^.]\)/\1\2/g"\
		-e s"/^\(\(<[^>]*>\)\{0,\}\)[({]\{0,1\}\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ.,:;\!¡·?¿[:blank:]]\{1,\}\]\)/\1[\3/g"\
		-e s"/^\([-]\{0,\}\(<[^>]*>\)\{0,\}[-]\{0,\}\)\( \?\(\. \?\)\{2,\}\+\.\?\)\(\(<[^>]*>\)\{0,\}\)/\1...\5/g"\
		-e s"/\(\(<[^>]*>\)\{0,\}\)\( \?\(\. \?\)\{2,\}\+\.\?\)\(\(<[^>]*>\)\{0,\}\)\($cr\)$/\1...\5\7/g"\
		-e s"/ \.\./  ../g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[,:;\!¡·?¿|@\\})]\)/\1\3/g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}]\)/\1/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}\.\(<[^>]*>\)\{0,\}\)\($cr\)$/\1\3\6/g"\
		-e s"/\([0-9]\) \([°%‰]\)/\1\2/g"\
		-e s"/°\([%‰]\)/\1/g"\
		-e s"/°\/\([oο]\)/%/g"\
		-e s"/°\/\([oο][oο]\)/‰/g"\
		-e s"/\([).,:;\!¡·?¿_@\\]\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[,:;\!¡·?¿@\\]\)/\1\3/g"\
		-e s"/\([).,:;\!¡·?¿_@\\]\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[,:;\!¡·?¿@\\]\)/\1\3/g"\
		-e s"/\([,:;\!¡·?¿_@\\]\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.]\{1,\}\(<[^>]*>\)\{0,\}[ ,:;\!¡·?¿_|@\\{}]\{0,\}\(<[^>]*>\)\{0,\}[0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1\3/g"\
		-e s"/  / /g"\
		-e s"/^\(\(<[^>]*>\)\{0,\}[-]\{1,\}\)\(\(<[^>]*>\)\{0,\}\)/\1 \3/g"\
		-e s"/\([:]\(<[^>]*>\)\{0,\}\)\([A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1 \3/g"\
		-e s"/\([;\!¡·?¿°%‰»\\)}]\(<[^>]*>\)\{0,\}\)\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1 \3/g"\
		-e s"/\(]\(<[^>]*>\)\{0,\}\)\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1 \3/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}\)\([({«\[]\)/\1 \3/g"\
		-e s"/\([({\[]\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1\3/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}\) \(<[^>]*>\)\{0,\}\.\(\(<[^>]*>\)\{0,\}[ ,:;\!¡·?¿_|@\\{}]\{0,\}\)\(\(<[^>]*>\)\{0,\}[0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1\3.\4 \6/g"\
		-e s"/\.\. /..  /g"\
		-e s"/\([^.]\.['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\( ['\"«»]\{0,\}\(<[^>]*>\)\{0,\}\-\)\{0,1\} ['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\U\6\E/g"\
		-e s"/\([^.]\.['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\(\(<[^>]*>\)\{0,\}\-\)['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\U\6\E/g"\
		-e s"/\(\!\|\?\)\(['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\( ['\"«»]\{0,\}\(<[^>]*>\)\{0,\}\-\)\{0,1\} ['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\2\6\U\8\E/g"\
		-e s"/\(;['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\( ['\"«»]\{0,\}\(<[^>]*>\)\{0,\}\-\)\{0,1\} \)\(['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\([α-ωά-ώΐΰ]\)/\1\5\U\7\E/g"\
		-e s"/  / /g"\
		-e s"/^\(['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\- ['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\U\4\E/g"\
		-e s"/,\{2,\}/.../g"\
		-e s"/\.\{2,\}/.../g"\
		-e s"/,\.\.\.\|\.\.\.,/.../g"\
		-e s"/'Ι'/Ϊ/g"\
		-e s"/'Υ'/Ϋ/g"\
		-e s"/'Α/Ά/g"\
		-e s"/'Ε/Έ/g"\
		-e s"/'Η/Ή/g"\
		-e s"/'Ι/Ί/g"\
		-e s"/'Ο/Ό/g"\
		-e s"/'Υ/Ύ/g"\
		-e s"/'Ω/Ώ/g"\
		-e s"/^\([(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\)\"\([(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}[0-9]\{0,\}[ ]\{0,1\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1«\3/g"\
		-e s"/ \([(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\)\"\([(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}[0-9]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1«\3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ ]\{0,1\}[).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\)\"\([).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}$cr\{0,1\}\)$/\1»\3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\)\"\([).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\) /\1»\3 /g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ 0-9).,:;\!¡·?¿_|@&°%‰*\\+-»]\{0,\}\(<[^>]*>\)\{0,\}[ 0-9).,:;\!¡·?¿_|@&°%‰*\\+-»]\{0,\}\)?/\1;/g")"

		# read_srt needs the new encoding
		encoding_old=$encoding
		encoding="utf-8"

		# Read text file to arraysrt
		printf "%s\n" "$tempvar" > "$inputfilename"
		read_srt "$inputfilename"

		encoding=$encoding_old

		# We do not need this anymore
		unset tempvar

		IFS=$'\n'			# new field separator, the end of line

		# Remove subtitles with zero duration
		temp1arraysrt=()
		for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}
		nextline=${arraysrt[((i+1))]}
			if [[ $line =~ $regexinteger ]] && [[ $nextline =~ $regextime ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				h2="${BASH_REMATCH[5]}"
				m2="${BASH_REMATCH[6]}"
				s2="${BASH_REMATCH[7]}"
				f2="${BASH_REMATCH[8]}"

				# Check if time is invalid
				if (( 10#$m1 >= 60 )) || (( 10#$s1 >= 60 )) || (( 10#$m2 >= 60 )) || (( 10#$s2 >= 60 )); then
					echo "Warning: Invalid time found: $line"
				fi

				if [[ $h1$m1$s1$f1 == $h2$m2$s2$f2 ]]; then
					foundzeroduration="True"
				else
					unset foundzeroduration
				fi
			fi

			if ! [[ $foundzeroduration ]]; then
				temp1arraysrt+=(${arraysrt[$i]})
			fi
		done

		# Remove subtitles that contain the key words in subeditrcarray
		if (( ${#subeditrcarray[@]} >= 1 )); then
			buffer=()
			temp2arraysrt=()

			# This was put inside a function because it needs to run twice
			keywordcleaning ()
			{
				if [[ $buffer ]] && ! [[ ${buffer[-1]} =~ $regextime ]]; then
					for ((j=-2; j>=-${#buffer[@]}; j--)); do
						if [[ ${buffer[$j]} =~ $regextime ]]; then
							break
						fi

						tempbuffer=${buffer[$j]}

						for ((k=0; k<=${#subeditrcarray[@]}-1; k++)); do
							temptrash="${subeditrcarray[$k]}"
							if [[ "${tempbuffer,,}" == *"${temptrash,,}"* ]]; then
								trashfound="True"
								break
							fi
						done
					done
					if ! [[ $trashfound ]]; then
						temp2arraysrt+=("${buffer[@]}")
					fi
				fi
			}

			for ((i=0; i<=${#temp1arraysrt[@]}; i++)); do
				if [[ ${temp1arraysrt[$i]} =~ $regexinteger ]] && [[ ${temp1arraysrt[((i+1))]} =~ $regextime ]]; then
					keywordcleaning
					unset trashfound
					buffer=()
				fi
				buffer+=(${temp1arraysrt[$i]})
			done

			# Everything inside previous for-loop must run one last time for the last subtitle
			keywordcleaning


			# Create temp1arraysrt from temp2arraysrt so that we can continue with the same array
			temp1arraysrt=()
			temp1arraysrt+=("${temp2arraysrt[@]}")
			unset temp2arraysrt
		fi

		# Re-create the subtitle array with new counter
		subcounter=0
		for ((i=0; i<=${#temp1arraysrt[@]}; i++)); do
			line=${temp1arraysrt[$i]}
			if [[ $line =~ $regexinteger ]] && [[ ${temp1arraysrt[((i+1))]} =~ $regextime ]]; then
				((subcounter++))
				temp1arraysrt[$i]="$subcounter$cr"
			fi
		done

		# Remove an empty line at the end
		if [[ ${temp1arraysrt[-1]} =~ $regexemptyline ]]; then
			unset temp1arraysrt[-1]
		fi


		IFS=$'\r'

		# Make the first letter uppercase if previous line ends with . ! ? ;
		# Make the first letter of the first subtitle uppercase
		# Split dialogs in one line
		temparray=()
		temparray+=( $(printf "%s" "${temp1arraysrt[@]}" | sed -e s"/\([^.]\.['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}$cr['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\3\U\5\E/g"\
		-e s"/\([\!?]['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}$cr['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\3\U\5\E/g"\
		-e s"/\(;['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}$cr['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\([α-ωά-ώΐΰ]\)/\1\3\U\5\E/g"\
		-e s"/\([^.]\.['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}$cr$cr[0-9]\{1,\}$cr[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$cr['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\3\U\5\E/g"\
		-e s"/\([\!?]['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}$cr$cr[0-9]\{1,\}$cr[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$cr['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\3\U\5\E/g"\
		-e s"/\(\;['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}$cr$cr[0-9]\{1,\}$cr[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$cr['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\([α-ωά-ώΐΰ]\)/\1\3\U\5\E/g"\
		-e s"/\(^1$cr[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$cr['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\2\U\4\E/g"\
		-e s"/\(- [^.]*[.]\) \(- \)/\1$cr\2/g"\
		-e s"/\(- [^.]*[.]\) \(- \)/\1$cr\2/g"\
		-e s"/\(- [^\!]*[\!]\) \(- \)/\1$cr\2/g"\
		-e s"/\(- [^\!]*[\!]\) \(- \)/\1$cr\2/g"\
		-e s"/\(- [^?]*[?]\) \(- \)/\1$cr\2/g"\
		-e s"/\(- [^?]*[?]\) \(- \)/\1$cr\2/g"\
		-e s"/\(- [^;]*[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ 0-9]*[;]\) \(- \)/\1$cr\2/g"\
		-e s"/\(- [^;]*[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ 0-9]*[;]\) \(- \)/\1$cr\2/g") )

		IFS=$old_IFS		# restore default field separator

		printf "%s\r\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
	elif [[ $subtitleis == "sub" ]]; then
		# Replace multiple whitespaces with one,
		# remove spaces between tags and text,
		# clean beginning and trailing spaces,
		# replace two single quotes with a double quote,
		# replace multiple quotes with one,
		# replace two single less-than/greater-that signs with double angle quotation mark,
		# remove spaces between double quotes and text (not in the middle of the sentence),
		# replace … with ...,
		# replace english characters with same-looking greek characters when necessary (x2),
		# remove spaces before punctuation marks (only for latin/greek text, when appropriate),
		# insert spaces after punctuation marks (only for latin/greek text, when appropriate),
		# remove unneded periods,
		# fix missing '[',
		# capitalize the first letter after '.', '!' and '?',
		# capitalize the first letter, if it's greek, after ';',
		# replace 2 or more ',' with '...',
		# replace 2 or more '.' with '...',
		# replace ',...' and '...,' with '...',
		# replace various marks that are often used by ocr instead of greek tonos with single quote,
		# replace single quote + greek capital vowel with the same accented capital vowel,
		# replace double quotes with double angle quotation marks if the quoted text is greek,
		# replace '?' with the greek question mark ';', if it proceeds a greek letter
		# NOTE: Needs the system locale to be utf-8
		# If the file is not utf-8 then sed won't work OK so we convert to utf-8 first
		tempvar="$(cat "$inputfilename" | iconv -f $encoding -t utf-8 | sed -b -e s"/[[:blank:]]\{1,\}/ /g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/()\|\[\]\|{}//g"\
		-e s"/ \{1,\}/ /g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\) \{0,1\}\(\({[cCsSfFPyY]:[^}]*}\)*\) \{0,1\}/\1\2/g"\
		-e s"/ |/|/g"\
		-e s"/| \{0,1\}\(\({[cCsSfFPyY]:[^}]*}\)*\) \{0,1\}/|\1/g"\
		-e s"/[ ]\($cr\)$/\1/g"\
		-e s"/[ʼ’΄\`ˋ´ˊˈ`´′]/'/g"\
		-e s"/''/\"/g"\
		-e s"/\"\{2,\}/\"/g"\
		-e s"/<</«/g"\
		-e s"/>>/»/g"\
		-e s"/«\{2,\}/«/g"\
		-e s"/»\{2,\}/»/g"\
		-e s"/«»//g"\
		-e s"/  / /g"\
		-e s"/…/.../g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)A/\1Α/g"\
		-e s"/A\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)B/\1Β/g"\
		-e s"/B\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Β\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)E/\1Ε/g"\
		-e s"/E\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ε\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Z/\1Ζ/g"\
		-e s"/Z\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ζ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)H/\1Η/g"\
		-e s"/H\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)I/\1Ι/g"\
		-e s"/I\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)K/\1Κ/g"\
		-e s"/K\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)M/\1Μ/g"\
		-e s"/M\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Μ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)N/\1Ν/g"\
		-e s"/N\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)O/\1Ο/g"\
		-e s"/O\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)P/\1Ρ/g"\
		-e s"/P\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)T/\1Τ/g"\
		-e s"/T\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Τ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Y/\1Υ/g"\
		-e s"/Y\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)X/\1Χ/g"\
		-e s"/X\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)a/\1α/g"\
		-e s"/a\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)n/\1η/g"\
		-e s"/n\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)h/\1η/g"\
		-e s"/h\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)i/\1ι/g"\
		-e s"/i\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)k/\1κ/g"\
		-e s"/k\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)o/\1ο/g"\
		-e s"/o\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)v/\1ν/g"\
		-e s"/v\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)p/\1ρ/g"\
		-e s"/p\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)u/\1υ/g"\
		-e s"/u\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)x/\1χ/g"\
		-e s"/x\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)s/\1ς/g"\
		-e s"/s\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ς\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)H\([.,]\{0,\}\) /\1 \2Η\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)H\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Η\2 \3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)H\([.,]\{0,\}\) /\1 \2Ο\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)O\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Ο\2 \3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)n\([.,]\{0,\}\) /\1 \2η\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)n\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1η\2 \3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)o\([.,]\{0,\}\) /\1 \2ο\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)o\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1ο\2 \3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)A/\1Α/g"\
		-e s"/A\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)B/\1Β/g"\
		-e s"/B\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Β\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)E/\1Ε/g"\
		-e s"/E\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ε\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Z/\1Ζ/g"\
		-e s"/Z\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ζ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)H/\1Η/g"\
		-e s"/H\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)I/\1Ι/g"\
		-e s"/I\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)K/\1Κ/g"\
		-e s"/K\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)M/\1Μ/g"\
		-e s"/M\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Μ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)N/\1Ν/g"\
		-e s"/N\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)O/\1Ο/g"\
		-e s"/O\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)P/\1Ρ/g"\
		-e s"/P\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)T/\1Τ/g"\
		-e s"/T\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Τ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Y/\1Υ/g"\
		-e s"/Y\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)X/\1Χ/g"\
		-e s"/X\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)a/\1α/g"\
		-e s"/a\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)n/\1η/g"\
		-e s"/n\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)h/\1η/g"\
		-e s"/h\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)i/\1ι/g"\
		-e s"/i\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)k/\1κ/g"\
		-e s"/k\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)o/\1ο/g"\
		-e s"/o\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)v/\1ν/g"\
		-e s"/v\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)p/\1ρ/g"\
		-e s"/p\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)u/\1υ/g"\
		-e s"/u\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)x/\1χ/g"\
		-e s"/x\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)s/\1ς/g"\
		-e s"/s\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ς\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)H\([.,]\{0,\}\) /\1 \2Η\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)H\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Η\2 \3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)H\([.,]\{0,\}\) /\1 \2Ο\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)O\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Ο\2 \3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)n\([.,]\{0,\}\) /\1 \2η\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)n\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1η\2 \3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)o\([.,]\{0,\}\) /\1 \2ο\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)o\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1ο\2 \3/g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*[.,:;\!¡·?¿_@°%‰\\-]\{0,\}\)\([\"]\) /\1\3/g"\
		-e s"/\(|\({[cCsSfFPyY]:[^}]*}\)*[.,:;\!¡·?¿_@°%‰*\\+-]\{0,\}\)\([\"]\) /\1\3/g"\
		-e s"/[«] /«/g"\
		-e s"/ \([\"]\)\([.,:;\!¡·?¿_@&°%‰\\]\{0,\}\)\($cr\)$/\1\2\3/g"\
		-e s"/ \([\"]\)\([.,:;\!¡·?¿_@&°%‰\\]\{0,\}\)|/\1\2|/g"\
		-e s"/ [»]/»/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ][,:;\!¡·?¿]\{1,\}\)\.\([^.]\)/\1\2/g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*\)[({]\{0,1\}\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ.,:;\!¡·?¿[:blank:]]\{1,\}\]\)/\1[\3/g"\
		-e s"/\(|\({[cCsSfFPyY]:[^}]*}\)*\)[({]\{0,1\}\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ.,:;\!¡·?¿[:blank:]]\{1,\}\]\)/\1[\3/g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*[-]\{0,\}\)\( \?\(\. \?\)\{2,\}\+\.\?\)/\1.../g"\
		-e s"/\(|\({[cCsSfFPyY]:[^}]*}\)*[-]\{0,\}\)\( \?\(\. \?\)\{2,\}\+\.\?\)/\1.../g"\
		-e s"/\( \?\(\. \?\)\{2,\}\+\.\?\)|/...|/g"\
		-e s"/\( \?\(\. \?\)\{2,\}\+\.\?\)\($cr\)$/.../g"\
		-e s"/ \.\./  ../g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\) \([,:;\!¡·?¿@\\})]\)/\1\2/g"\
		-e s"/ ]/]/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\) \.\($cr\)$/\1.\2/g"\
		-e s"/\([0-9]\) \([°%‰]\)/\1\2/g"\
		-e s"/°\([%‰]\)/\1/g"\
		-e s"/°\/\([oο]\)/%/g"\
		-e s"/°\/\([oο][oο]\)/‰/g"\
		-e s"/\([).,:;\!¡·?¿_@\\]\) \([,:;\!¡·?¿@\\]\)/\1\2/g"\
		-e s"/\([).,:;\!¡·?¿_@\\]\) \([,:;\!¡·?¿@\\]\)/\1\2/g"\
		-e s"/\([,:;\!¡·?¿_@\\]\) \([.]\{1,\}[ ,:;\!¡·?¿_@\\]\{0,\}[0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1\2/g"\
		-e s"/  / /g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*\"\{0,1\}[-]\{1,\}\)/\1 /g"\
		-e s"/\(|\({[cCsSfFPyY]:[^}]*}\)*\"\{0,1\}[-]\{1,\}\)/\1 /g"\
		-e s"/\([;\!¡·?¿°%‰»)}\\]\)\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1 \2/g"\
		-e s"/\]\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/] \1/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)\([({«\[]\)/\1 \2/g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\) \{0,1\}\(\({[cCsSfFPyY]:[^}]*}\)*\) \{0,1\}/\1\2/g"\
		-e s"/| \{0,1\}\(\({[cCsSfFPyY]:[^}]*}\)*\) \{0,1\}/|\1/g"\
		-e s"/\([({\[]\) \([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1\2/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\) \.\([ ,:;\!¡·?¿_@\\]\{0,\}\)\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1.\2 \3/g"\
		-e s"/\.\. /..  /g"\
		-e s"/\([^.]\.['\"«»]\{0,\}\( ['\"«»]\{0,\}[-]\)\{0,1\} ['\"«»]\{0,\}\)\(.\)/\1\U\3\E/g"\
		-e s"/\([^.]\.['\"«»]\{0,\}\(['\"«»]\{0,\}[-]\)['\"«»]\{0,\}\)\(.\)/\1\U\3\E/g"\
		-e s"/\(\!\|\?\)\(['\"«»]\{0,\}\( ['\"«»]\{0,\}[-]\)\{0,1\} ['\"«»]\{0,\}\)\(.\)/\1\2\U\4\E/g"\
		-e s"/\(;['\"«»]\{0,\}\( ['\"«»]\{0,\}[-]\)\{0,1\} ['\"«»]\{0,\}\)\([α-ωά-ώΐΰ]\)/\1\U\3\E/g"\
		-e s"/  / /g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*\- \)\(.\)/\1\U\3\E/g"\
		-e s"/\(|\({[cCsSfFPyY]:[^}]*}\)*\- \)\(.\)/\1\U\3\E/g"\
		-e s"/,\{2,\}/.../g"\
		-e s"/\.\{2,\}/.../g"\
		-e s"/,\.\.\.\|\.\.\.,/.../g"\
		-e s"/'Ι'/Ϊ/g"\
		-e s"/'Υ'/Ϋ/g"\
		-e s"/'Α/Ά/g"\
		-e s"/'Ε/Έ/g"\
		-e s"/'Η/Ή/g"\
		-e s"/'Ι/Ί/g"\
		-e s"/'Ο/Ό/g"\
		-e s"/'Υ/Ύ/g"\
		-e s"/'Ω/Ώ/g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)\{0,\}[(.,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}\)\"\([(.,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}[0-9]\{0,\}[ ]\{0,1\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1«\3/g"\
		-e s"/\([ |]\({[cCsSfFPyY]:[^}]*}\)\{0,\}[(.,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}\)\"\([(.,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}[0-9]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1«\3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ ]\{0,1\}[).,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}\)\"\([).,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}$cr\{0,\}\)\{0,1\}$/\1»\2/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][).,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}\)\"\([).,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}[ |]\)/\1»\2/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ 0-9).,:;\!¡·?¿_|@&°%‰*\\+-»]\{0,\}\)?/\1;/g")"

		# read_sub needs the new encoding
		encoding_old=$encoding
		encoding="utf-8"

		# Read text file to arraysub
		printf "%s\n" "$tempvar" > "$inputfilename"
		read_sub "$inputfilename"

		encoding=$encoding_old

		# We do not need this anymore
		unset tempvar

		# Remove subtitles with zero duration
		temp1arraysub=()

		if [[ ${arraysub[0]} =~ $regexsub1 ]]; then
			temp1arraysub+=(${arraysub[0]})
		fi

		for ((i=0; i<=${#arraysub[@]}; i++)); do
			line=${arraysub[$i]}

			if [[ $line =~ $regexsub ]]; then
				framesstart="${BASH_REMATCH[1]}"
				framesend="${BASH_REMATCH[2]}"

				if ((framesstart != framesend)); then
					temp1arraysub+=("$line")
				fi
			fi
		done

		# Remove subtitles that contain the key words in subeditrcarray
		if (( ${#subeditrcarray[@]} >= 1 )); then
			temp2arraysub=()

			for ((i=0; i<=${#temp1arraysub[@]}-1; i++)); do
				unset trashfound
				line=${temp1arraysub[$i]}
				for ((k=0; k<=${#subeditrcarray[@]}-1; k++)); do
					temptrash="${subeditrcarray[$k]}"
					if [[ ${line,,} == *"${temptrash,,}"* ]]; then
						trashfound="True"
						break
					fi
				done
				if ! [[ $trashfound ]]; then
					temp2arraysub+=("$line")
				fi
			done

			# Create temp1arraysub from temp2arraysub so that we can continue with the same array
			temp1arraysub=()
			temp1arraysub+=("${temp2arraysub[@]}")
			unset temp2arraysub
		fi


		IFS=$'\r'

		# Make the first letter uppercase if previous line ends with . ! ? ;
		# Make the first letter of the first subtitle uppercase
		# Split dialogs in one line
		temparray=()
		temparray+=( $(printf "%s" "${temp1arraysub[@]}" | sed -e s"/\([^.]\.['\"«»]\{0,\}|\({[cCsSfFPyY]:[^}]*}\)*['\"«»]\{0,\}\)\(.\)/\1\U\3\E/g"\
		-e s"/\([\!?]['\"«»]\{0,\}|\({[cCsSfFPyY]:[^}]*}\)*['\"«»]\{0,\}\)\(.\)/\1\U\3\E/g"\
		-e s"/\(;['\"«»]\{0,\}|\({[cCsSfFPyY]:[^}]*}\)*['\"«»]\{0,\}\)\([α-ωά-ώΐΰ]\)/\1\U\3\E/g"\
		-e s"/\([^.]\.['\"«»]\{0,\}$cr{[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*['\"«»]\{0,\}\)\(.\)/\1\U\3\E/g"\
		-e s"/\([\!?]['\"«»]\{0,\}$cr{[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*['\"«»]\{0,\}\)\(.\)/\1\U\3\E/g"\
		-e s"/\(;['\"«»]\{0,\}$cr{[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*['\"«»]\{0,\}\)\([α-ωά-ώΐΰ]\)/\1\U\3\E/g"\
		-e s"/\(^\({1}{1}[0-9]\{1,\}\.\{0,1\}[0-9]\{0,\}$cr\)\{0,1\}{[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*['\"«»]\{0,\}\)\(.\)/\1\U\4\E/g"\
		-e s"/\(- [^.]*[.]\) \(- \)/\1|\2/g"\
		-e s"/\(- [^.]*[.]\) \(- \)/\1|\2/g"\
		-e s"/\(- [^\!]*[\!]\) \(- \)/\1|\2/g"\
		-e s"/\(- [^\!]*[\!]\) \(- \)/\1|\2/g"\
		-e s"/\(- [^?]*[?]\) \(- \)/\1|\2/g"\
		-e s"/\(- [^?]*[?]\) \(- \)/\1|\2/g"\
		-e s"/\(- [^;]*[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ 0-9]*[;]\) \(- \)/\1|\2/g"\
		-e s"/\(- [^;]*[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ 0-9]*[;]\) \(- \)/\1|\2/g") )

		printf "%s\r\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
	fi
}


delete_HI ()
{
	# Get the symbols that enclose the text to be removed
	regexHIsymbols="^([(\[{?mM]+)$"

	if [[ $deletetextsforHI =~ $regexHIsymbols ]]; then
		HIsymbols="${BASH_REMATCH[1]}"
	else
		echo -e "Error: Syntax must be like '([{?mM'. The single quotes are necessary.\nThe ([{? characters are the symbols that the text for the hearing impaired is enclosed by.\n'm' and 'M' are for music symbols. With 'm' only the music symbols are deleted.\nWith 'M' the text that is enclosed by the music symbols is deleted too.\nUse only the symbol(s) that are needed for each subtitle file."
		exit 1
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the srt or sub is OK
	check_srt_and_sub "$inputfilename" "Deleting text for hearing impaired for \"$inputfilename\""

	# Exit this function if the return code of check_srt_and_sub is not 0
	if (($? != 0)); then
		return 1
	fi


	IFS=$'\n'			# new field separator, the end of line

	if [[ $subtitleis == "srt" ]]; then
		# Read text file to arraysrt
		arraysrt=()
		for line in $(iconv -f $encoding -t utf-8 "$inputfilename" 2> /dev/null); do
			arraysrt+=($line)
		done

		# Delete the text that is enclosed by the defined symbols
		tempvar=$(printf "%s\n" "${arraysrt[@]}")

		if [[ $HIsymbols == *"("* ]]; then
			tempvar=$(echo "$tempvar" |
			sed -e '/^[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}([^)]*)[[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}\($cr\)\{0,1\}$/d'\
			-e s'/[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}([^)]*)[[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}/ /'g\
			-e s'/^[ ]\|[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"["* ]]; then
			tempvar=$(echo "$tempvar" |
			sed -e '/^[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}\[[^]]*\][[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}\($cr\)\{0,1\}$/d'\
			-e s'/[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}\[[^]]*\][[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}/ /'g\
			-e s'/^[ ]\|[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"{"* ]]; then
			tempvar=$(echo "$tempvar" |
			sed -e '/^[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}{[^}]*}[[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}\($cr\)\{0,1\}$/d'\
			-e s'/[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}{[^}]*}[[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}/ /'g\
			-e s'/^[ ]\|[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"?"* ]]; then
			tempvar=$(echo "$tempvar" |
			sed -e '/^[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}?[^?]*?[[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}\($cr\)\{0,1\}$/d'\
			-e s'/[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}?[^?]*?[[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}/ /'g\
			-e s'/^[ ]\|[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"M"* ]]; then
			tempvar=$(echo "$tempvar" |
			sed -e '/^[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}[¶♪♫][^¶♪♫]*[¶♪♫][[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}\($cr\)\{0,1\}$/d'\
			-e s'/[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}[¶♪♫][^¶♪♫]*[¶♪♫][[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}/ /'g\
			-e '/^[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}[#][^#]*[#][[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}\($cr\)\{0,1\}$/d'\
			-e s'/[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}[#][^#]*[#][[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}/ /'g\
			-e s'/^[ ]\|[ ]\($cr\)\{0,1\}$//g')
		fi

		# Delete the music symbols
		if [[ $HIsymbols == *"m"* ]]; then
			tempvar=$(echo "$tempvar" | sed -e s'/[[:blank:]]\{0,\}[¶♪♫][[:blank:]]\{0,\}/ /'g\
			-e s'/^[ ]\|[ ]\($cr\)\{0,1\}$//g')
		fi

		# Export what we have so far to inputfilename
		printf "%s\n" "$tempvar" > "$inputfilename"

		unset tempvar

		# We must unset this so that read_srt fixes the line endings
		unset subtitleis

		# read_srt removes any empty subtitles
		read_srt "$inputfilename"

		# We must set this again, or the basic_clean_up will run after this
		subtitleis="srt"

		# Export to inputfilename
		printf "%s\n" "${arraysrt[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
	elif [[ $subtitleis == "sub" ]]; then
		# Read text file to arraysub
		arraysub=()
		for line in $(iconv -f $encoding -t utf-8 "$inputfilename" 2> /dev/null); do
			arraysub+=($line)
		done

		# Delete the text that is enclosed by the defined symbols
		tempvar=$(printf "%s\n" "${arraysub[@]}")

		if [[ $HIsymbols == *"("* ]]; then
			tempvar=$(echo "$tempvar" | sed -e s'/[[:blank:]]\{0,\}([^)]*)[[:blank:]]\{0,\}/ /'g\
			-e s'/\({[0-9]\+}{[0-9]\+}\)\({[cCsSfFPyY]:[^}]*}\)* \(.*\)/\1\2\3/g'\
			-e s'/[ ]\{0,1\}[|][ ]\{0,1\}/|/g'\
			-e s'/[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"["* ]]; then
			tempvar=$(echo "$tempvar" | sed -e s'/[[:blank:]]\{0,\}\[[^]]*\][[:blank:]]\{0,\}/ /'g\
			-e s'/\({[0-9]\+}{[0-9]\+}\)\({[cCsSfFPyY]:[^}]*}\)* \(.*\)/\1\2\3/g'\
			-e s'/[ ]\{0,1\}[|][ ]\{0,1\}/|/g'\
			-e s'/[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"{"* ]]; then
			tempvar=$(echo "$tempvar" | sed -e s'/^{\([0-9]\+\)}{\([0-9]\+\)}/*(*\1*)**(*\2*)*/'g\
			-e s'/{\([cCsSfFPyY]:[^}]*\)}/*(*\1*)*/'g\
			-e s'/[[:blank:]]\{0,\}{[^}]*}[[:blank:]]\{0,\}/ /'g\
			-e s'/^\*(\*\([0-9]\+\)\*)\*\*(\*\([0-9]\+\)\*)\*/{\1}{\2}/'g\
			-e s'/\*(\*\([cCsSfFPyY]:[^*]*\)\*)\*/{\1}/'g\
			-e s'/\({[0-9]\+}{[0-9]\+}\)\({[cCsSfFPyY]:[^}]*}\)* \(.*\)/\1\2\3/g'\
			-e s'/[ ]\{0,1\}[|][ ]\{0,1\}/|/g'\
			-e s'/[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"?"* ]]; then
			tempvar=$(echo "$tempvar" | sed -e s'/[[:blank:]]\{0,\}?[^?]*?[[:blank:]]\{0,\}/ /'g\
			-e s'/\({[0-9]\+}{[0-9]\+}\)\({[cCsSfFPyY]:[^}]*}\)* \(.*\)/\1\2\3/g'\
			-e s'/[ ]\{0,1\}[|][ ]\{0,1\}/|/g'\
			-e s'/[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"M"* ]]; then
			tempvar=$(echo "$tempvar" | sed -e s'/[[:blank:]]\{0,\}[¶♪♫][^¶♪♫]*[¶♪♫][[:blank:]]\{0,\}/ /'g\
			-e s'/[[:blank:]]\{0,\}[#][^#]*[#][[:blank:]]\{0,\}/ /'g\
			-e s'/\({[0-9]\+}{[0-9]\+}\)\({[cCsSfFPyY]:[^}]*}\)* \(.*\)/\1\2\3/g'\
			-e s'/[ ]\{0,1\}[|][ ]\{0,1\}/|/g'\
			-e s'/[ ]\($cr\)\{0,1\}$//g')
		fi

		# Delete the music symbols
		if [[ $HIsymbols == *"m"* ]]; then
			tempvar=$(echo "$tempvar" | sed -e s'/[[:blank:]]\{0,\}[¶♪♫][[:blank:]]\{0,\}/ /'g\
			-e s'/\({[0-9]\+}{[0-9]\+}\)\({[cCsSfFPyY]:[^}]*}\)* \(.*\)/\1\2\3/g'\
			-e s'/[ ]\{0,1\}[|][ ]\{0,1\}/|/g'\
			-e s'/[ ]\($cr\)\{0,1\}$//g')
		fi

		# Export what we have so far to inputfilename
		printf "%s\n" "$tempvar" | iconv -f utf-8 -t $encoding > "$inputfilename"

		unset tempvar

		# We must unset this so that read_sub fixes the line endings
		unset subtitleis

		# read_sub removes any empty subtitles
		read_sub "$inputfilename"

		# We must set this again, or the basic_clean_up will run after this
		subtitleis="sub"

		# Export to inputfilename
		printf "%s\n" "${arraysub[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
	fi

	IFS=$old_IFS		# restore default field separator
}


# Check for incompatible parameters
if [[ $inputfilename ]] && [[ $inputdirectory ]]; then
	echo "Error: The parameters -i (Input file) and -d (Input directory) cannot be used together."; exit 1
fi

if [[ $inputfilename ]] && [[ $synchronizedirectory ]]; then
	echo "Error: The parameters -i (Input file) and -D (Synchronize with directory.) cannot be used together."
	echo "Instead of \"Synchronize with directory\" you can use \"Synchronize with file\" (-y parameter)."; exit 1
fi


# Input file with wildcard support
master_function ()
{
	if [[ $shifttime ]]; then
		shift_time; (($? != 0)) && return 1
	fi

	if [[ $pal2ntsc ]] || [[ $ntsc2pal ]]; then
		change_fps; (($? != 0)) && return 1
	fi

	if [[ $adjustfirst ]]; then
		adjust_time; (($? != 0)) && return 1
	fi

	if [[ $adjustonlyfirst ]] || [[ $adjustonlylast ]]; then
		adjust_time_v2; (($? != 0)) && return 1
	fi

	if [[ $synchronizefile ]]; then
		synchronize_with_file; (($? != 0)) && return 1
	fi

	if [[ $findci ]] || [[ $findcs ]]; then
		find_text; (($? != 0)) && return 1
	fi

	if [[ $replace1 ]] || [[ $replace3 ]]; then
		replace_text; (($? != 0)) && return 1
	fi

	if [[ $sub2srt ]]; then
		sub2_srt; (($? != 0)) && return 1
	elif [[ $srt2sub ]]; then
		srt2_sub; (($? != 0)) && return 1
	fi

	if [[ $joinsrt ]]; then
		join_srt; (($? != 0)) && return 1
	fi

	if [[ $splitsrt ]]; then
		split_srt; (($? != 0)) && return 1
	fi

	if [[ $cleantrash ]]; then
		clean_trash; (($? != 0)) && return 1
	fi

	if [[ $deletetextsforHI ]]; then
		delete_HI; (($? != 0)) && return 1
	fi

	if ! [[ $srtok ]] && ! [[ $subok ]] && ! [[ $subtitleis ]]; then
		basic_clean_up; (($? != 0)) && return 1
	fi
}

if [[ $inputfilename ]]; then
	# Set globbing to case insensitive
	shopt -s nocaseglob

	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	# Capture the output of ls to an array
	filesarray=( $(ls $inputfilename -p -d 2> /dev/null | grep -v /) )

	IFS=$old_IFS		# restore default field separator

	# Restore globbing to case sensitive
	shopt -u nocaseglob

	if ((${#filesarray[@]} == 0)); then
		echo "Error: No file found."; exit 1
	elif ((${#filesarray[@]} == 1)); then
		master_function

		# Exit if the return code of anything in the master_function is not 0
		if (($? != 0)); then
			exit 1
		else
			exit 0
		fi
	else
		numberofsrt=$(printf "%s\n" "${filesarray[@]}" | grep -i "\.srt$" -c)
		numberofsub=$(printf "%s\n" "${filesarray[@]}" | grep -i "\.sub$" -c)
		echo "$numberofsrt .srt & $numberofsub .sub file(s) found"
		((numberofother = ${#filesarray[@]} - $numberofsrt - $numberofsub))
		if ((numberofother > 0)); then
			echo "$numberofother other file(s) were also found. These will be checked too and processed if they are subtitles."
		fi

		batchcounter=0
		numberofsubtitles=${#filesarray[@]}
		numberofsubtitleslength=${#numberofsubtitles}
		for inputfilename in "${filesarray[@]}"; do
			((batchcounter++))
			batchcounterlength=${#batchcounter}
			spaceslength=$((numberofsubtitleslength-batchcounterlength))
			case "$spaceslength" in
				0) precedingspaces="" ;;
				1) precedingspaces=" " ;;
				2) precedingspaces="  " ;;
				3) precedingspaces="   " ;;
				?) precedingspaces=$(eval printf "\ %.0s" {1..$spaceslength}) ;;
			esac
			printf "${bold}${green}[$precedingspaces$batchcounter/${#filesarray[@]}]${normal} "

			master_function
		done
		exit 0
	fi
fi


# Input directory with wildcard support
if [[ $inputdirectory ]]; then
	# Set globbing to case insensitive
	shopt -s nocaseglob

	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	# Check if directory/ies exist
	if ! [[ $(ls -p -d $inputdirectory 2> /dev/null | grep /) ]]; then
		echo "Error: No directory found."; exit 1
	fi

	# Capture the output of ls to an array
	if [[ $shifttime ]] || [[ $pal2ntsc ]] || [[ $ntsc2pal ]] || [[ $adjustfirst ]] || [[ $adjustonlyfirst ]] || [[ $adjustonlylast ]] || [[ $synchronizedirectory ]] || [[ $srt2sub ]] || [[ $splitsrt ]]; then
		if [[ $recurse ]]; then
			filesarray=( $(find $inputdirectory -type f -iname "*.srt" 2> /dev/null | sort) )
		else
			filesarray=( $(ls $inputdirectory/*.srt 2> /dev/null) )
		fi
		echo "${#filesarray[@]} srt file(s) found"
	elif [[ $sub2srt ]]; then
		if [[ $recurse ]]; then
			filesarray=( $(find $inputdirectory -type f -iname "*.sub" 2> /dev/null | sort) )
		else
			filesarray=( $(ls $inputdirectory/*.sub 2> /dev/null) )
		fi
		echo "${#filesarray[@]} sub file(s) found"
	elif [[ $synchronizefile ]] || [[ $joinsrt ]]; then
		echo "Error: Synchronize with file and Join srt cannot be used in batch mode."
		echo "Instead of Synchronize with file you can use Synchronize with directory (-D parameter)."; exit 1
	else
		if [[ $recurse ]]; then
			filesarray=( $(find $inputdirectory -type f -iname "*.srt" -o -iname "*.sub" 2> /dev/null | sort) )
		else
			filesarray=( $(ls $inputdirectory/*.srt $inputdirectory/*.sub 2> /dev/null) )
		fi
		echo "$(printf "%s\n" "${filesarray[@]}" | grep -i "\.srt$" -c) .srt & $(printf "%s\n" "${filesarray[@]}" | grep -i "\.sub$" -c) .sub file(s) found"
	fi

	IFS=$old_IFS		# restore default field separator

	# Restore globbing to case sensitive
	shopt -u nocaseglob

	batchcounter=0
	numberofsubtitles=${#filesarray[@]}
	numberofsubtitleslength=${#numberofsubtitles}
	for inputfilename in "${filesarray[@]}"; do
		((batchcounter++))
		batchcounterlength=${#batchcounter}
		spaceslength=$((numberofsubtitleslength-batchcounterlength))
		case "$spaceslength" in
			0) precedingspaces="" ;;
			1) precedingspaces=" " ;;
			2) precedingspaces="  " ;;
			3) precedingspaces="   " ;;
			?) precedingspaces=$(eval printf "\ %.0s" {1..$spaceslength}) ;;
		esac
		printf "${bold}${green}[$precedingspaces$batchcounter/${#filesarray[@]}]${normal} "

		if [[ $shifttime ]]; then
			shift_time
		fi

		if [[ $pal2ntsc ]] || [[ $ntsc2pal ]]; then
			change_fps
		fi

		if [[ $adjustfirst ]]; then
			adjust_time
		fi

		if [[ $adjustonlyfirst ]] || [[ $adjustonlylast ]]; then
			adjust_time_v2
		fi

		if [[ $synchronizedirectory ]]; then
			synchronize_with_file
		fi

		if [[ $findci ]] || [[ $findcs ]]; then
			find_text
		fi

		if [[ $replace1 ]] || [[ $replace3 ]]; then
			replace_text
		fi

		if [[ $sub2srt ]]; then
			sub2_srt
		elif [[ $srt2sub ]]; then
			srt2_sub
		fi

		if [[ $splitsrt ]]; then
			split_srt
		fi

		if [[ $cleantrash ]]; then
			clean_trash
		fi

		if [[ $deletetextsforHI ]]; then
			delete_HI
		fi

		if ! [[ $srtok ]] && ! [[ $subok ]] && ! [[ $subtitleis ]]; then
			basic_clean_up
		fi
	done
	exit 0
fi
