#!/usr/bin/bash


#	Copyright 2016-2017 George Savvidis, Odysseas Raftopoulos

#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 2 of the License, or
#	(at your option) any later version.

#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.

#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Define colors and bold letters
red=$(tput setaf 1)
green=$(tput setaf 2)
cyan=$(tput setaf 6)
bold=$(tput bold)
normal=$(tput sgr0)

# Check if dos2unix, unix2dos, iconv, file and uchardet programs exist.
if ! [[ -x "$(command -v dos2unix)" ]]; then
	echo "${red}Error: \"dos2unix\" is not installed. Exiting.${normal}"; exit 1
fi

if ! [[ -x "$(command -v unix2dos)" ]]; then
	echo "${red}Error: \"unix2dos\" is not installed. Exiting.${normal}"; exit 1
fi

if ! [[ -x "$(command -v iconv)" ]]; then
	echo "${red}Error: \"iconv\" is not installed. Exiting.${normal}"; exit 1
fi

if ! [[ -x "$(command -v file)" ]]; then
	echo "${red}Error: \"file\" is not installed. Exiting.${normal}"; exit 1
fi

if ! [[ -x "$(command -v uchardet)" ]]; then
	echo "${bold}${red}Warning: \"uchardet\" is not installed. Uchardet improves input file's encoding detection but is not mandatory for subedit to run.${normal}"
fi

# Define carriage return and new line
cr=$(echo -e "\r")
nl=$(echo -e "\n")

# Define regular expressions
regexinteger="^([0-9]+)$cr$"
regextime="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9]) --> ([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$cr$"
regexsub="^\{([0-9]+)\}\{([0-9]+)\}(.+)$cr$"
regexsub1="^\{[1]\}\{[1]\}(.+)$cr$"
regexemptyline="^($cr$nl|$nl|$cr)$"


# Help
get_help ()
{
case $((10#$(date +%S)%2)) in
	0) authors[0]="George Savvidis (stargr@gmail.com)"; authors[1]="Odysseas Raftopoulos" ;;
	1) authors[0]="Odysseas Raftopoulos"; authors[1]="George Savvidis (stargr@gmail.com)" ;;
esac

text1="
${cyan}NAME${normal}
  subedit


${cyan}DESCRIPTION${normal}
  Command line srt subtitle editor.

  The script generally works with srt (SubRip), but a few parameters work with sub (MicroDVD) subtitle files too.


${cyan}PARAMETERS${normal}
  ${bold}-i \"Input file\"${normal}
      Subtitle file to process.
      Accepts srt or sub files, depending on what other parameter is used.
      Supports wildcards and relative or absolute paths.
      Open a subtitle file with no other parameters to perform basic clean-up.
      Does not work with -D parameter (synchronize with directory) and -r parameter (recurse).

  ${bold}-d \"Input directory\"${normal}
      Directory containing subtitle files to process.
      Can contain srt, sub or both subtitle types.
      Supports wildcards and relative or absolute paths.
      Open a directory with no other parameters to perform basic clean-up to all contained subtitle files.
      Works with all parameters except with -y (synchronize with file) and -j (join two srt subtitles).
      Instead of Synchronize with file you can use Synchronize with directory (-D parameter).

  ${bold}-r [Switch]${normal}
      Recurse.
      Optional switch, to be used with -d.
      Searches recursively for subtitle files.

  ${bold}-b [Switch]${normal}
      Backup input file.
      Optional switch that can be used with any other parameter.
      Makes a copy of the input file in the same directory with the .bak suffix.
      If the backup already exists, it does nothing. If -b is not set and the backup file exists, it is removed.

  ${bold}-s (+/-/a/z)hh:mm:ss,fff${normal}
      Shift time.
      Plus sign (or no sign at all) adds time, where the minus sign subtracts time.
      \"a\" and \"z\" indicate absolute time value for the beginning and end time of the subtitle file
      respectively. In this case the shifting time will be calculated.

  ${bold}-p [Switch]${normal}
      Convert fps.
      Change the fps from NTSC (23.976/29.970) to PAL (25).

  ${bold}-n [Switch]${normal}
      Convert fps.
      Change the fps from PAL (25) to NTSC (23.976/29.970).

  ${bold}-a (+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff${normal}
      Adjust time.
      Beginning and end time will be set to these values and the rest will be adjusted proportionally.
      The time value is absolute if you don't use the +/- and will be shifted if you do use either sign.

  ${bold}-1 (+/-)hh:mm:ss,fff${normal}
      Adjust time.
      Beginning time will be set to this value and the rest will be adjusted proportionally.
      The time value is absolute if you don't use the +/- and will be shifted if you do use either sign.

  ${bold}-2 (+/-)hh:mm:ss,fff${normal}
      Adjust time.
      End time will be set to this value and the rest will be adjusted proportionally.
      The time value is absolute if you don't use the +/- and will be shifted if you do use either sign.
      -1 and -2 parameters can be combined (equivalent of using just the -a parameter).

  ${bold}-y \"Input file\"${normal}
      Synchronize with file.
      Supports relative or absolute paths.
      The subtitle times of the srt given with -i parameter will be adjusted with beginning and end time
      of this srt.

  ${bold}-D \"Input directory\"${normal}
      Synchronize with directory.
      To be used only with -d parameter.
      This directory contains srt subtitle files with correct times.
      Supports relative or absolute paths.
      The two directories (given with -d and -D parameters) must contain srt subtitle files with the same names.
      Synchronizes each srt subtitle file in the input directory (-d) with the srt subtitle file with the
      same name that's in the directory (-D).

  ${bold}-Y [Switch]${normal}
      Synchronize subtitle times one by one.
      Optional switch, to be used with -y or -D.
      Replaces times of file to be synchronized with times of synchronization file, respectively.

  ${bold}-f \"Find text\"${normal}
      Search, case insensitive.
      The double quotes are necessary.
      Works with srt and sub.

  ${bold}-F \"Find text\"${normal}
      Search, case sensitive.
      The double quotes are necessary.
      Works with srt and sub.

  ${bold}-e \"Text to be replaced\" \"New text\"${normal}
      Replace, case insensitive.
      The double quotes are necessary.
      Works with srt and sub.

  ${bold}-E \"Text to be replaced\" \"New text\"${normal}
      Replace, case sensitive.
      The double quotes are necessary.
      Works with srt and sub.

  ${bold}-t film${normal} or ${bold}ntsc${normal} or ${bold}pal${normal} or ${bold}custom fps${normal}
      Convert sub to srt.
      Pal = 25, film = 23.976, ntsc = 29.970. Custom fps can be integer or float number.
      Works only with sub subtitle files.

  ${bold}-u film${normal} or ${bold}ntsc${normal} or ${bold}pal${normal} or ${bold}custom fps${normal}
      Convert srt to sub.
      Pal = 25, film = 23.976, ntsc = 29.970. Custom fps can be integer or float number.
      Any srt tags that cannot be converted to sub tags will be passed unchanged to the .sub file.
      For example, a tag that includes just one word in a sentence.

  ${bold}-U film${normal} or ${bold}ntsc${normal} or ${bold}pal${normal} or ${bold}custom fps${normal}
      Convert srt to sub.
      Pal = 25, film = 23.976, ntsc = 29.970. Custom fps can be integer or float number.
      Same as the -u parameter above, but any srt tags that were not converted to respective sub tags are ignored.
      This is the behavior that you'd expect from other subtitle edit programs.

  ${bold}-j \"Input file\"${normal}
      Join two srt subtitles.
      Supports relative or absolute paths.
      This srt will be appended to the srt given with -i parameter.

  ${bold}-J hh:mm:ss,fff${normal}
      Join time.
      Optional parameter, to be used with -j.
      Shifts the time after beginning of the second srt in the output file.

  ${bold}-x (+/-)hh:mm:ss,fff${normal} or ${bold}(+/-)SUB_INTEGER${normal} or ${bold}(+/-)INTEGER:INTEGERt${normal} or ${bold}(+/-)INTEGER:INTEGERn${normal}
      Split srt subtitle.
      Can take 4 different syntaxes:
        1. (+/-)hh:mm:ss,fff:     splitting time.
        2. (+/-)SUB_INTEGER:      splitting subtitle integer.
        3. (+/-)INTEGER:INTEGERt: fraction where we split the subtitle file according to total time.
        4. (+/-)INTEGER:INTEGERn: fraction where we split the subtitle file according to number of subtitles.
      The minus sign means that counting begins from the end of the subtitle file.
      The plus sign means that counting begins from the beginning. (Equivalent of using no sign at all).

  ${bold}-X [Switch]${normal}
      Split time.
      Optional switch, to be used with -x.
      Makes the second generated srt begin with time 00:00:00,000.
      Can be used with any -x syntax.

  ${bold}-c [Switch]${normal}
      Clean trash.
      Fixes many errors usually found in subtitles:
      • Replace multiple whitespaces with one
      • clean beginning and trailing spaces
      • replace two single quotes with a double quote
      • replace 2 or more \".\" with \"...\"
      • capitalize the first letter after '.', '!' and '?'
      • remove subtitles with zero duration
      • and many more.
      Also removes subtitles that contain the key words or key phrases (case insensitive) in /etc/subeditrc.
      /etc/subeditrc is a text file that you can edit and add key words or key phrases.
      If ~/.subeditrc exists (you have to create it manually), then it will be used instead of /etc/subeditrc.
      Works with srt and sub.

  ${bold}-k '([{?mM'${normal}
      Delete text for hearing impaired.
      The ([{? characters are the symbols that the text for the hearing impaired is enclosed by.
      \"m\" and \"M\" represent the music symbols ¶♪♫.
      With \"m\" only the music symbols are deleted.
      With \"M\" the text that is enclosed by the music symbols is deleted too.
      Use only the symbol(s) that are needed for each subtitle file.
      The single quotes are necessary.
      Works with srt and sub.

  ${bold}-m [Switch]${normal}
      Fix common errors.
      Similar to Clean trash, but fixes different OCR mistakes:
      • Zero and capital 'o' ripping mistakes
      • replace \"I\" with \"l\" in the middle of a lowercase word
      • replace a single \"l\" with \"I\"
      • replace \"l'm\" with \"I'm\" etc.
      Also fixes errors in subtitle times:
      • Invalid times (duration < 0)
      • too long durations (max of 7 seconds or 0.15 seconds per character)
      • overlapping display times
      • too short durations (0.06 seconds per character or less)
      • subtitles over two lines
      • too long lines.
      Works with srt and sub.

  ${bold}-o [Switch]${normal}
      Sort subtitles by start time/frames.
      Works with srt and sub.

  ${bold}-h [Switch]${normal}
      Display help.

  ${bold}-H [Switch]${normal}
      Display help with more information and examples.\n\n\n"

examplecounter=1

text2="${cyan}NOTES${normal}
  • -i (input file) or -d (input directory) is required in every case.
  • Filenames must be enclosed in quotes if they contain spaces or other special characters (including wildcards).
  • Do not use \"~\" or \"\$HOME\" to symbolize the home directory. Write the text instead (/home/yourname).
  • -f, -F (find), -e, -E (replace), -c (clean trash), -k (delete text for HI) and -m (fix common errors) parameters
  work with both srt and sub subtitle files.
  • You can use multiple parameters in the same command. They'll run one after the other in a predetermined order.
  • Bellow you'll find examples for every parameter.\n\n\n"


text2+="${cyan}EXAMPLES${normal}
  ${bold}Basic clean-up (purify)${normal}
  ${bold}Wildcard usage${normal}

  ${bold}${green}Example $((exmpl=examplecounter++))${normal}
  subedit -i foo.srt
  Removes empty subtitles, duplicate subtitles and extra empty lines, fixes subtitles' indexes, etc.\n\n"


text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i \"*.srt\"
  Same as above, but applies to all .srt files.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -b
  Same as Example $exmpl, but creates a backup before processing the subtitle.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory
  Runs Basic clean-up for all subtitle files in directory \"foo_directory\".\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -r
  Same as above, but also processes subtitles found in subdirectories (unlimited depth) as well.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d \"Season*\" -b
  Runs Basic clean-up for all subtitles found in all folders that begin with \"Season\" and
  creates a backup for each subtitle.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d \"Season [1-3,5]\"
  Runs Basic clean-up for all subtitles found in the folders \"Season 1\", \"Season 2\", \"Season 3\" and \"Season 5\".\n\n\n"


text2+="  ${bold}Shift time${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -s 00:00:03,100
  Shifts time by 3.1 seconds.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -s +00:00:03,100
  The same as above.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -s -00:00:02,500
  Shifts time by -2.5 seconds.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -s a00:00:11,530
  Calculates and applies the appropriate shift time value so that the first subtitle starts at 00:00:11,530.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -s z01:38:32,600
  Calculates and applies the appropriate shift time value so that the last subtitle starts at 01:38:32,600.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i \"*.srt\" -s 00:00:02,000
  Shifts time by 2.0 seconds in all .srt subtitle files.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -s 00:00:01,700
  Shifts time by 1.7 seconds in all .srt subtitle files in directory \"foo_directory\".\n\n\n"


text2+="  ${bold}Convert NTSC to PAL${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -p
  Converts the fps of foo.srt from NTSC to PAL.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i \"*.srt\" -p
  Converts the fps of all .srt subtitle files from NTSC to PAL.\n\n\n"


text2+="  ${bold}Convert PAL to NTSC${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -n
  Converts the fps of foo.srt from PAL to NTSC.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -n
  Converts the fps of all .srt subtitle files in directory \"foo_directory\" from PAL to NTSC.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -r -n
  Same as above, but also processes subtitles found in subdirectories (unlimited depth) as well.\n\n\n"


text2+="  ${bold}Adjust time${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -a 00:00:17,360 00:48:02,200
  Sets beginning time to 00:00:17,360 and end time to 00:48:02,200.
  Both times are absolute.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -a +00:00:02,600 -00:00:05,920
  Shifts beginning time by +00:00:02,600 and end time by -00:00:05,920.
  Both times are relative.\n\n"

text2+="  ${bold}${green}Example $((exmpl=examplecounter++))${normal}
  subedit -i foo.srt -a 00:00:17,360 -00:00:05,920
  Sets beginning time to 00:00:17,360 and shifts end time by -00:00:05,920.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -1 00:00:17,360
  Sets beginning time to 00:00:17,360.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -2 +00:00:03,810
  Shifts end time by 00:00:03,810.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -1 00:00:17,360 -2 -00:00:05,920
  This has the same result as Example $exmpl.\n\n\n"


text2+="  ${bold}Synchronize with file${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -y boo.srt
  Synchronizes foo.srt with boo.srt. Subtitle times of foo.srt
  will be adjusted with the beginning and end time of boo.srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -y boo.srt -Y
  Synchronizes foo.srt with boo.srt. Subtitle times of foo.srt
  will be replaced with the times of boo.srt.\n\n\n"


text2+="  ${bold}Synchronize with directory${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -D boo_directory
  Synchronizes each srt subtitle file in the directory \"foo_directory\" with the srt subtitle file
  that has the same name that's in the directory \"boo_directory\".\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -D boo_directory -Y
  Synchronizes each srt subtitle file's times in the directory \"foo_directory\" with the srt
  subtitle file's times that has the same name that's in the directory \"boo_directory\",
  respectively.\n\n\n"


text2+="  ${bold}Find text${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -f \"Whatever you want\"
  Searches text \"whatever you want\" (case insensitive) and prints the lines that contain it.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -F \"Name, please.\"
  Searches text \"Name, please.\" (case sensitive) and prints the lines that contain it.\n\n\n"


text2+="  ${bold}Replace text${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -e \"Goerge\" \"George\"
  Replaces text \"goerge\" (case insensitive) with \"George\".\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -E \"wthout\" \"without\"
  Replaces text \"wthout\" (case sensitive) with \"without\".\n\n\n"


text2+="  ${bold}Convert sub to srt${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.sub -t pal
  Assumes that foo.sub is in 25 fps and creates a new file foo.srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.sub -t film
  Assumes that foo.sub is in 23.976 fps and creates a new file foo.srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.sub -t ntsc
  Assumes that foo.sub is in 29.970 fps and creates a new file foo.srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.sub -t 15.338
  Assumes that foo.sub is in 15.338 fps and creates a new file foo.srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i \"*.sub\" -t film
  Assumes that all .sub subtitle files are in 23.976 fps and converts them to srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -t film
  Assumes that all .sub subtitle files in \"foo_directory\" are in 23.976 fps and converts them to srt.\n\n\n"


text2+="  ${bold}Convert srt to sub${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -u pal
  Creates a new file foo.sub that's in 25 fps.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -U pal
  Same as above, but any srt tags that were not converted to sub tags will not pass to the .sub file.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -u film
  Creates a new file foo.sub that's in 23.976 fps.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -u ntsc
  Creates a new file foo.sub that's in 29.970 fps.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -u 12
  Creates a new file foo.sub that's in 12 fps.\n\n\n"


text2+="  ${bold}Join two srt${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -j boo.srt
  Joins foo.srt and boo.srt to a new file foo_join.srt.
  The subtitle times in boo.srt are added unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -j boo.srt -J 00:48:05,956
  Joins foo.srt and boo.srt to a new file foo_join.srt.
  The subtitle times in boo.srt are shifted by 00:48:05,956 before added.\n\n\n"


text2+="  ${bold}Split srt to two files${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x 01:02:39,000
  Splits foo.srt at 01:02:39,000 to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x -00:59:14,000
  Splits foo.srt at 00:59:14,000 (counting from the end) to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x 431
  Splits foo.srt at subtitle number 431 to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x -399
  Splits foo.srt at subtitle number 399 (counting from the end) to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x 1:2t
  Splits foo.srt at 1/2 of total time to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x -2:3t
  Splits foo.srt at 2/3 of total time (counting from the end) to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x 3:4n
  Splits foo.srt at 3/4 of total subtitles to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x -1:5n
  Splits foo.srt at 1/5 of total subtitles (counting from the end) to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x 01:02:39,000 -X
  Splits foo.srt at 01:02:39,000 to two files foo_1.srt and foo_2.srt.
  foo_2.srt begins with time 00:00:00,000.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -x -399 -X
  Splits foo.srt at subtitle number 399 (counting from the end) to two files foo_1.srt and foo_2.srt.
  foo_2.srt begins with time 00:00:00,000.\n\n\n"


text2+="  ${bold}Clean trash${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -c
  Cleans foo.srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i \"*\" -c -b
  Cleans all subtitle files and creates a backup for each one before processing it.
  Files that are not subtitle files are not processed.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -c -b
  Cleans all subtitle files in directory \"foo_directory\", and creates a backup for each one
  before processing it.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -c -r -b
  Same as above, but also processes subtitles found in subdirectories (unlimited depth) as well.\n\n\n"


text2+="  ${bold}Delete text for hearing impaired${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -k '('
  Deletes text for hearing impaired that's enclosed in parentheses.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -k '['
  Deletes text for hearing impaired that's enclosed in brackets.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -k '([{?'
  Deletes text for hearing impaired that's enclosed in all ([{? symbols.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -k 'm'
  Deletes the music symbols ¶♪♫.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -k 'M'
  Deletes text that's enclosed in the music symbols ¶♪♫.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -k '{M'
  Deletes text that's enclosed in braces and the music symbols ¶♪♫.\n\n\n"


text2+="  ${bold}Fix common errors${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -m
  Fixes common OCR mistakes, errors in display times etc.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -m -b
  Fixes common errors in all subtitle files in directory \"foo_directory\", and creates
  a backup for each one before processing it.\n\n\n"


text2+="  ${bold}Sort subtitles${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -o
  Sorts subtitles by start time.\n\n\n"


text2+="  ${bold}Multiple parameters in the same command${normal}

  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -s 00:00:03,600 -k '['
  Shifts time and deletes text for hearing impaired in foo.srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -i foo.srt -p -c
  Converts the fps from NTSC to PAL and cleans foo.srt.\n\n"

text2+="  ${bold}${green}Example $((examplecounter++))${normal}
  subedit -d foo_directory -c -k 'M' -m -b
  Cleans, deletes text that's enclosed in the music symbols ¶♪♫ and fixes common errors in all subtitle
  files in directory \"foo_directory\", and creates a backup for each one before processing it.\n\n\n"


text2+="${cyan}ABOUT${normal}
  Authors:      ${authors[0]}
                ${authors[1]}

  This program is licensed under GPLv2.\n\n"

printf "$text1"
if [[ $longhelp ]]; then
	printf "$text2"
fi
exit 0
}


# If no parameter is given then exit
if ( ! getopts ":i:d:rbs:pna:1:2:y:D:Yf:F:e:E:t:u:U:j:J:x:Xck:mohH" opt); then
	echo "Try 'subedit -h' for more information."; exit 1;
fi

# Processing parameters
while getopts ":i:d:rbs:pna:1:2:y:D:Yf:F:e:E:t:u:U:j:J:x:Xck:mohH" parameter; do
	case "$parameter" in
		i) inputfilename=$OPTARG ;;
		d) inputdirectory=$OPTARG ;;
		r) recurse="True" ;;
		b) backup="True" ;;
		s) shifttime=$OPTARG ;;
		p) ntsc2pal="True" ;;
		n) pal2ntsc="True" ;;
		a)	eval "adjustfirst=\$$((OPTIND-1))"
			eval "adjustlast=\$$((OPTIND))"
			((OPTIND++)) ;;
		1) adjustonlyfirst=$OPTARG ;;
		2) adjustonlylast=$OPTARG ;;
		y) synchronizefile=$OPTARG ;;
		D) synchronizedirectory=$OPTARG ;;
		Y) synchronizetimebytime="True" ;;
		f) findci=$OPTARG ;;
		F) findcs=$OPTARG ;;
		e)	eval "replace1=\$$((OPTIND-1))"
			eval "replace2=\$$((OPTIND))"
			((OPTIND++)) ;;
		E)	eval "replace3=\$$((OPTIND-1))"
			eval "replace4=\$$((OPTIND))"
			((OPTIND++)) ;;
		t) sub2srt=$OPTARG ;;
		u) srt2sub=$OPTARG ;;
		U) srt2sub=$OPTARG ; srt2sub_delsrttags="True" ;;
		j) joinsrt=$OPTARG ;;
		J) jointime=$OPTARG ;;
		x) splitsrt=$OPTARG ;;
		X) splittime="True" ;;
		c) cleantrash="True" ;;
		k) deletetextsforHI=$OPTARG ;;
		m) fixerrors="True" ;;
		o) sortsubs="True" ;;
		h) get_help ;;
		H) longhelp="True"; get_help ;;
		?) echo -e "${red}Error: Parameter -$OPTARG is unknown or an argument is missing.${normal}\nTry 'subedit -h' for more information."; exit 1 ;;
	esac
done

if ! [[ $inputfilename ]] && ! [[ $inputdirectory ]]; then
	echo -e "${red}Error: -i (input file) or -d (input directory) is required in every case${normal}\nTry 'subedit -h' for more information."
	exit 1
fi


### Helper functions
check_file ()
{
	if ! [[ -f "$1" ]]; then
		echo "${red}Error: \"$1\" not found.${normal}"
		return 1
	fi

	if ! [[ -r "$1" ]]; then
		echo "${red}Error: \"$1\" is not readable.${normal}"
		return 1
	fi

	encoding=$(file -b --mime-encoding "$1")
	if [[ $encoding == "binary" ]] || ! [[ $(file -b "$1") == *"text"* ]] && ! [[ $(file -b "$1") == *"Bio-Rad .PIC Image File"* ]]; then
		echo "${red}Error: \"$1\" is not a text file or it is UTF-16 without BOM${normal}"
		return 1
	fi

	# Check the file extension and create backup if it's not srt or sub
	extension="${1##*.}"
	if [[ "${extension,,}" != "srt" ]] && [[ "${extension,,}" != "sub" ]]; then
		cp "$1" "$1.bak" 2> /dev/null
	fi

	# Backup input file
	if [[ $backup ]] && [[ "$1" == "$inputfilename" ]] && ! [[ -f "$1.bak" ]]; then
		cp "$1" "$1.bak" 2> /dev/null
	fi

	# Detect encoding of input file
	# We use both file and uchardet (if it is available) because no one is perfect.
	# file doesn't get right some non-unicode encodings, but for UTF-16 is preferable
	# than uchardet because the latter doesn't specify if it is UTF-16BE or UTF-16LE.
	# uchardet doesn't exist for Cygwin, but one place you can find a Windows binary is here:
	# https://sourceforge.net/projects/cbadvanced/files/Repo/
	# For subedit to be able to use uchardet put uchardet.exe inside /bin directory in the Cygwin installation folder.
	# This uchardet has 2 problems: It needs windows-style path and it produces windows-style line endings.
	# We work around them in subedit, but keep them in mind if you use this uchardet in the console.
	if [[ $encoding == "utf-16"* ]] || [[ $encoding == *"ascii"* ]]; then
		:
	elif [[ -x /usr/bin/uchardet ]]; then
		cd "$(dirname "$1")"
		encoding=$(uchardet "$(basename "$1")" | tr -d '\r')
		cd - &> /dev/null
	fi

	# If the encoding is detected as ISO-8859-7, make it CP1253
	if [[ ${encoding^^} == "ISO-8859-7" ]]; then
		encoding="CP1253"
	fi

	# If text file is UTF-16 convert it to UTF-8
	if [[ $encoding == "utf-16"* ]]; then
		tempvar="$(cat "$1" | iconv -f $encoding -t utf-8)"
		printf "%s\n" "$tempvar" > "$1"
		encoding="utf-8"
		unset tempvar
	fi
}


read_srt ()
{
	# Make all line endings dos-like
	if ! [[ $subtitleis ]]; then
		dos2unix -q "$1" 2> /dev/null
		temptext=$(cat "$1")
		echo "$temptext" | tr '\r' '\n' > "$1"
		unix2dos -q "$1" 2> /dev/null
	fi

	# Delete tags that contain no text
	# The -b parameter open files in binary mode (CR+LFs are not processed specially) and makes sed behave in Cygwin like in Linux. In Linux it is ignored
	sed -b -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -i "$1"

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	temp1arraysrt=()
	for line in $(iconv -f $encoding -t utf-8 "$1" 2> /dev/null); do
		temp1arraysrt+=($line)
	done


	# Remove any empty lines between the integer and the time and add integer if it doesn't exist
	temp2arraysrt=()
	regexemptyorblank="^[[:blank:]]*$cr$"
	for ((i=0; i<=${#temp1arraysrt[@]}; i++)); do
		temp2arraysrt+=(${temp1arraysrt[$i]})
		if [[ ${temp1arraysrt[((i+1))]} =~ $regextime ]]; then 
			if [[ ${temp1arraysrt[$i]} =~ $regexemptyorblank ]]; then
				while :; do
					if [[ ${temp2arraysrt[-1]} =~ $regexemptyorblank ]]; then
						unset temp2arraysrt[-1]
					else
						break
					fi
				done

				if ! [[ ${temp2arraysrt[-1]} =~ $regexinteger ]]; then
					temp2arraysrt+=("$cr")
					temp2arraysrt+=("0$cr")
				fi
			fi
			if ! [[ ${temp2arraysrt[-1]} =~ $regexinteger ]]; then
				temp2arraysrt+=("$cr")
				temp2arraysrt+=("0$cr")
			fi
		fi
	done

	unset temp1arraysrt


	# If a line ends with an opening tag, move it to the beginning of the next line
	# If a line begins with a closing tag, move it to the end of the preceding line
	regexendswithopentag="^(.*)((<[ibus]>)|(<font[^>]*>))($cr)$"
	regexstartswithclosetag="^((</[ibus]>)+|(</font>)+)(.*)($cr)$"
	temp3arraysrt=()
	for ((i=0; i<=${#temp2arraysrt[@]}; i++)); do
		if [[ ${temp2arraysrt[((i+1))]} =~ $regextime ]]; then
			temp3arraysrt+=(${temp2arraysrt[$i]})
		else
			temp3arraysrt+=($tobecarriedover1e$tobecarriedover1d$tobecarriedover1c$tobecarriedover1b$tobecarriedover1a${temp2arraysrt[$i]})
		fi

		unset tobecarriedover1a tobecarriedover1b tobecarriedover1c tobecarriedover1d tobecarriedover1e

		if [[ ${temp3arraysrt[-1]} =~ $regexendswithopentag ]]; then
			unset temp3arraysrt[-1]
			temp3arraysrt+=(${BASH_REMATCH[1]}${BASH_REMATCH[5]})
			tobecarriedover1a=${BASH_REMATCH[2]}
		fi

		if [[ ${temp3arraysrt[-1]} =~ $regexendswithopentag ]]; then
			unset temp3arraysrt[-1]
			temp3arraysrt+=(${BASH_REMATCH[1]}${BASH_REMATCH[5]})
			tobecarriedover1b=${BASH_REMATCH[2]}
		fi

		if [[ ${temp3arraysrt[-1]} =~ $regexendswithopentag ]]; then
			unset temp3arraysrt[-1]
			temp3arraysrt+=(${BASH_REMATCH[1]}${BASH_REMATCH[5]})
			tobecarriedover1c=${BASH_REMATCH[2]}
		fi

		if [[ ${temp3arraysrt[-1]} =~ $regexendswithopentag ]]; then
			unset temp3arraysrt[-1]
			temp3arraysrt+=(${BASH_REMATCH[1]}${BASH_REMATCH[5]})
			tobecarriedover1d=${BASH_REMATCH[2]}
		fi

		if [[ ${temp3arraysrt[-1]} =~ $regexendswithopentag ]]; then
			unset temp3arraysrt[-1]
			temp3arraysrt+=(${BASH_REMATCH[1]}${BASH_REMATCH[5]})
			tobecarriedover1e=${BASH_REMATCH[2]}
		fi

		if [[ ${temp3arraysrt[-1]} =~ $regexstartswithclosetag ]]; then
			unset temp3arraysrt[-1]
			temp3arraysrt+=(${BASH_REMATCH[4]}${BASH_REMATCH[5]})
		fi

		if ! [[ $tobecarriedover1a ]] && ! [[ ${temp2arraysrt[$i]} =~ $regextime ]] && [[ ${temp2arraysrt[((i+1))]} =~ $regexstartswithclosetag ]]; then
			tobecarriedover2=${BASH_REMATCH[1]}
			[[ ${temp3arraysrt[-1]} =~ (.*)($cr)$ ]]
			tobecarriedover3=${BASH_REMATCH[1]}
			unset temp3arraysrt[-1]
			temp3arraysrt+=($tobecarriedover3$tobecarriedover2$cr)
			unset tobecarriedover2
			unset tobecarriedover3
		fi
	done

	unset temp2arraysrt


	# Delete tags that contain no text. Again.
	temp4arraysrt=( $(printf "%s\n" "${temp3arraysrt[@]}" | sed -b -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" -e s"/<\([ibus]\)><\/\1>//g" -e s"/<font[^>]*><\/font>//g" | iconv -f utf-8 -t $encoding) )


	# Remove any empty lines between the time and the first dialog line
	temp5arraysrt=()
	for ((i=0; i<=${#temp4arraysrt[@]}; i++)); do
		temp5arraysrt+=(${temp4arraysrt[$i]})
		if (( ${#temp5arraysrt[@]} > 1)) && [[ ${temp5arraysrt[-2]} =~ $regextime ]]; then 
			if [[ ${temp5arraysrt[-1]} =~ $regexemptyorblank ]]; then
				unset temp5arraysrt[-1]
			fi
		fi
	done

	unset temp4arraysrt


	# Remove empty subtitles, remove duplicate subtitles and remove extra empty lines before each integer
	buffer=()
	buffer_old=()	# This is used to search for duplicate subtitles
	arraysrt=()
	regexnotonlyblank="^[[:blank:]]+[^[:blank:]]+.+"
	regexblank="^[[:blank:]]+$cr$"

	# This was put inside a function because it needs to run twice
	srtcleaning ()
	{
		while :; do
			if [[ $buffer ]] && [[ ${buffer[-1]} =~ $regexemptyline ]]; then
				unset buffer[-1]
			elif [[ $buffer ]] && [[ ${buffer[-1]} =~ $regexnotonlyblank ]]; then
				break
			elif [[ $buffer ]] && [[ ${buffer[-1]} =~ $regexblank ]]; then
				unset buffer[-1]
			else
				break
			fi
		done

		if [[ $buffer_old ]] && (( ${#buffer_old[@]} == ${#buffer[@]} )); then
			check=1
			for ((j=1; j<=${#buffer_old[@]}-1; j++)); do
				if [[ ${buffer_old[$j],,} == ${buffer[$j],,} ]]; then
					((check++))
				else
					break
				fi
			done
			if (( $check == ${#buffer_old[@]} )); then
				duplicatefound="True"
			fi
		fi

		if ! [[ $duplicatefound ]] && [[ $buffer ]] && ! [[ ${buffer[-1]} =~ $regextime ]]; then
			arraysrt+=("${buffer[@]}")
			arraysrt+=("$cr")
		fi
	}

	for ((i=0; i<=${#temp5arraysrt[@]}; i++)); do
		if [[ ${temp5arraysrt[$i]} =~ $regexinteger ]] && [[ ${temp5arraysrt[((i+1))]} =~ $regextime ]]; then
			srtcleaning

			unset duplicatefound
			buffer_old=()
			buffer_old+=("${buffer[@]}")
			buffer=()
		fi
		buffer+=(${temp5arraysrt[$i]})
	done

	unset temp5arraysrt

	# Everything inside the previous for-loop must run one last time for the last subtitle
	srtcleaning

	IFS=$old_IFS		# restore default field separator

	# Re-create the subtitle array with new counter
	subcounter=0
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		if [[ ${arraysrt[$i]} =~ $regexinteger ]] && [[ ${arraysrt[((i+1))]} =~ $regextime ]]; then
			((subcounter++))
			arraysrt[$i]="$subcounter$cr"
		fi
	done

	# Remove an empty line at the end
	if [[ $arraysrt ]] && [[ ${arraysrt[-1]} =~ $regexemptyline ]]; then
		unset arraysrt[-1]
	fi
}


read_sub ()
{
	# Make all line endings dos-like
	if ! [[ $subtitleis ]]; then
		dos2unix -q "$1" 2> /dev/null
		temptext=$(cat "$1")
		echo "$temptext" | tr '\r' '\n' > "$1"
		unix2dos -q "$1" 2> /dev/null
	fi

	# Remove any empty subtitle lines before the first non-empty dialog line
	sed -b s'/^\({[0-9]\+}{[0-9]\+}\)\(\({[CSFPY]:[^}]*}\)*\)\([|[:blank:]]*[|]*\({[csfy]:[^}]*}\)*[|[:blank:]]*[|]\)*\(.*\)/\1\2\6/'g -i "$1"

	# Regular expressions for multiple tags that need to become one
	color_size_TAGS="((\{[S]:[0-9]+\})?(\{[C]:[$][A-F0-9]{6}\})?(\{[S]:[0-9]+\})?)"
	color_size_tags="((\{[s]:[0-9]+\})?(\{[c]:[$][A-F0-9]{6}\})?(\{[s]:[0-9]+\})?)"
	regex_merge_Y_tags="^(\{[0-9]+\}\{[0-9]+\}$color_size_TAGS)$color_size_tags({Y:([ibus]+)})?$color_size_TAGS$color_size_tags({Y:([ibus]+)})?$color_size_TAGS$color_size_tags({Y:([ibus]+)})?$color_size_TAGS$color_size_tags({Y:([ibus]+)})?(.*)$"
	regex_merge_y_tags1="^(\{[0-9]+\}\{[0-9]+\}$color_size_TAGS({Y:[ibus]+})?$color_size_tags)({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?(.*)$"
	regex_merge_y_tags2="^($color_size_tags)({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?(.*)$"

	# Read text file to array and delete empty and duplicate subs
	arraysub=()
	regexemptysub="^\{([0-9]+)\}\{([0-9]+)\}(\{[cCsSfFPyY]:[^}]*\})*([|[:blank:]]*)$cr$"
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(iconv -f $encoding -t utf-8 "$1" 2> /dev/null); do
		if [[ $line =~ $regexsub1 ]]; then
			arraysub+=($line)
		fi
		break
	done

	for line in $(iconv -f $encoding -t utf-8 "$1" 2> /dev/null); do
		if ! [[ $line =~ $regexemptysub ]] && ! [[ $line =~ $regexsub1 ]] && [[ $line =~ $regexsub ]] && [[ ${line,,} != ${arraysub[-1],,} ]]; then
			# Merge multiple Y tags
			if [[ $line =~ $regex_merge_Y_tags ]] && [[ ${BASH_REMATCH[10]} ]]; then
				ibus_matches=${BASH_REMATCH[11]}${BASH_REMATCH[21]}${BASH_REMATCH[31]}${BASH_REMATCH[41]}
				tag_values=""
				if [[ $ibus_matches == *"i"* ]]; then tag_values+="i"; fi
				if [[ $ibus_matches == *"b"* ]]; then tag_values+="b"; fi
				if [[ $ibus_matches == *"u"* ]]; then tag_values+="u"; fi
				if [[ $ibus_matches == *"s"* ]]; then tag_values+="s"; fi
				line="${BASH_REMATCH[1]}${BASH_REMATCH[12]}${BASH_REMATCH[22]}${BASH_REMATCH[32]}{Y:$tag_values}${BASH_REMATCH[6]}${BASH_REMATCH[16]}${BASH_REMATCH[26]}${BASH_REMATCH[36]}${BASH_REMATCH[42]}"
			fi

			# Remove the \r in the line ending to workaround read's inconsistency between Cygwin and Linux
			if [[ $line =~ ^(.+)$cr$ ]]; then
				line=${BASH_REMATCH[1]}
			fi

			# Split the line in the '|' character and store it to an array
			IFS=$'|'
			read -r -a split_line <<< "$line"

			# Merge multiple y tags in the first line
			if [[ ${split_line[0]} =~ $regex_merge_y_tags1 ]] && [[ ${BASH_REMATCH[11]} ]]; then
				ibus_matches=${BASH_REMATCH[12]}${BASH_REMATCH[18]}${BASH_REMATCH[24]}${BASH_REMATCH[30]}
				tag_values=""
				if [[ $ibus_matches == *"i"* ]]; then tag_values+="i"; fi
				if [[ $ibus_matches == *"b"* ]]; then tag_values+="b"; fi
				if [[ $ibus_matches == *"u"* ]]; then tag_values+="u"; fi
				if [[ $ibus_matches == *"s"* ]]; then tag_values+="s"; fi
				split_line[0]="${BASH_REMATCH[1]}${BASH_REMATCH[13]}${BASH_REMATCH[19]}${BASH_REMATCH[25]}{y:$tag_values}${BASH_REMATCH[31]}"
			fi
			line_new=${split_line[0]}

			# Merge multiple y tags in the rest of the lines
			for ((i=1; i<=${#split_line[@]}-1; i++)); do
				if [[ ${split_line[$i]} =~ $regex_merge_y_tags2 ]] && [[ ${BASH_REMATCH[6]} ]]; then
					ibus_matches=${BASH_REMATCH[7]}${BASH_REMATCH[13]}${BASH_REMATCH[19]}${BASH_REMATCH[25]}
					tag_values=""
					if [[ $ibus_matches == *"i"* ]]; then tag_values+="i"; fi
					if [[ $ibus_matches == *"b"* ]]; then tag_values+="b"; fi
					if [[ $ibus_matches == *"u"* ]]; then tag_values+="u"; fi
					if [[ $ibus_matches == *"s"* ]]; then tag_values+="s"; fi
					split_line[$i]="${BASH_REMATCH[1]}${BASH_REMATCH[8]}${BASH_REMATCH[14]}${BASH_REMATCH[20]}{y:$tag_values}${BASH_REMATCH[26]}"
				fi
				line_new+="|${split_line[$i]}"
			done
			IFS=$'\n'

			arraysub+=($line_new$cr)
		fi 2> /dev/null
	done

	IFS=$old_IFS		# restore default field separator
}


check_srt ()
{
	# Check the file extension
	extension="${1##*.}"
	if [[ "${extension,,}" != "srt" ]]; then
		echo "${bold}${red}Warning: \"$1\" does not have '.srt' extension${normal}"
	fi

	srtok=""
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		if [[ ${arraysrt[$i]} =~ $regextime ]]; then
			if [[ $2 ]]; then echo $2; fi
			srtok="true"
			break
		fi
	done

	if ! [[ $srtok ]]; then
		if ! [[ -r "$1.bak" ]]; then
			echo "${bold}${red}Warning: \"$1.bak\" is not readable${normal}"
		fi
		if [[ $backup ]]; then
			cp "$1.bak" "$1" 2> /dev/null
		else
			mv "$1.bak" "$1" 2> /dev/null
		fi
		echo "${red}Error: \"$1\" is not a valid srt file${normal}"
		return 1
	elif ! [[ $backup ]]; then
		rm -f "$1.bak" 2> /dev/null
	fi
}


check_sub ()
{
	# Check the file extension
	extension="${1##*.}"
	if [[ "${extension,,}" != "sub" ]]; then
		echo "${bold}${red}Warning: \"$1\" does not have '.sub' extension${normal}"
	fi

	subok=""
	for ((i=0; i<=${#arraysub[@]}; i++)); do
		line=${arraysub[$i]}

		if ! [[ $line =~ $regexsub1 ]] && [[ $line =~ $regexsub ]]; then
			if [[ $2 ]]; then echo $2; fi
			subok="true"
			break
		fi
	done

	if ! [[ $subok ]]; then
		if ! [[ -r "$1.bak" ]]; then
			echo "${bold}${red}Warning: \"$1.bak\" is not readable${normal}"
		fi
		if [[ $backup ]]; then
			cp "$1.bak" "$1" 2> /dev/null
		else
			mv "$1.bak" "$1" 2> /dev/null
		fi
		echo "${red}Error: \"$1\" is not a valid sub file${normal}"
		return 1
	elif ! [[ $backup ]]; then
		rm -f "$1.bak" 2> /dev/null
	fi
}


check_srt_and_sub ()
{
	# Make all line endings dos-like
	dos2unix -q "$1" 2> /dev/null
	temptext=$(cat "$1")
	echo "$temptext" | tr '\r' '\n' > "$1"
	unix2dos -q "$1" 2> /dev/null

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	array=()
	for line in $(iconv -f $encoding -t utf-8 "$1" 2> /dev/null); do
		array+=($line)
	done

	IFS=$old_IFS		# restore default field separator

	subtitleis=""
	for ((i=0; i<=${#array[@]}; i++)); do
		if ! [[ ${array[$i]} =~ $regexsub1 ]] && [[ ${array[$i]} =~ $regexsub ]]; then
			if [[ $2 ]]; then echo $2; fi
			subtitleis="sub"
			# Check the file extension
			extension="${1##*.}"
			if [[ "${extension,,}" != "sub" ]]; then
				echo "${bold}${red}Warning: \"$1\" does not have '.sub' extension${normal}"
			fi
			break
		elif [[ ${array[$i]} =~ $regextime ]]; then
			if [[ $2 ]]; then echo $2; fi
			subtitleis="srt"
			# Check the file extension
			extension="${1##*.}"
			if [[ "${extension,,}" != "srt" ]]; then
				echo "${bold}${red}Warning: \"$1\" does not have '.srt' extension${normal}"
			fi
			break
		fi
	done

	if ! [[ $subtitleis ]]; then
		mv "$1.bak" "$1" 2> /dev/null
		echo "${red}Error: \"$1\" is not a valid srt or sub file${normal}"
		return 1
	elif ! [[ $backup ]]; then
		rm -f "$1.bak" 2> /dev/null
	fi
}


### Main functions
basic_clean_up ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the srt or sub is OK
	check_srt_and_sub "$inputfilename" "Purifying \"$inputfilename\""

	# Exit this function if the return code of check_srt_and_sub is not 0
	if (($? != 0)); then
		return 1
	fi

	case "$subtitleis" in
		"srt") read_srt "$inputfilename"; printf "%s\n" "${arraysrt[@]}" > "$inputfilename" ;;
		"sub") read_sub "$inputfilename"; printf "%s\n" "${arraysub[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename" ;;
	esac

	unset subtitleis
}


shift_time ()
{
	# Calculate the time to move the subs
	regexshift="^([az+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

	if [[ $shifttime =~ $regexshift ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "${red}Error: Syntax must be like '(+/-/a/z)hh:mm:ss,fff'${normal}"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )); then
		echo "${red}Error: Minutes and seconds must take a value of less than 60${normal}"; exit 1
	fi

	givenms=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))


	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	check_srt "$inputfilename" "Shifting time of \"$inputfilename\" by $shifttime..."

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi


	# Find shift milliseconds
	if [[ $sign == "a" ]]; then
		# Find the first subtitle time
		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h1a="${BASH_REMATCH[1]}"
				m1a="${BASH_REMATCH[2]}"
				s1a="${BASH_REMATCH[3]}"
				f1a="${BASH_REMATCH[4]}"

				break
			fi
		done

		# Time in milliseconds of the start time of the first subtitle
		pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

		# Shift milliseconds
		((p=givenms-pa))
	elif [[ $sign == "z" ]]; then
		# Find the last subtitle time
		for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h1b="${BASH_REMATCH[1]}"
				m1b="${BASH_REMATCH[2]}"
				s1b="${BASH_REMATCH[3]}"
				f1b="${BASH_REMATCH[4]}"

				break
			fi
		done

		# Time in milliseconds of the start time of the last subtitle
		pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))

		# Shift milliseconds
		((p=givenms-pb))
	else
		# Shift milliseconds
		p=$sign$givenms
	fi


	# Process the array
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p1 + $p))
			p2_new=$(($p2 + $p))

			if (( $p1_new < 0 )) || (( $p2_new < 0 )); then
				echo "${red}Error: Negative time not allowed. Check the shifting value.${normal}"; return 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new$cr
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


change_fps ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	if [[ $pal2ntsc ]]; then
		check_srt "$inputfilename" "Changing fps of \"$inputfilename\" from PAL (25) to NTSC (23.976 or 29.970)..."
	elif [[ $ntsc2pal ]]; then
		check_srt "$inputfilename" "Changing fps of \"$inputfilename\" from NTSC (23.976 or 29.970) to PAL (25)..."
	fi

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Process the array
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			if [[ $pal2ntsc ]]; then
				p1_new=$(($p1 * 1001 / 960))
				p2_new=$(($p2 * 1001 / 960))
			elif [[ $ntsc2pal ]]; then
				p1_new=$(($p1 * 960 / 1001))
				p2_new=$(($p2 * 960 / 1001))
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new$cr
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


adjust_time ()
{
	# Calculate the time to move the subs
	regexadjust="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

	if [[ $adjustfirst =~ $regexadjust ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "${red}Error: Syntax must be like '(+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff'${normal}"; exit 1
	fi

	if [[ $adjustlast =~ $regexadjust ]]; then
		sign_="${BASH_REMATCH[1]}"
		h_="${BASH_REMATCH[2]}"
		m_="${BASH_REMATCH[3]}"
		s_="${BASH_REMATCH[4]}"
		f_="${BASH_REMATCH[5]}"
	else
		echo "${red}Error: Syntax must be like '(+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff'${normal}"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
		echo "${red}Error: Minutes and seconds must take a value of less than 60${normal}"; exit 1
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	check_srt "$inputfilename" "Adjusting time of \"$inputfilename\"..."

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the file has only 1 subtitle
	if ((subcounter == 1)); then
		echo "${red}Error: File has only 1 subtitle. Use Shift time (-s parameter) instead.${normal}"; return 1
	fi


	# Find the first and last subtitle time
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	# Time in milliseconds of the start time of the first subtitle
	pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in milliseconds of the start time of the last subtitle
	pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Calculate the NEW first and last subtitle
	if [[ $sign ]]; then
		p=$(($pa $sign $(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))))
	else
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
	fi

	if [[ $sign_ ]]; then
		p_=$(($pb $sign_ $(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))))
	else
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))
	fi


	if (( $pa == $pb )); then
		echo "${red}Error: Cannot process the file. The first subtitle starts at the same time as the last subtitle${normal}"; return 1
	elif (( $pa > $pb )); then
		echo "${red}Error: Cannot process the file. The first subtitle starts after the last subtitle${normal}"; return 1
	fi

	if (( $p == $p_ )); then
		echo "${red}Error: The first subtitle cannot start at the same time as the last subtitle${normal}"; return 1
	elif (( $p > $p_ )); then
		echo "${red}Error: The first subtitle cannot start after the last subtitle${normal}"; return 1
	fi


	# Process the array
	diff1=$(($p_ - $p))
	diff2=$(($pb - $pa))

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
			p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

			if (( $p1_new < 0 )) || (( $p2_new < 0 )); then
				echo "${red}Error: Negative time not allowed. Check the adjusting values.${normal}"; return 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new$cr
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


adjust_time_v2 ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	check_srt "$inputfilename" "Adjusting time of \"$inputfilename\"..."

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the file has only 1 subtitle
	if ((subcounter == 1)); then
		echo "${red}Error: File has only 1 subtitle. Use Shift time (-s parameter) instead.${normal}"; return 1
	fi


	# Find the first and last subtitle time
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	if (( 10#$m1a >= 60 )) || (( 10#$s1a >= 60 )) || (( 10#$m1b >= 60 )) || (( 10#$s1b >= 60 )); then
		echo "${red}Error: The first or last subtitle time is invalid.${normal}"; return 1
	fi

	# Time in milliseconds of the start time of the first subtitle
	pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in milliseconds of the start time of the last subtitle
	pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Calculate the time to move the subs
	regexadjust="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

	if ! [[ $adjustonlyfirst ]]; then
		h=$h1a
		m=$m1a
		s=$s1a
		f=$f1a
	elif [[ $adjustonlyfirst =~ $regexadjust ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "${red}Error: Syntax must be like '(+/-)hh:mm:ss,fff'${normal}"; exit 1
	fi

	if ! [[ $adjustonlylast ]]; then
		h_=$h1b
		m_=$m1b
		s_=$s1b
		f_=$f1b
	elif [[ $adjustonlylast =~ $regexadjust ]]; then
		sign_="${BASH_REMATCH[1]}"
		h_="${BASH_REMATCH[2]}"
		m_="${BASH_REMATCH[3]}"
		s_="${BASH_REMATCH[4]}"
		f_="${BASH_REMATCH[5]}"
	else
		echo "${red}Error: Syntax must be like '(+/-)hh:mm:ss,fff'${normal}"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
		echo "${red}Error: Minutes and seconds must take a value of less than 60${normal}"; exit 1
	fi


	# Calculate the NEW first and last subtitle
	if [[ $sign ]]; then
		p=$(($pa $sign $(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))))
	else
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
	fi

	if [[ $sign_ ]]; then
		p_=$(($pb $sign_ $(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))))
	else
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))
	fi


	if (( $pa == $pb )); then
		echo "${red}Error: Cannot process the file. The first subtitle starts at the same time as the last subtitle${normal}"; return 1
	elif (( $pa > $pb )); then
		echo "${red}Error: Cannot process the file. The first subtitle starts after the last subtitle${normal}"; return 1
	fi

	if (( $p == $p_ )); then
		echo "${red}Error: The first subtitle cannot start at the same time as the last subtitle${normal}"; return 1
	elif (( $p > $p_ )); then
		echo "${red}Error: The first subtitle cannot start after the last subtitle${normal}"; return 1
	fi


	# Process the array
	diff1=$(($p_ - $p))
	diff2=$(($pb - $pa))

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
			p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

			if (( $p1_new < 0 )) || (( $p2_new < 0 )); then
				echo "${red}Error: Negative time not allowed. Check the adjusting values.${normal}"; return 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new$cr
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


synchronize_with_file ()
{
	if [[ $synchronizedirectory ]]; then
		synchronizefile="$synchronizedirectory/$(basename "$inputfilename")"
		if ! [[ -f "$synchronizefile" ]]; then
			echo "${red}Error: \"$synchronizefile\" not found.${normal}"
			return 1
		fi

		if ! [[ -r "$synchronizefile" ]]; then
			echo "${red}Error: \"$synchronizefile\" is not readable.${normal}"
			return 1
		fi
	fi

	# Check if the synchronize file is a text
	check_file "$synchronizefile"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read file to synchronize to
	read_srt "$synchronizefile"

	# Check if the srt is OK
	check_srt "$synchronizefile"

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi


	if ! [[ $synchronizetimebytime ]]; then
		# Find the first and last subtitle time of the file to synchronize to
		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h="${BASH_REMATCH[1]}"
				m="${BASH_REMATCH[2]}"
				s="${BASH_REMATCH[3]}"
				f="${BASH_REMATCH[4]}"

				break
			fi
		done

		for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h_="${BASH_REMATCH[1]}"
				m_="${BASH_REMATCH[2]}"
				s_="${BASH_REMATCH[3]}"
				f_="${BASH_REMATCH[4]}"

				break
			fi
		done

		if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
			echo "${red}Error: The first or last subtitle time of the subtitle you want to synchronize with, is invalid.${normal}"; return 1
		fi

		# Calculate the NEW first and last subtitle
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))

		if (( $p == $p_ )); then
			echo "${red}Error: The first subtitle cannot start at the same time as the last subtitle${normal}"; return 1
		elif (( $p > $p_ )); then
			echo "${red}Error: The first subtitle cannot start after the last subtitle${normal}"; return 1
		fi


		# Check if the input file is a text
		check_file "$inputfilename"

		# Exit this function if the return code of check_file is not 0
		if (($? != 0)); then
			return 1
		fi

		# Read text file to arraysrt
		read_srt "$inputfilename"

		# Check if the srt is OK
		check_srt "$inputfilename" "Synchronizing \"$inputfilename\" with \"$synchronizefile\"..."

		# Exit this function if the return code of check_srt is not 0
		if (($? != 0)); then
			return 1
		fi

		# Check if the file has only 1 subtitle
		if ((subcounter == 1)); then
			echo "${red}Error: File has only 1 subtitle. Use Shift time (-s parameter) instead.${normal}"; return 1
		fi


		# Find the first and last subtitle time
		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h1a="${BASH_REMATCH[1]}"
				m1a="${BASH_REMATCH[2]}"
				s1a="${BASH_REMATCH[3]}"
				f1a="${BASH_REMATCH[4]}"

				break
			fi
		done

		for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h1b="${BASH_REMATCH[1]}"
				m1b="${BASH_REMATCH[2]}"
				s1b="${BASH_REMATCH[3]}"
				f1b="${BASH_REMATCH[4]}"

				break
			fi
		done

		# Time in milliseconds of the start time of the first subtitle
		pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

		# Time in milliseconds of the start time of the last subtitle
		pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))

		if (( $pa == $pb )); then
			echo "${red}Error: Cannot process the file. The first subtitle starts at the same time as the last subtitle${normal}"; return 1
		elif (( $pa > $pb )); then
			echo "${red}Error: Cannot process the file. The first subtitle starts after the last subtitle${normal}"; return 1
		fi


		# Process the array
		diff1=$(($p_ - $p))
		diff2=$(($pb - $pa))

		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				h2="${BASH_REMATCH[5]}"
				m2="${BASH_REMATCH[6]}"
				s2="${BASH_REMATCH[7]}"
				f2="${BASH_REMATCH[8]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
				p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

				p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
				p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

				if (( $p1_new < 0 )) || (( $p2_new < 0 )); then
					echo "${red}Error: Negative time not allowed. Check the adjusting values.${normal}"; return 1
				fi

				j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
				j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

				line_new="$j1 --> $j2"

				arraysrt[$i]=$line_new$cr
			fi
		done
	else
		# Copy the times of arraysrt to arraysynchronize
		arraysynchronize=()

		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			if [[ ${arraysrt[$i]} =~ $regextime ]]; then
				arraysynchronize+=("${arraysrt[$i]}")
			fi
		done

		# Check if the input file is a text
		check_file "$inputfilename"

		# Exit this function if the return code of check_file is not 0
		if (($? != 0)); then
			return 1
		fi

		# Read text file to arraysrt
		read_srt "$inputfilename"

		# Check if the srt is OK
		check_srt "$inputfilename" "Synchronizing \"$inputfilename\" with \"$synchronizefile\"..."

		# Exit this function if the return code of check_srt is not 0
		if (($? != 0)); then
			return 1
		fi

		counter=0
		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			if [[ ${arraysrt[$i]} =~ $regextime ]]; then
				if [[ ${arraysynchronize[$counter]} ]]; then
					arraysrt[$i]="${arraysynchronize[$counter]}"
					((counter++))
				else
					break
				fi
			fi
		done
	fi

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


find_text ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	if [[ $findci ]]; then
		find=$findci
	elif [[ $findcs ]]; then
		find=$findcs
	fi

	# Check if the srt or sub is OK
	check_srt_and_sub "$inputfilename"
	echo -e "Finding \"$find\" in file \"$inputfilename\""

	# Exit this function if the return code of check_srt_and_sub is not 0
	if (($? != 0)); then
		return 1
	fi

	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	if [[ $findci ]]; then
		iconv -f $encoding -t utf-8 "$inputfilename" 2> /dev/null | grep $find -ni | sed s'/:/: /' | while read -r line; do echo "line $line"; done
	else
		iconv -f $encoding -t utf-8 "$inputfilename" 2> /dev/null | grep $find -n | sed s'/:/: /' | while read -r line; do echo "line $line"; done
	fi

	IFS=$old_IFS		# restore default field separator
}


replace_text ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	if [[ $replace3 ]]; then
		replace1=$replace3
		replace2=$replace4
	fi

	# Define forbidden and allowed regex
	regexforbiddensynbols="^[0-9<>\/:{}\$=#-,]+$"
	regexallowedtimes="^[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$"
	regexallowedframes="^\{[0-9]+\}\{[0-9]+\}$"
	regexallowedtime="^[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$"
	regexallowedframe="^\{[0-9]+\}$"

	if ! [[  $replace1 =~  $regexallowedtimes ]] && ! [[  $replace1 =~  $regexallowedframes ]] && ! [[  $replace1 =~  $regexallowedtime ]] && ! [[  $replace1 =~  $regexallowedframe ]] && [[ $replace1 =~ $regexforbiddensynbols ]]; then
		echo "${red}Error: You cannot replace this${normal}"; exit 1
	fi

	# Check if the srt or sub is OK
	check_srt_and_sub "$inputfilename" "Replacing \"$replace1\" with \"$replace2\" in file \"$inputfilename\""

	# Exit this function if the return code of check_srt_and_sub is not 0
	if (($? != 0)); then
		return 1
	fi

	IFS=$'\n'			# new field separator, the end of line

	if [[ $replace3 ]]; then
		case "$subtitleis" in
			"srt")
				read_srt "$inputfilename"
				temparray=( $(printf "%s\n" "${arraysrt[@]}" | iconv -f $encoding -t utf-8 | sed -b s"/$replace1/$replace2/g") )
				# If the conversion from UTF-8 to the original encoding isn't possible, keep the UTF-8
				printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding &> /dev/null
				if (($? == 0)); then
					printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
				else
					printf "%s\n" "${temparray[@]}" > "$inputfilename"
					echo "${bold}${red}Warning: \"$inputfilename\" has been saved with UTF-8 encoding${normal}"
				fi
				unset temparray ;;
			"sub")
				read_sub "$inputfilename"
				temparray=( $(printf "%s\n" "${arraysub[@]}" | sed -b s"/$replace1/$replace2/g") )
				# If the conversion from UTF-8 to the original encoding isn't possible, keep the UTF-8
				printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding &> /dev/null
				if (($? == 0)); then
					printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
				else
					printf "%s\n" "${temparray[@]}" > "$inputfilename"
					echo "${bold}${red}Warning: \"$inputfilename\" has been saved with UTF-8 encoding${normal}"
				fi
				unset temparray ;;
		esac
	else
		case "$subtitleis" in
			"srt")
				read_srt "$inputfilename"
				temparray=( $(printf "%s\n" "${arraysrt[@]}" | iconv -f $encoding -t utf-8 | sed -b s"/$replace1/$replace2/ig") )
				# If the conversion from UTF-8 to the original encoding isn't possible, keep the UTF-8
				printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding &> /dev/null
				if (($? == 0)); then
					printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
				else
					printf "%s\n" "${temparray[@]}" > "$inputfilename"
					echo "${bold}${red}Warning: \"$inputfilename\" has been saved with UTF-8 encoding${normal}"
				fi
				unset temparray ;;
			"sub")
				read_sub "$inputfilename"
				temparray=( $(printf "%s\n" "${arraysub[@]}" | sed -b s"/$replace1/$replace2/ig") )
				# If the conversion from UTF-8 to the original encoding isn't possible, keep the UTF-8
				printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding &> /dev/null
				if (($? == 0)); then
					printf "%s\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
				else
					printf "%s\n" "${temparray[@]}" > "$inputfilename"
					echo "${bold}${red}Warning: \"$inputfilename\" has been saved with UTF-8 encoding${normal}"
				fi
				unset temparray ;;
		esac
	fi

	IFS=$old_IFS		# restore default field separator
}


sub2_srt ()
{
	if [[ $sub2srt == "pal" ]]; then ratio=1; fps=25025
	elif [[ $sub2srt == "film" ]]; then ratio=1; fps=24000
	elif [[ $sub2srt == "ntsc" ]]; then ratio=1; fps=30000
	elif [[ $sub2srt =~ ^[0-9]+$ ]]; then ratio=1; fps=$(($sub2srt * 1001))
	elif [[ $sub2srt =~ ^[0-9]+\.[0-9]*$ ]]; then fpsint=${sub2srt%.*}; fpsdecimal=${sub2srt##*.}; decimallength=${#fpsdecimal}; if (( $decimallength == 0 )); then ratio=1; else ratio=1$(eval printf '0%.0s' {1..$decimallength}); fi; fps=$(($(echo $fpsint$fpsdecimal) * 1001))
	else echo -e "${red}Error: The sub2srt parameter only accepts the arguments pal, film, ntsc or a custom framerate.\n       Pal = 25, film = 23.976 and ntsc = 29.970${normal}"; exit 1
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraysub
	read_sub "$inputfilename"

	# Check if the sub is OK
	newfilename="${inputfilename%.*}.srt"
	check_sub "$inputfilename" "Converting \"$inputfilename\" to \"$newfilename\"..."

	# Exit this function if the return code of check_sub is not 0
	if (($? != 0)); then
		return 1
	fi

	# Process the arraysub and at the same time create the arraysrt
	arraysrt=()
	linecounter=0
	IFS=$'|'			# new field separator, the new line character in sub file
	tag="\{(c|C|s|S|f|F|P|y|Y):[0-9a-zA-Z$,]+\}"
	regextags="^($tag){1}($tag)?($tag)?($tag)?($tag)?($tag)?($tag)?($tag)?(.+)$"

	for ((i=0; i<=${#arraysub[@]}-1; i++)); do
		line=${arraysub[$i]}

		if ! [[ $line =~ $regexsub1 ]] && [[ $line =~ $regexsub ]]; then
			framesstart="${BASH_REMATCH[1]}"
			framesend="${BASH_REMATCH[2]}"
			subs="${BASH_REMATCH[3]}"

			p1=$((1001000 * $ratio * $framesstart / $fps))
			p2=$((1001000 * $ratio * $framesend / $fps))

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1 / 3600000)) $(($(($p1 % 3600000)) / 60000)) $(($(($p1 % 60000)) / 1000)) $(($p1 % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2 / 3600000)) $(($(($p2 % 3600000)) / 60000)) $(($(($p2 % 60000)) / 1000)) $(($p2 % 1000)))

			read -r -a arraysubs <<< "$subs"

			for ((j=0; j<=${#arraysubs[@]}-1; j++)); do
				text=${arraysubs[$j]}

				if [[ $text =~ $regextags ]]; then
					tagvalue1="${BASH_REMATCH[1]}"
					tag1="${BASH_REMATCH[2]}"
					tagvalue2="${BASH_REMATCH[3]}"
					tag2="${BASH_REMATCH[4]}"
					tagvalue3="${BASH_REMATCH[5]}"
					tag3="${BASH_REMATCH[6]}"
					tagvalue4="${BASH_REMATCH[7]}"
					tag4="${BASH_REMATCH[8]}"
					tagvalue5="${BASH_REMATCH[9]}"
					tag5="${BASH_REMATCH[10]}"
					tagvalue6="${BASH_REMATCH[11]}"
					tag6="${BASH_REMATCH[12]}"
					tagvalue7="${BASH_REMATCH[13]}"
					tag7="${BASH_REMATCH[14]}"
					tagvalue8="${BASH_REMATCH[15]}"
					tag8="${BASH_REMATCH[16]}"
					justtext="${BASH_REMATCH[17]}"

					# Remove tags that are in-between the text.
					unnecessarytags="(.*)\{(c|C|s|S|f|F|P|y|Y):[0-9a-zA-Z$,]+\}(.*)"
					while [[ $justtext =~ $unnecessarytags ]]; do
						justtext=${BASH_REMATCH[1]}${BASH_REMATCH[3]}
					done

					# Remove tags that are ignored (position, font).
					arraysubs[$j]=$justtext

					# In YYY we gather the tags that affect all lines and in yyy the tags that affect only one line.
					YYY=""
					yyy=""

					if [[ $tag1 == "Y" ]]; then YYY+=$tagvalue1; fi
					if [[ $tag2 == "Y" ]]; then YYY+=$tagvalue2; fi
					if [[ $tag3 == "Y" ]]; then YYY+=$tagvalue3; fi
					if [[ $tag4 == "Y" ]]; then YYY+=$tagvalue4; fi
					if [[ $tag5 == "Y" ]]; then YYY+=$tagvalue5; fi
					if [[ $tag6 == "Y" ]]; then YYY+=$tagvalue6; fi
					if [[ $tag7 == "Y" ]]; then YYY+=$tagvalue7; fi
					if [[ $tag8 == "Y" ]]; then YYY+=$tagvalue8; fi

					if [[ $tag1 == "y" ]]; then yyy+=$tagvalue1; fi
					if [[ $tag2 == "y" ]]; then yyy+=$tagvalue2; fi
					if [[ $tag3 == "y" ]]; then yyy+=$tagvalue3; fi
					if [[ $tag4 == "y" ]]; then yyy+=$tagvalue4; fi
					if [[ $tag5 == "y" ]]; then yyy+=$tagvalue5; fi
					if [[ $tag6 == "y" ]]; then yyy+=$tagvalue6; fi
					if [[ $tag7 == "y" ]]; then yyy+=$tagvalue7; fi
					if [[ $tag8 == "y" ]]; then yyy+=$tagvalue8; fi

					suffix=""
					case ${YYY,,} in
						*"s"*) justtext="<s>"$justtext; arraysubs[$j]=$justtext; suffix+="</s>" ;;&
						*"u"*) justtext="<u>"$justtext; arraysubs[$j]=$justtext; suffix+="</u>" ;;&
						*"b"*) justtext="<b>"$justtext; arraysubs[$j]=$justtext; suffix+="</b>" ;;&
						*"i"*) justtext="<i>"$justtext; arraysubs[$j]=$justtext; suffix+="</i>" ;;
					esac
					arraysubs[-1]+=$suffix
					if ((${#arraysubs[@]} == 1)); then
						justtext+=$suffix
					fi
					suffix=""

					case ${yyy,,} in
						*"s"*) justtext="<s>"$justtext"</s>"; arraysubs[$j]=$justtext ;;&
						*"u"*) justtext="<u>"$justtext"</u>"; arraysubs[$j]=$justtext ;;&
						*"b"*) justtext="<b>"$justtext"</b>"; arraysubs[$j]=$justtext ;;&
						*"i"*) justtext="<i>"$justtext"</i>"; arraysubs[$j]=$justtext ;;
					esac

					# COLOR is the tag that affects all lines and color is the tag that affects only one line.
					COLOR=""
					color=""

					if [[ $tag1 == "C" ]]; then COLOR=$tagvalue1; fi
					if [[ $tag2 == "C" ]]; then COLOR=$tagvalue2; fi
					if [[ $tag3 == "C" ]]; then COLOR=$tagvalue3; fi
					if [[ $tag4 == "C" ]]; then COLOR=$tagvalue4; fi
					if [[ $tag5 == "C" ]]; then COLOR=$tagvalue5; fi
					if [[ $tag6 == "C" ]]; then COLOR=$tagvalue6; fi
					if [[ $tag7 == "C" ]]; then COLOR=$tagvalue7; fi
					if [[ $tag8 == "C" ]]; then COLOR=$tagvalue8; fi

					if [[ $tag1 == "c" ]]; then color=$tagvalue1; fi
					if [[ $tag2 == "c" ]]; then color=$tagvalue2; fi
					if [[ $tag3 == "c" ]]; then color=$tagvalue3; fi
					if [[ $tag4 == "c" ]]; then color=$tagvalue4; fi
					if [[ $tag5 == "c" ]]; then color=$tagvalue5; fi
					if [[ $tag6 == "c" ]]; then color=$tagvalue6; fi
					if [[ $tag7 == "c" ]]; then color=$tagvalue7; fi
					if [[ $tag8 == "c" ]]; then color=$tagvalue8; fi


					regexsubcolor="[$]([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})"
					if [[ $COLOR =~ $regexsubcolor ]]; then
						COLOR="\"#${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}\""
						COLOR=${COLOR,,}
					else
						COLOR=""
					fi

					if [[ $color =~ $regexsubcolor ]]; then
						color="\"#${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}\""
						color=${color,,}
					else
						color=""
					fi

					# SIZE is the tag that affects all lines and size is the tag that affects only one line.
					SIZE=""
					size=""

					if [[ $tag1 == "S" ]]; then SIZE=$tagvalue1; fi
					if [[ $tag2 == "S" ]]; then SIZE=$tagvalue2; fi
					if [[ $tag3 == "S" ]]; then SIZE=$tagvalue3; fi
					if [[ $tag4 == "S" ]]; then SIZE=$tagvalue4; fi
					if [[ $tag5 == "S" ]]; then SIZE=$tagvalue5; fi
					if [[ $tag6 == "S" ]]; then SIZE=$tagvalue6; fi
					if [[ $tag7 == "S" ]]; then SIZE=$tagvalue7; fi
					if [[ $tag8 == "S" ]]; then SIZE=$tagvalue8; fi

					if [[ $tag1 == "s" ]]; then size=$tagvalue1; fi
					if [[ $tag2 == "s" ]]; then size=$tagvalue2; fi
					if [[ $tag3 == "s" ]]; then size=$tagvalue3; fi
					if [[ $tag4 == "s" ]]; then size=$tagvalue4; fi
					if [[ $tag5 == "s" ]]; then size=$tagvalue5; fi
					if [[ $tag6 == "s" ]]; then size=$tagvalue6; fi
					if [[ $tag7 == "s" ]]; then size=$tagvalue7; fi
					if [[ $tag8 == "s" ]]; then size=$tagvalue8; fi

					regexsubsize="([0-9]+)"
					if [[ $SIZE =~ $regexsubsize ]]; then
						SIZE="\"${BASH_REMATCH[1]}\""
					else
						SIZE=""
					fi

					if [[ $size =~ $regexsubsize ]]; then
						size="\"${BASH_REMATCH[1]}\""
					else
						size=""
					fi


					if [[ $COLOR ]] && [[ $SIZE ]] ; then
						justtext="<font color=$COLOR size=$SIZE>"$justtext
						arraysubs[$j]=$justtext
						suffix+="</font>"
						arraysubs[-1]+=$suffix
					elif [[ $COLOR ]]; then
						justtext="<font color=$COLOR>"$justtext
						arraysubs[$j]=$justtext
						suffix+="</font>"
						arraysubs[-1]+=$suffix
					elif [[ $SIZE ]] ; then
						justtext="<font size=$SIZE>"$justtext
						arraysubs[$j]=$justtext
						suffix+="</font>"
						arraysubs[-1]+=$suffix
					fi

					if [[ $color ]] && [[ $size ]] ; then
						justtext="<font color=$color size=$size>"$justtext"</font>"
						arraysubs[$j]=$justtext
					elif [[ $color ]]; then
						justtext="<font color=$color>"$justtext"</font>"
						arraysubs[$j]=$justtext
					elif [[ $size ]] ; then
						justtext="<font size=$size>"$justtext"</font>"
						arraysubs[$j]=$justtext
					fi
				fi
			done

			((linecounter++))
			arraysrt+=("$linecounter")
			arraysrt+=("$j1 --> $j2")
			arraysrt+=("${arraysubs[@]}")
			arraysrt+=("")
		fi
	done

	IFS=$old_IFS		# restore default field separator

	# Remove an empty line at the end
	if [[ ${arraysrt[-1]} =~ $regexemptyline ]]; then
		unset arraysrt[-1]
	fi

	# Write to the txt file the contents of array.
	if (( ${#arraysrt[@]} > 2 )); then
		printf "%s\r\n" "${arraysrt[@]}" | iconv -f utf-8 -t $encoding > "$newfilename"
	else
		echo "${red}Error: Not a valid sub file${normal}"; return 1
	fi
}


srt2_sub ()
{
	if [[ $srt2sub == "pal" ]]; then ratio=1; fps=25025; firstline="{1}{1}25.000"
	elif [[ $srt2sub == "film" ]]; then ratio=1; fps=24000; firstline="{1}{1}23.976"
	elif [[ $srt2sub == "ntsc" ]]; then ratio=1; fps=30000; firstline="{1}{1}29.970"
	elif [[ $srt2sub =~ ^[0-9]+$ ]]; then ratio=1; fps=$(($srt2sub * 1001)); firstline="{1}{1}$srt2sub.000"
	elif [[ $srt2sub =~ ^[0-9]+\.[0-9]*$ ]]; then fpsint=${srt2sub%.*}; fpsdecimal=${srt2sub##*.}; decimallength=${#fpsdecimal}; if (( $decimallength == 0 )); then ratio=1; trizero="000"; firstline="{1}{1}$srt2sub$trizero"; else ratio=1$(eval printf '0%.0s' {1..$decimallength}); firstline="{1}{1}$srt2sub"; fi; fps=$(($(echo $fpsint$fpsdecimal) * 1001))
	else echo -e "${red}Error: The srt2sub parameter only accepts the arguments pal, film, ntsc or a custom framerate.\n       Pal = 25, film = 23.976 and ntsc = 29.970${normal}"; exit 1
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# The encoding must be UTF-8
	IFS=$'\n'
	temparraysrt=( $(printf "%s\n" "${arraysrt[@]}" | iconv -f $encoding -t utf-8) )
	unset arraysrt
	arraysrt+=("${temparraysrt[@]}")
	unset temparraysrt

	# Check if the srt is OK
	newfilename="${inputfilename%.*}.sub"
	check_srt "$inputfilename" "Converting \"$inputfilename\" to \"$newfilename\"..."

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Remove non necessary lines
	newarraysrt=()
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		if [[ ${arraysrt[$(($i + 1))]} =~ $regextime ]] || [[ ${arraysrt[$(($i + 2))]} =~ $regextime ]]; then
			:
		else
			newarraysrt+=(${arraysrt[$i]})
		fi
	done


	# Associative array of color names converted to values used by the sub subtitles
	declare -A colornames

	colornames[indianred]="\$5C5CCD"
	colornames[lightcoral]="\$8080F0"
	colornames[salmon]="\$7280FA"
	colornames[darksalmon]="\$7A96E9"
	colornames[lightsalmon]="\$7AA0FF"
	colornames[crimson]="\$3C14DC"
	colornames[red]="\$0000FF"
	colornames[firebrick]="\$2222B2"
	colornames[darkred]="\$00008B"
	colornames[pink]="\$CBC0FF"
	colornames[lightpink]="\$C1B6FF"
	colornames[hotpink]="\$B469FF"
	colornames[deeppink]="\$9314FF"
	colornames[mediumvioletred]="\$8515C7"
	colornames[palevioletred]="\$9370DB"
	colornames[lightsalmon]="\$7AA0FF"
	colornames[coral]="\$507FFF"
	colornames[tomato]="\$4763FF"
	colornames[orangered]="\$0045FF"
	colornames[darkorange]="\$008CFF"
	colornames[orange]="\$00A5FF"
	colornames[gold]="\$00D7FF"
	colornames[yellow]="\$00FFFF"
	colornames[lightyellow]="\$E0FFFF"
	colornames[lemonchiffon]="\$CDFAFF"
	colornames[lightgoldenrodyellow]="\$D2FAFA"
	colornames[papayawhip]="\$D5EFFF"
	colornames[moccasin]="\$B5E4FF"
	colornames[peachpuff]="\$B9DAFF"
	colornames[palegoldenrod]="\$AAE8EE"
	colornames[khaki]="\$8CE6F0"
	colornames[darkkhaki]="\$6BB7BD"
	colornames[lavender]="\$FAE6E6"
	colornames[thistle]="\$D8BFD8"
	colornames[plum]="\$DDA0DD"
	colornames[violet]="\$EE82EE"
	colornames[orchid]="\$D670DA"
	colornames[fuchsia]="\$FF00FF"
	colornames[magenta]="\$FF00FF"
	colornames[mediumorchid]="\$D355BA"
	colornames[mediumpurple]="\$DB7093"
	colornames[rebeccapurple]="\$993366"
	colornames[blueviolet]="\$E22B8A"
	colornames[darkviolet]="\$D30094"
	colornames[darkorchid]="\$CC3299"
	colornames[darkmagenta]="\$8B008B"
	colornames[purple]="\$800080"
	colornames[indigo]="\$82004B"
	colornames[slateblue]="\$CD5A6A"
	colornames[darkslateblue]="\$8B3D48"
	colornames[mediumslateblue]="\$EE687B"
	colornames[greenyellow]="\$2FFFAD"
	colornames[chartreuse]="\$00FF7F"
	colornames[lawngreen]="\$00FC7C"
	colornames[lime]="\$00FF00"
	colornames[limegreen]="\$32CD32"
	colornames[palegreen]="\$98FB98"
	colornames[lightgreen]="\$90EE90"
	colornames[mediumspringgreen]="\$9AFA00"
	colornames[springgreen]="\$7FFF00"
	colornames[mediumseagreen]="\$71B33C"
	colornames[seagreen]="\$578B2E"
	colornames[forestgreen]="\$228B22"
	colornames[green]="\$008000"
	colornames[darkgreen]="\$006400"
	colornames[yellowgreen]="\$32CD9A"
	colornames[olivedrab]="\$238E6B"
	colornames[olive]="\$008080"
	colornames[darkolivegreen]="\$2F6B55"
	colornames[mediumaquamarine]="\$AACD66"
	colornames[darkseagreen]="\$8BBC8F"
	colornames[lightseagreen]="\$AAB220"
	colornames[darkcyan]="\$8B8B00"
	colornames[teal]="\$808000"
	colornames[aqua]="\$FFFF00"
	colornames[cyan]="\$FFFF00"
	colornames[lightcyan]="\$FFFFE0"
	colornames[paleturquoise]="\$EEEEAF"
	colornames[aquamarine]="\$D4FF7F"
	colornames[turquoise]="\$D0E040"
	colornames[mediumturquoise]="\$CCD148"
	colornames[darkturquoise]="\$D1CE00"
	colornames[cadetblue]="\$A09E5F"
	colornames[steelblue]="\$B48246"
	colornames[lightsteelblue]="\$DEC4B0"
	colornames[powderblue]="\$E6E0B0"
	colornames[lightblue]="\$E6D8AD"
	colornames[skyblue]="\$EBCE87"
	colornames[lightskyblue]="\$FACE87"
	colornames[deepskyblue]="\$FFBF00"
	colornames[dodgerblue]="\$FF901E"
	colornames[cornflowerblue]="\$ED9564"
	colornames[mediumslateblue]="\$EE687B"
	colornames[royalblue]="\$E16941"
	colornames[blue]="\$FF0000"
	colornames[mediumblue]="\$CD0000"
	colornames[darkblue]="\$8B0000"
	colornames[navy]="\$800000"
	colornames[midnightblue]="\$701919"
	colornames[cornsilk]="\$DCF8FF"
	colornames[blanchedalmond]="\$CDEBFF"
	colornames[bisque]="\$C4E4FF"
	colornames[navajowhite]="\$ADDEFF"
	colornames[wheat]="\$B3DEF5"
	colornames[burlywood]="\$87B8DE"
	colornames[tan]="\$8CB4D2"
	colornames[rosybrown]="\$8F8FBC"
	colornames[sandybrown]="\$60A4F4"
	colornames[goldenrod]="\$20A5DA"
	colornames[darkgoldenrod]="\$0B86B8"
	colornames[peru]="\$3F85CD"
	colornames[chocolate]="\$1E69D2"
	colornames[saddlebrown]="\$13458B"
	colornames[sienna]="\$2D52A0"
	colornames[brown]="\$2A2AA5"
	colornames[maroon]="\$000080"
	colornames[white]="\$FFFFFF"
	colornames[snow]="\$FAFAFF"
	colornames[honeydew]="\$F0FFF0"
	colornames[mintcream]="\$FAFFF5"
	colornames[azure]="\$FFFFF0"
	colornames[aliceblue]="\$FFF8F0"
	colornames[ghostwhite]="\$FFF8F8"
	colornames[whitesmoke]="\$F5F5F5"
	colornames[seashell]="\$EEF5FF"
	colornames[beige]="\$DCF5F5"
	colornames[oldlace]="\$E6F5FD"
	colornames[floralwhite]="\$F0FAFF"
	colornames[ivory]="\$F0FFFF"
	colornames[antiquewhite]="\$D7EBFA"
	colornames[linen]="\$E6F0FA"
	colornames[lavenderblush]="\$F5F0FF"
	colornames[mistyrose]="\$E1E4FF"
	colornames[gainsboro]="\$DCDCDC"
	colornames[lightgray]="\$D3D3D3"
	colornames[silver]="\$C0C0C0"
	colornames[darkgray]="\$A9A9A9"
	colornames[gray]="\$808080"
	colornames[dimgray]="\$696969"
	colornames[lightslategray]="\$998877"
	colornames[slategray]="\$908070"
	colornames[darkslategray]="\$4F4F2F"
	colornames[black]="\$000000"


	# Process the newarraysrt and at the same time create the arraysub
	IFS=$'\r'
	elementsub=()
	stringsub=()
	framesub=""
	arraysub=()
	arraysub+=($firstline)

	# Regular expression of srt color code
	regexsrtcolor="([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})"

	# Regular expressions for srt tags. They contain possible sub tags because inside the loop they co-exist
	regex_tag_i="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[bus]>)*(<font[^>]*>)*(<[bus]>)*)<i>(.*)</i>((</[bus]>)*(</font>)*(</[bus]>)*)$"
	regex_tag_b="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ius]>)*(<font[^>]*>)*(<[ius]>)*)<b>(.*)</b>((</[ius]>)*(</font>)*(</[ius]>)*)$"
	regex_tag_u="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibs]>)*(<font[^>]*>)*(<[ibs]>)*)<u>(.*)</u>((</[ibs]>)*(</font>)*(</[ibs]>)*)$"
	regex_tag_s="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibu]>)*(<font[^>]*>)*(<[ibu]>)*)<s>(.*)</s>((</[ibu]>)*(</font>)*(</[ibu]>)*)$"
	regex_tag_font_color="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*color[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*#?[[:blank:]]*([^> \"]*)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"
	regex_tag_font_size="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*size[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*([0-9]+)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"
	regex_tag_font_color_size="^(\|?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*color[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*#?[[:blank:]]*([^> \"]*)[[:blank:]]*\"?[[:blank:]]*size[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*([0-9]+)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"
	regex_tag_font_size_color="^(\|?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*size[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*([0-9]+)[[:blank:]]*\"?[[:blank:]]*color[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*#?[[:blank:]]*([^> \"]*)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"

	# Regular expressions for multiple tags that need to become one
	regex_merge_y_tags="^(\|?(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?)({y:([ibus])})?({y:([ibus])})?({y:([ibus])})?({y:([ibus])})?(.*)$"
	regex_merge_Y_tags="^((\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?)({Y:([ibus])})?({Y:([ibus])})?({Y:([ibus])})?({Y:([ibus])})?(.*)$"

	# Regular expression for removing the remaining srt tags
	regexremove="(.*)<[/]?([ibus]|font[^>]*)>(.*)"

	# This was put inside a function because it needs to run twice
	add_arraysub_element ()
	{
		for j in "${elementsub[@]}"; do
			# Search for "<font color ... size>" and "</font>", remove them from the text and add {C:$xxxxxx}{S:xx} if the subtitle is 1 line or {c:$xxxxxx}{s:xx} if it's more
			if [[ $j =~ $regex_tag_font_color_size ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
				srtcolor=${BASH_REMATCH[5]}
				size=${BASH_REMATCH[6]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

				for colorname in "${!colornames[@]}"; do
					if [[ $colorname == ${srtcolor,,} ]]; then
						colornamefound=$colorname
						break
					fi
				done

				if [[ $colornamefound ]]; then
					subcolor=${colornames[$colornamefound]}
					unset colornamefound
				elif [[ $srtcolor =~ $regexsrtcolor ]]; then
					subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
					subcolor=${subcolor^^}
				else
					subcolor=""
				fi

				if [[ $subcolor ]] && [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}{S:$size}$temptext2"
					else
						j="$temptext1{c:$subcolor}{s:$size}$temptext2"
					fi
				elif [[ $subcolor ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}$temptext2"
					else
						j="$temptext1{c:$subcolor}$temptext2"
					fi
				elif [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font size ... color>" and "</font>", remove them from the text and add {C:$xxxxxx}{S:xx} if the subtitle is 1 line or {c:$xxxxxx}{s:xx} if it's more
			if [[ $j =~ $regex_tag_font_size_color ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
				size=${BASH_REMATCH[5]}
				srtcolor=${BASH_REMATCH[6]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

				for colorname in "${!colornames[@]}"; do
					if [[ $colorname == ${srtcolor,,} ]]; then
						colornamefound=$colorname
						break
					fi
				done

				if [[ $colornamefound ]]; then
					subcolor=${colornames[$colornamefound]}
					unset colornamefound
				elif [[ $srtcolor =~ $regexsrtcolor ]]; then
					subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
					subcolor=${subcolor^^}
				else
					subcolor=""
				fi

				if [[ $subcolor ]] && [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}{S:$size}$temptext2"
					else
						j="$temptext1{c:$subcolor}{s:$size}$temptext2"
					fi
				elif [[ $subcolor ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}$temptext2"
					else
						j="$temptext1{c:$subcolor}$temptext2"
					fi
				elif [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font size>" and "</font>", remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
			# This runs below a second time - not a mistake
			if [[ $j =~ $regex_tag_font_size ]]; then
				size=${BASH_REMATCH[8]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

				if [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font color>" and "</font>", remove them from the text and add {C:$xxxxxx} if the subtitle is 1 line or {c:$xxxxxx} if it's more
			if [[ $j =~ $regex_tag_font_color ]]; then
				srtcolor=${BASH_REMATCH[8]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

				for colorname in "${!colornames[@]}"; do
					if [[ $colorname == ${srtcolor,,} ]]; then
						colornamefound=$colorname
						break
					fi
				done

				if [[ $colornamefound ]]; then
					subcolor=${colornames[$colornamefound]}
					unset colornamefound
				elif [[ $srtcolor =~ $regexsrtcolor ]]; then
					subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
					subcolor=${subcolor^^}
				else
					subcolor=""
				fi

				if [[ $subcolor ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}$temptext2"
					else
						j="$temptext1{c:$subcolor}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font size>" and "</font>", remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
			if [[ $j =~ $regex_tag_font_size ]]; then
				size=${BASH_REMATCH[8]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

				if [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<i>" and "</i>", remove them from the text and add {Y:i} if the subtitle is 1 line or {y:i} if it's more
			if [[ $j =~ $regex_tag_i ]] && ! [[ ${BASH_REMATCH[10]} == *"<i>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</i>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:i}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:i}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Search for "<b>" and "</b>", remove them from the text and add {Y:b} if the subtitle is 1 line or {y:b} if it's more
			if [[ $j =~ $regex_tag_b ]] && ! [[ ${BASH_REMATCH[10]} == *"<b>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</b>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:b}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:b}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Search for "<u>" and "</u>", remove them from the text and add {Y:u} if the subtitle is 1 line or {y:u} if it's more
			if [[ $j =~ $regex_tag_u ]] && ! [[ ${BASH_REMATCH[10]} == *"<u>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</u>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:u}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:u}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Search for "<s>" and "</s>", remove them from the text and add {Y:s} if the subtitle is 1 line or {y:s} if it's more
			if [[ $j =~ $regex_tag_s ]] && ! [[ ${BASH_REMATCH[10]} == *"<s>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</s>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:s}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:s}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Merge multiple y tags
			if [[ $j =~ $regex_merge_y_tags ]] && [[ ${BASH_REMATCH[4]} ]]; then
				j="${BASH_REMATCH[1]}{y:${BASH_REMATCH[5]}${BASH_REMATCH[7]}${BASH_REMATCH[9]}${BASH_REMATCH[11]}}${BASH_REMATCH[12]}"
			fi

			stringsub=${stringsub:+$stringsub}$j
		done

		# Search for "<s>" and "</s>" that enclose all lines, remove them from the text and add {Y:s}
		if [[ $stringsub =~ $regex_tag_s ]] && ! [[ ${BASH_REMATCH[10]} == *"<s>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</s>"* ]]; then
			stringsub="{Y:s}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<u>" and "</u>" that enclose all lines, remove them from the text and add {Y:u}
		if [[ $stringsub =~ $regex_tag_u ]] && ! [[ ${BASH_REMATCH[10]} == *"<u>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</u>"* ]]; then
			stringsub="{Y:u}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<b>" and "</b>" that enclose all lines, remove them from the text and add {Y:b}
		if [[ $stringsub =~ $regex_tag_b ]] && ! [[ ${BASH_REMATCH[10]} == *"<b>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</b>"* ]]; then
			stringsub="{Y:b}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<i>" and "</i>" that enclose all lines, remove them from the text and add {Y:i}
		if [[ $stringsub =~ $regex_tag_i ]] && ! [[ ${BASH_REMATCH[10]} == *"<i>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</i>"* ]]; then
			stringsub="{Y:i}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<font color ... size>" and "</font>" that enclose all lines, remove them from the text and add {C:$xxxxxx}{S:xx}
		if [[ $stringsub =~ $regex_tag_font_color_size ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
			srtcolor=${BASH_REMATCH[5]}
			size=${BASH_REMATCH[6]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

			for colorname in "${!colornames[@]}"; do
				if [[ $colorname == ${srtcolor,,} ]]; then
					colornamefound=$colorname
					break
				fi
			done

			if [[ $colornamefound ]]; then
				subcolor=${colornames[$colornamefound]}
				unset colornamefound
			elif [[ $srtcolor =~ $regexsrtcolor ]]; then
				subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
				subcolor=${subcolor^^}
			else
				subcolor=""
			fi

			if [[ $subcolor ]] && [[ $size ]]; then
				stringsub="{C:$subcolor}{S:$size}$temptext"
			elif [[ $subcolor ]]; then
				stringsub="{C:$subcolor}$temptext"
			elif [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font size ... color>" and "</font>" that enclose all lines, remove them from the text and add {C:$xxxxxx}{S:xx}
		if [[ $stringsub =~ $regex_tag_font_size_color ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
			size=${BASH_REMATCH[5]}
			srtcolor=${BASH_REMATCH[6]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

			for colorname in "${!colornames[@]}"; do
				if [[ $colorname == ${srtcolor,,} ]]; then
					colornamefound=$colorname
					break
				fi
			done

			if [[ $colornamefound ]]; then
				subcolor=${colornames[$colornamefound]}
				unset colornamefound
			elif [[ $srtcolor =~ $regexsrtcolor ]]; then
				subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
				subcolor=${subcolor^^}
			else
				subcolor=""
			fi

			if [[ $subcolor ]] && [[ $size ]]; then
				stringsub="{C:$subcolor}{S:$size}$temptext"
			elif [[ $subcolor ]]; then
				stringsub="{C:$subcolor}$temptext"
			elif [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font size>" and "</font>" that enclose all lines, remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
		# This runs below a second time - not a mistake
		if [[ $stringsub =~ $regex_tag_font_size ]]; then
			size=${BASH_REMATCH[8]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

			if [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font color>" and "</font>" that enclose all lines, remove them from the text and add {C:$xxxxxx}
		if [[ $stringsub =~ $regex_tag_font_color ]]; then
			srtcolor=${BASH_REMATCH[8]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}
			for colorname in "${!colornames[@]}"; do
				if [[ $colorname == ${srtcolor,,} ]]; then
					colornamefound=$colorname
					break
				fi
			done

			if [[ $colornamefound ]]; then
				subcolor=${colornames[$colornamefound]}
				unset colornamefound
			elif [[ $srtcolor =~ $regexsrtcolor ]]; then
				subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
				subcolor=${subcolor^^}
			else
				subcolor=""
			fi

			if [[ $subcolor ]]; then
				stringsub="{C:$subcolor}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font size>" and "</font>" that enclose all lines, remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
		if [[ $stringsub =~ $regex_tag_font_size ]]; then
			size=${BASH_REMATCH[8]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

			if [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Merge multiple Y tags
		if [[ $stringsub =~ $regex_merge_Y_tags ]] && [[ ${BASH_REMATCH[4]} ]]; then
			stringsub="${BASH_REMATCH[1]}{Y:${BASH_REMATCH[5]}${BASH_REMATCH[7]}${BASH_REMATCH[9]}${BASH_REMATCH[11]}}${BASH_REMATCH[12]}"
		fi

		# Remove the remaining srt tags
		if [[ $srt2sub_delsrttags ]]; then
			while [[ $stringsub =~ $regexremove ]]; do
				stringsub=${BASH_REMATCH[1]}${BASH_REMATCH[3]}
			done
		fi

		arraysub+=($framesub$stringsub)
	}

	for ((i=0; i<${#newarraysrt[@]}; i++)); do
		line=${newarraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			framesstart=$(($fps * $p1 / (($ratio * 1001000))))
			framesend=$(($fps * $p2 / (($ratio * 1001000))))

			add_arraysub_element

			unset elementsub
			stringsub=""

			framesub="{$framesstart}{$framesend}"

		elif [[ $elementsub ]]; then
			elementsub+=(\|$line)
		else
			elementsub+=($line)
		fi
	done

	# Run for the last subtitle
	add_arraysub_element

	# Write to the txt file the contents of array.
	if (( ${#arraysub[@]} >= 1 )); then
		printf "%s\r\n" "${arraysub[@]}" | iconv -f utf-8 -t $encoding > "$newfilename"
	else
		echo "${red}Error: Not a valid srt file${normal}"; return 1
	fi
	IFS=$old_IFS		# restore default field separator
}


join_srt ()
{
	# Check if the input file is a text
	check_file "$joinsrt"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Encoding of the join file
	encodingjoin=$encoding

	# Read text file to arraysrt
	read_srt "$joinsrt"

	# Check if the srt is OK
	check_srt "$joinsrt"

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Create arraysrtjoin from arraysrt
	arraysrtjoin+=("${arraysrt[@]}")


	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Encoding of the input file
	encodinginput=$encoding

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	check_srt "$inputfilename"

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi


	# Compare the encodings of the two files and convert to UTF-8 if necessary
	if [[ ${encodinginput,,} != ${encodingjoin,,} ]]; then
		IFS=$'\n'
		echo "${bold}${red}Warning: The two files have different encodings (${encodinginput^^} and ${encodingjoin^^}). The output file will be UTF-8.${normal}"
		if [[ ${encodinginput,,} != "utf-8" ]]; then
			temparraysrt=( $(printf "%s\n" "${arraysrt[@]}" | iconv -f $encodinginput -t utf-8) )
			unset arraysrt
			arraysrt+=("${temparraysrt[@]}")
			unset temparraysrt
		fi

		if [[ ${encodingjoin,,} != "utf-8" ]]; then
			temparraysrtjoin=( $(printf "%s\n" "${arraysrtjoin[@]}" | iconv -f $encodingjoin -t utf-8) )
			unset arraysrtjoin
			arraysrtjoin+=("${temparraysrtjoin[@]}")
			unset temparraysrtjoin
		fi
		IFS=$old_IFS
	fi


	# Add an empty line
	arraysrt+=("$cr")

	if ! [[ $jointime ]]; then
		echo "Joining \"$inputfilename\" with \"$joinsrt\"..."
		# Re-create the second subtitle array with new counter
		for ((i=0; i<=${#arraysrtjoin[@]}; i++)); do
			if [[ ${arraysrtjoin[$((i+1))]} =~ $regextime ]] && [[ ${arraysrtjoin[$i]} =~ $regexinteger ]]; then
				((subcounter++))
				arraysrtjoin[$i]="$subcounter$cr"
			fi
		done
	else
		# Calculate the time of the end time of the last subtitle of the first file
		for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h2b="${BASH_REMATCH[5]}"
				m2b="${BASH_REMATCH[6]}"
				s2b="${BASH_REMATCH[7]}"
				f2b="${BASH_REMATCH[8]}"

				break
			fi
		done

		# Time in milliseconds of the end time of the last subtitle of the first file
		p2b=$(($(($((10#$h2b)) * 3600000)) + $(($((10#$m2b)) * 60000)) + $(($((10#$s2b)) * 1000)) + $((10#$f2b))))


		# Calculate the time to shift the second subtitle
		regexjoin="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

		if [[ $jointime =~ $regexjoin ]]; then
			h="${BASH_REMATCH[1]}"
			m="${BASH_REMATCH[2]}"
			s="${BASH_REMATCH[3]}"
			f="${BASH_REMATCH[4]}"
		else
			echo "${red}Error: Syntax must be like 'hh:mm:ss,fff'${normal}"; exit 1
		fi

		if (( 10#$m >= 60 )) || (( 10#$s >= 60 )); then
			echo "${red}Error: Minutes and seconds must take a value of less than 60${normal}"; exit 1
		fi

		# Time in milliseconds of jointime
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))


		# Compare jointime with the end time of the last subtitle of the first file
		if ((p < p2b)); then
			echo "${red}Error: The duration of the first video (-J parameter) cannot be less than the first subtitle${normal}"; exit 1
		else
			echo "Joining \"$inputfilename\" with \"$joinsrt\"..."
		fi


		# Process the array of the second subtitle
		for ((i=0; i<=${#arraysrtjoin[@]}; i++)); do
			line=${arraysrtjoin[$i]}

			if [[ $line =~ $regextime ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				h2="${BASH_REMATCH[5]}"
				m2="${BASH_REMATCH[6]}"
				s2="${BASH_REMATCH[7]}"
				f2="${BASH_REMATCH[8]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
				p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

				p1_new=$(($p1 + $p))
				p2_new=$(($p2 + $p))

				j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
				j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

				line_new="$j1 --> $j2"

				arraysrtjoin[$i]=$line_new
			fi
		done

		# Re-create the second subtitle array with new counter
		for ((i=0; i<=${#arraysrtjoin[@]}; i++)); do
			if [[ ${arraysrtjoin[$((i+1))]} =~ $regextime ]] && [[ ${arraysrtjoin[$i]} =~ $regexinteger ]]; then
				((subcounter++))
				arraysrtjoin[$i]="$subcounter$cr"
			fi
		done
	fi


	# Add the second array to the first
	arraysrt+=("${arraysrtjoin[@]}")

	# Write to the txt file the contents of array.
	basename=${inputfilename%.*}
	j="_join.srt"
	printf "%s\n" "${arraysrt[@]}" > "$basename$j"
}


split_srt ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	check_srt "$inputfilename" "Splitting \"$inputfilename\"..."

	# Exit this function if the return code of check_srt is not 0
	if (($? != 0)); then
		return 1
	fi

	# Find the first and last subtitle time
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	# Time in milliseconds of the start time of the first subtitle
	p1a=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in milliseconds of the start time of the last subtitle
	p1b=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Initialize the variables
	splitsubfound=""
	split2counter=0
	arraysrtsplit1=()
	arraysrtsplit2=()

	# Calculate the time to split the subtitle
	regexsplit1="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"
	regexsplit2="^([+-]?)([0-9]+)$"
	regexsplit3="^([+-]?)([0-9]+)[:]([0-9]+)[t]$"
	regexsplit4="^([+-]?)([0-9]+)[:]([0-9]+)[n]$"

	if [[ $splitsrt =~ $regexsplit1 ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"

		if (( 10#$m >= 60 )) || (( 10#$s >= 60 )); then
			echo "${red}Error: Minutes and seconds must take a value of less than 60${normal}"; exit 1
		fi

		# Time in milliseconds to split the subtitle
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
		if [[ $sign == "-" ]]; then
			p=$(($p1b - $p))
		fi

		if ((p < p1a)); then
			echo "${red}Error: Split time cannot precede the start time of the first subtitle.${normal}"; return 1
		fi

		if ((p > p1b)); then
			echo "${red}Error: Split time cannot exceed the start time of the last subtitle.${normal}"; return 1
		fi

		# Find the subtitle to make the split
		for ((i=0; i<=${#arraysrt[@]}-1; i++)); do
			line=${arraysrt[$i]}
			nextline=${arraysrt[((i+1))]}

			if ! [[ $splitsubfound ]] && [[ $nextline =~ $regextime ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))

				if ((p1 >= p)); then
					splitsubfound="True"
				fi
			fi

			if ! [[ $splitsubfound ]]; then
				arraysrtsplit1[$i]=$line
			else
				arraysrtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	elif [[ $splitsrt =~ $regexsplit2 ]]; then
		sign="${BASH_REMATCH[1]}"
		splitinteger="${BASH_REMATCH[2]}"

		if [[ $sign == "-" ]]; then
			splitinteger=$(($subcounter - $splitinteger))
		fi

		# Check if the given integer is OK
		if ((splitinteger == 0)) || ((splitinteger > ((subcounter-1)))); then
			echo "${red}Error: The number of subtitles in the file are $subcounter. The given integer must be between or equal to 1 and $((subcounter-1)).${normal}"; return 1
		fi

		# Create the two new subtitle arrays
		for ((i=0; i<=${#arraysrt[@]}-1; i++)); do
			line=${arraysrt[$i]}
			nextline=${arraysrt[((i+1))]}

			if ! [[ $splitsubfound ]] && [[ $nextline =~ $regextime ]] && [[ $line =~ $regexinteger ]]; then
				if ((${BASH_REMATCH[1]} > splitinteger)); then
					splitsubfound="True"
				fi
			fi

			if ! [[ $splitsubfound ]]; then
				arraysrtsplit1[$i]=$line
			else
				arraysrtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	elif [[ $splitsrt =~ $regexsplit3 ]]; then
		sign="${BASH_REMATCH[1]}"
		numerator="${BASH_REMATCH[2]}"
		denominator="${BASH_REMATCH[3]}"

		if ((numerator == 0)) || ((denominator == 0)) || ((numerator >= denominator)); then
			echo "${red}Error: The numerator must be less than the denominator and both must not be 0.${normal}"; exit 1
		fi

		# Time in milliseconds to split the subtitle
		if [[ $sign == "-" ]]; then
			p=$((p1b*((denominator - numerator))/denominator))
		else
			p=$((p1b*numerator/denominator))
		fi

		if ((p < p1a)); then
			echo "${red}Error: Split time cannot precede the start time of the first subtitle.${normal}"; return 1
		fi

		# Find the subtitle to make the split
		for ((i=0; i<=${#arraysrt[@]}-1; i++)); do
			line=${arraysrt[$i]}
			nextline=${arraysrt[((i+1))]}

			if ! [[ $splitsubfound ]] && [[ $nextline =~ $regextime ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))

				if ((p1 >= p)); then
					splitsubfound="True"
				fi
			fi

			if ! [[ $splitsubfound ]]; then
				arraysrtsplit1[$i]=$line
			else
				arraysrtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	elif [[ $splitsrt =~ $regexsplit4 ]]; then
		sign="${BASH_REMATCH[1]}"
		numerator="${BASH_REMATCH[2]}"
		denominator="${BASH_REMATCH[3]}"

		if ((numerator == 0)) || ((denominator == 0)) || ((numerator >= denominator)); then
			echo "${red}Error: The numerator must be less than the denominator and both must not be 0.${normal}"; exit 1
		fi

		if [[ $sign == "-" ]]; then
			if ((subcounter%2 == 1)) && ((denominator/numerator == 2)); then
				splitinteger=$((1 + subcounter*((denominator - numerator))/denominator))
			else
				splitinteger=$((subcounter*((denominator - numerator))/denominator))
			fi
		else
			if ((subcounter%2 == 1)) && ((denominator/numerator == 2)); then
				splitinteger=$((1 + subcounter*numerator/denominator))
			else
				splitinteger=$((subcounter*numerator/denominator))
			fi
		fi

		# Check if the integer is OK
		if ((splitinteger == 0)); then
			echo "${red}Error: The fraction is too small. Exiting...${normal}"; exit 1
		fi

		# Create the two new subtitle arrays
		for ((i=0; i<=${#arraysrt[@]}-1; i++)); do
			line=${arraysrt[$i]}
			nextline=${arraysrt[((i+1))]}

			if ! [[ $splitsubfound ]] && [[ $nextline =~ $regextime ]] && [[ $line =~ $regexinteger ]]; then
				if ((${BASH_REMATCH[1]} > splitinteger)); then
					splitsubfound="True"
				fi
			fi

			if ! [[ $splitsubfound ]]; then
				arraysrtsplit1[$i]=$line
			else
				arraysrtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	else
		echo "${red}Error: Syntax must be like '(+/-)hh:mm:ss,fff' or '(+/-)SUB_INTEGER' or '(+/-)INTEGER:INTEGERt' or '(+/-)INTEGER:INTEGERn'${normal}"; exit 1
	fi


	# Re-create the second subtitle array with new counter
	subcounter=0
	for ((i=0; i<=${#arraysrtsplit2[@]}-1; i++)); do
		if [[ ${arraysrtsplit2[((i+1))]} =~ $regextime ]] && [[ ${arraysrtsplit2[$i]} =~ $regexinteger ]]; then
			((subcounter++))
			arraysrtsplit2[$i]="$subcounter$cr"
		fi
	done


	# Remove an empty line at the end
	if [[ ${arraysrtsplit1[-1]} =~ $regexemptyline ]]; then
		unset arraysrtsplit1[-1]
	fi


	# Write to the txt file the contents of the two arrays.
	basename=${inputfilename%.*}
	firstfile="_1.srt"
	secondfile="_2.srt"
	printf "%s\n" "${arraysrtsplit1[@]}" > "$basename$firstfile"
	printf "%s\n" "${arraysrtsplit2[@]}" > "$basename$secondfile"


	# If -X (splittime) exists:
	unset arraysrt
	if [[ $splittime ]]; then
		# Find the first subtitle time of the second file
		for ((i=0; i<=${#arraysrtsplit2[@]}; i++)); do
			line=${arraysrtsplit2[$i]}

			if [[ $line =~ $regextime ]]; then
				h1a="${BASH_REMATCH[1]}"
				m1a="${BASH_REMATCH[2]}"
				s1a="${BASH_REMATCH[3]}"
				f1a="${BASH_REMATCH[4]}"

				break
			fi
		done

	shifttime="-$h1a:$m1a:$s1a,$f1a"
	inputfilename="$basename$secondfile"
	shift_time
	unset shifttime
	fi
}


clean_trash ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the srt or sub is OK
	check_srt_and_sub "$inputfilename" "Cleaning \"$inputfilename\""

	# Exit this function if the return code of check_srt_and_sub is not 0
	if (($? != 0)); then
		return 1
	fi

	# If subeditrc exists...
	unset subeditrcfullpath
	if [[ -r "$HOME/.subeditrc" ]] && [[ $(grep -a -v "^#\|^$" "$HOME/.subeditrc") ]]; then
		subeditrcfullpath="$HOME/.subeditrc"
	elif [[ -r /etc/subeditrc ]] && [[ $(grep -a -v "^#\|^$" /etc/subeditrc) ]]; then
		subeditrcfullpath="/etc/subeditrc"
	fi

	if [[ $subeditrcfullpath ]]; then
		# Detect encoding of subeditrc
		encodingrc=$(file -b --mime-encoding "$subeditrcfullpath")
		if [[ $encodingrc == "utf-16"* ]] || [[ $encodingrc == *"ascii"* ]]; then
			:
		elif [[ -x /usr/bin/uchardet ]]; then
			cd "$(dirname "$subeditrcfullpath")"
			encodingrc=$(uchardet "$(basename "$subeditrcfullpath")" | tr -d '\r')
			cd - &> /dev/null
		fi

		# Read subeditrc to an array
		old_IFS=$IFS		# save the field separator
		IFS=$'\n'			# new field separator, the end of line
		subeditrcarray=()
		if ! [[ -x /usr/bin/uchardet ]]; then
			# Create subeditrcarray and a copy
			for line in "$(grep -a -v "^#\|^$" "$subeditrcfullpath")"; do
				subeditrcarray+=($line)
				subeditrcarraycopy+=($line)
			done

			# Re-create subeditrcarray if the encodings aren't the same
			if [[ ${encodingrc^^} != "UTF-8" ]]; then
				subeditrcarray=()
				for ((i=0; i<=${#subeditrcarraycopy[@]}-1; i++)); do
					iconvresult=""
					iconvresult=$(iconv -f $encodingrc -t utf-8 -c <<< ${subeditrcarraycopy[$i]})
					if (( ${#iconvresult} >= 2 )); then
						subeditrcarray+=($iconvresult)
					fi
				done
			fi
		else
			for line in "$(grep -a -v "^#\|^$" "$subeditrcfullpath" | iconv -f $encodingrc -t utf-8 -c)"; do
				subeditrcarray+=($line)
			done
		fi

		IFS=$old_IFS		# restore default field separator
	fi


	if [[ $subtitleis == "srt" ]]; then
		# Replace multiple whitespaces with one,
		# remove spaces between tags and text,
		# clean beginning and trailing spaces,
		# replace two single quotes with a double quote,
		# replace multiple quotes with one,
		# replace two single less-than/greater-that signs with double angle quotation mark,
		# remove spaces between double quotes and text (not in the middle of the sentence),
		# replace … with ...,
		# replace english characters with same-looking greek characters when necessary (x2),
		# remove spaces before punctuation marks (only for latin/greek text, when appropriate),
		# insert spaces after punctuation marks (only for latin/greek text, when appropriate),
		# remove unneeded periods,
		# fix missing '[',
		# capitalize the first letter after '.', '!' and '?',
		# capitalize the first letter, if it's greek, after ';',
		# replace 2 or more ',' with '...',
		# replace 2 or more '.' with '...',
		# replace ',...' and '...,' with '...',
		# replace various marks that are often used by ocr instead of greek tonos with single quote,
		# replace single quote + greek capital vowel with the same accented capital vowel,
		# replace double quotes with double angle quotation marks if the quoted text is greek,
		# replace '?' with the greek question mark ';', if it proceeds a greek letter
		# NOTE: Needs the system locale to be utf-8
		# If the file is not utf-8 then sed won't work OK so we convert to utf-8 first
		tempvar="$(cat "$inputfilename" | iconv -f $encoding -t utf-8 | sed -b -e s"/[[:blank:]]\{1,\}/ /g"\
		-e s"/\(<i>\|<b>\|<u>\|<s>\|<font[^>]*>\) / \1/g"\
		-e s"/\(<i>\|<b>\|<u>\|<s>\|<font[^>]*>\) / \1/g"\
		-e s"/\(<i>\|<b>\|<u>\|<s>\|<font[^>]*>\) / \1/g"\
		-e s"/\(<i>\|<b>\|<u>\|<s>\|<font[^>]*>\) / \1/g"\
		-e s"/\(<i>\|<b>\|<u>\|<s>\|<font[^>]*>\) / \1/g"\
		-e s"/\(<i>\|<b>\|<u>\|<s>\|<font[^>]*>\) / \1/g"\
		-e s"/ \(<\/i>\|<\/b>\|<\/u>\|<\/s>\|<\/font>\)/\1 /g"\
		-e s"/ \(<\/i>\|<\/b>\|<\/u>\|<\/s>\|<\/font>\)/\1 /g"\
		-e s"/ \(<\/i>\|<\/b>\|<\/u>\|<\/s>\|<\/font>\)/\1 /g"\
		-e s"/ \(<\/i>\|<\/b>\|<\/u>\|<\/s>\|<\/font>\)/\1 /g"\
		-e s"/ \(<\/i>\|<\/b>\|<\/u>\|<\/s>\|<\/font>\)/\1 /g"\
		-e s"/ \(<\/i>\|<\/b>\|<\/u>\|<\/s>\|<\/font>\)/\1 /g"\
		-e s"/()\|\[\]\|{}//g"\
		-e s"/ \{1,\}/ /g"\
		-e s"/^[ ]//g"\
		-e s"/[ ]\($cr\)$/\1/g"\
		-e s"/[ʼ’΄\`ˋ´ˊˈ`´′]/'/g"\
		-e s"/''/\"/g"\
		-e s"/\"\{2,\}/\"/g"\
		-e s"/<</«/g"\
		-e s"/>>/»/g"\
		-e s"/«\{2,\}/«/g"\
		-e s"/»\{2,\}/»/g"\
		-e s"/«»//g"\
		-e s"/  / /g"\
		-e s"/…/.../g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)A/\1Α/g"\
		-e s"/A\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)B/\1Β/g"\
		-e s"/B\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Β\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)E/\1Ε/g"\
		-e s"/E\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ε\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Z/\1Ζ/g"\
		-e s"/Z\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ζ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)H/\1Η/g"\
		-e s"/H\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)I/\1Ι/g"\
		-e s"/I\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)K/\1Κ/g"\
		-e s"/K\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)M/\1Μ/g"\
		-e s"/M\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Μ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)N/\1Ν/g"\
		-e s"/N\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)O/\1Ο/g"\
		-e s"/O\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)P/\1Ρ/g"\
		-e s"/P\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)T/\1Τ/g"\
		-e s"/T\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Τ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Y/\1Υ/g"\
		-e s"/Y\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)X/\1Χ/g"\
		-e s"/X\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)a/\1α/g"\
		-e s"/a\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)n/\1η/g"\
		-e s"/n\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)h/\1η/g"\
		-e s"/h\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)i/\1ι/g"\
		-e s"/i\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)k/\1κ/g"\
		-e s"/k\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)o/\1ο/g"\
		-e s"/o\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)v/\1ν/g"\
		-e s"/v\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)p/\1ρ/g"\
		-e s"/p\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)u/\1υ/g"\
		-e s"/u\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)x/\1χ/g"\
		-e s"/x\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)s/\1ς/g"\
		-e s"/s\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ς\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)H\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4Η\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)H\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Η\4 \7/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)H\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4Ο\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)O\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Ο\4 \7/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)n\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4η\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)n\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1η\4 \7/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)o\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4ο\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)o\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1ο\4 \7/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)A/\1Α/g"\
		-e s"/A\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)B/\1Β/g"\
		-e s"/B\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Β\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)E/\1Ε/g"\
		-e s"/E\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ε\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Z/\1Ζ/g"\
		-e s"/Z\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ζ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)H/\1Η/g"\
		-e s"/H\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)I/\1Ι/g"\
		-e s"/I\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)K/\1Κ/g"\
		-e s"/K\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)M/\1Μ/g"\
		-e s"/M\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Μ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)N/\1Ν/g"\
		-e s"/N\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)O/\1Ο/g"\
		-e s"/O\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)P/\1Ρ/g"\
		-e s"/P\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)T/\1Τ/g"\
		-e s"/T\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Τ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Y/\1Υ/g"\
		-e s"/Y\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)X/\1Χ/g"\
		-e s"/X\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)a/\1α/g"\
		-e s"/a\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)n/\1η/g"\
		-e s"/n\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)h/\1η/g"\
		-e s"/h\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)i/\1ι/g"\
		-e s"/i\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)k/\1κ/g"\
		-e s"/k\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)o/\1ο/g"\
		-e s"/o\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)v/\1ν/g"\
		-e s"/v\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)p/\1ρ/g"\
		-e s"/p\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)u/\1υ/g"\
		-e s"/u\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)x/\1χ/g"\
		-e s"/x\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)s/\1ς/g"\
		-e s"/s\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ς\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)H\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4Η\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)H\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Η\4 \7/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)H\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4Ο\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)O\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Ο\4 \7/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)n\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4η\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)n\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1η\4 \7/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\'\"»-]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)o\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) /\1 \4ο\7 /g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}\)o\(\(<[^>]*>\)\{0,\}[.,]\{0,\}\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.'\"«-]\{0,\}\(<[^>]*>\)\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1ο\4 \7/g"\
		-e s"/^\([.,:;\!¡·?¿_|@°%‰\\-]\{0,\}\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@°%‰\\-]\{0,\}\)\([\"]\)\(\(<[^>]*>\)\{0,\}\) /\1\3\4/g"\
		-e s"/[«]\(\(<[^>]*>\)\{0,\}\) /«\1/g"\
		-e s"/ \([.,:;\!¡·?¿_|@&°%‰\\-]\{0,\}\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\-]\{0,\}\)\([\"]\)\([.,:;\!¡·?¿_|@&°%‰\\-]\{0,\}\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@&°%‰\\-]\{0,\}\)\($cr\)$/\1\3\4\6/g"\
		-e s"/ \([.,:;\!¡·?¿_|@°%‰\\-]\{0,\}\(<[^>]*>\)\{0,\}[.,:;\!¡·?¿_|@°%‰\\-]\{0,\}\)[»]/\1»/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ][,:;\!¡·?¿]\{1,\}\)\.\([^.]\)/\1\2/g"\
		-e s"/^\(\(<[^>]*>\)\{0,\}\)[({]\{0,1\}\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ.,:;\!¡·?¿[:blank:]]\{1,\}\]\)/\1[\3/g"\
		-e s"/^\([-]\{0,\}\(<[^>]*>\)\{0,\}[-]\{0,\}\)\( \?\(\. \?\)\{2,\}\+\.\?\)\(\(<[^>]*>\)\{0,\}\)/\1...\5/g"\
		-e s"/\(\(<[^>]*>\)\{0,\}\)\( \?\(\. \?\)\{2,\}\+\.\?\)\(\(<[^>]*>\)\{0,\}\)\($cr\)$/\1...\5\7/g"\
		-e s"/ \.\./  ../g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[,:;\!¡·?¿|@\\})]\)/\1\3/g"\
		-e s"/ \(\(<[^>]*>\)\{0,\}]\)/\1/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}\.\(<[^>]*>\)\{0,\}\)\($cr\)$/\1\3\6/g"\
		-e s"/\([0-9]\) \([°%‰]\)/\1\2/g"\
		-e s"/°\([%‰]\)/\1/g"\
		-e s"/°\/\([oο]\)/%/g"\
		-e s"/°\/\([oο][oο]\)/‰/g"\
		-e s"/\([).,:;\!¡·?¿_@\\]\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[,:;\!¡·?¿@\\]\)/\1\3/g"\
		-e s"/\([).,:;\!¡·?¿_@\\]\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[,:;\!¡·?¿@\\]\)/\1\3/g"\
		-e s"/\([,:;\!¡·?¿_@\\]\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[.]\{1,\}\(<[^>]*>\)\{0,\}[ ,:;\!¡·?¿_|@\\{}]\{0,\}\(<[^>]*>\)\{0,\}[0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1\3/g"\
		-e s"/  / /g"\
		-e s"/^\(\(<[^>]*>\)\{0,\}[-]\{1,\}\)\(\(<[^>]*>\)\{0,\}\)/\1 \3/g"\
		-e s"/\([:]\(<[^>]*>\)\{0,\}\)\([A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1 \3/g"\
		-e s"/\([;\!¡·?¿°%‰»\\)}]\(<[^>]*>\)\{0,\}\)\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1 \3/g"\
		-e s"/\(]\(<[^>]*>\)\{0,\}\)\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1 \3/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}\)\([({«\[]\)/\1 \3/g"\
		-e s"/\([({\[]\(<[^>]*>\)\{0,\}\) \(\(<[^>]*>\)\{0,\}[0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1\3/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\(<[^>]*>\)\{0,\}\) \(<[^>]*>\)\{0,\}\.\(\(<[^>]*>\)\{0,\}[ ,:;\!¡·?¿_|@\\{}]\{0,\}\)\(\(<[^>]*>\)\{0,\}[0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1\3.\4 \6/g"\
		-e s"/\.\. /..  /g"\
		-e s"/\([^.]\.['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\( ['\"«»]\{0,\}\(<[^>]*>\)\{0,\}\-\)\{0,1\} ['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\U\6\E/g"\
		-e s"/\([^.]\.['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\(\(<[^>]*>\)\{0,\}\-\)['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\U\6\E/g"\
		-e s"/\(\!\|\?\)\(['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\( ['\"«»]\{0,\}\(<[^>]*>\)\{0,\}\-\)\{0,1\} ['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\2\6\U\8\E/g"\
		-e s"/\(;['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\( ['\"«»]\{0,\}\(<[^>]*>\)\{0,\}\-\)\{0,1\} \)\(['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\([α-ωά-ώΐΰ]\)/\1\5\U\7\E/g"\
		-e s"/  / /g"\
		-e s"/^\(['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\- ['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\U\4\E/g"\
		-e s"/,\{2,\}/.../g"\
		-e s"/\.\{2,\}/.../g"\
		-e s"/,\.\.\.\|\.\.\.,/.../g"\
		-e s"/'Ι'/Ϊ/g"\
		-e s"/'Υ'/Ϋ/g"\
		-e s"/'Α/Ά/g"\
		-e s"/'Ε/Έ/g"\
		-e s"/'Η/Ή/g"\
		-e s"/'Ι/Ί/g"\
		-e s"/'Ο/Ό/g"\
		-e s"/'Υ/Ύ/g"\
		-e s"/'Ω/Ώ/g"\
		-e s"/^\([(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\)\"\([(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}[0-9]\{0,\}[ ]\{0,1\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1«\3/g"\
		-e s"/ \([(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\)\"\([(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[(.,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}[0-9]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1«\3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ ]\{0,1\}[).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\)\"\([).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}$cr\{0,1\}\)$/\1»\3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\)\"\([).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\(<[^>]*>\)\{0,\}[).,:;\!¡·?¿_|@&°%‰*\\+-]\{0,\}\) /\1»\3 /g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ 0-9).,:;\!¡·?¿_|@&°%‰*\\»+-]\{0,\}\(<[^>]*>\)\{0,\}[ 0-9).,:;\!¡·?¿_|@&°%‰*\\»+-]\{0,\}\)?/\1;/g")"

		# read_srt needs the new encoding
		encoding_old=$encoding
		encoding="utf-8"

		# Read text file to arraysrt
		printf "%s\n" "$tempvar" > "$inputfilename"
		read_srt "$inputfilename"

		encoding=$encoding_old

		# We do not need this anymore
		unset tempvar

		IFS=$'\n'			# new field separator, the end of line

		# Remove subtitles with zero duration
		temp1arraysrt=()
		for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}
		nextline=${arraysrt[((i+1))]}
			if [[ $line =~ $regexinteger ]] && [[ $nextline =~ $regextime ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				h2="${BASH_REMATCH[5]}"
				m2="${BASH_REMATCH[6]}"
				s2="${BASH_REMATCH[7]}"
				f2="${BASH_REMATCH[8]}"

				# Check if time is invalid
				if (( 10#$m1 >= 60 )) || (( 10#$s1 >= 60 )) || (( 10#$m2 >= 60 )) || (( 10#$s2 >= 60 )); then
					echo "${bold}${red}Warning: Invalid time found: $line${normal}"
				fi

				if [[ $h1$m1$s1$f1 == $h2$m2$s2$f2 ]]; then
					foundzeroduration="True"
				else
					unset foundzeroduration
				fi
			fi

			if ! [[ $foundzeroduration ]]; then
				temp1arraysrt+=(${arraysrt[$i]})
			fi
		done

		# Remove subtitles that contain the key words in subeditrcarray
		if (( ${#subeditrcarray[@]} >= 1 )); then
			buffer=()
			temp2arraysrt=()

			# This was put inside a function because it needs to run twice
			keywordcleaning ()
			{
				if [[ $buffer ]] && ! [[ ${buffer[-1]} =~ $regextime ]]; then
					for ((j=-2; j>=-${#buffer[@]}; j--)); do
						if [[ ${buffer[$j]} =~ $regextime ]]; then
							break
						fi

						tempbuffer=${buffer[$j]}

						for ((k=0; k<=${#subeditrcarray[@]}-1; k++)); do
							temptrash="${subeditrcarray[$k]}"
							if [[ "${tempbuffer,,}" == *"${temptrash,,}"* ]]; then
								trashfound="True"
								break
							fi
						done
					done
					if ! [[ $trashfound ]]; then
						temp2arraysrt+=("${buffer[@]}")
					fi
				fi
			}

			for ((i=0; i<=${#temp1arraysrt[@]}; i++)); do
				if [[ ${temp1arraysrt[$i]} =~ $regexinteger ]] && [[ ${temp1arraysrt[((i+1))]} =~ $regextime ]]; then
					keywordcleaning
					unset trashfound
					buffer=()
				fi
				buffer+=(${temp1arraysrt[$i]})
			done

			# Everything inside previous for-loop must run one last time for the last subtitle
			keywordcleaning


			# Create temp1arraysrt from temp2arraysrt so that we can continue with the same array
			temp1arraysrt=()
			temp1arraysrt+=("${temp2arraysrt[@]}")
			unset temp2arraysrt
		fi

		# Re-create the subtitle array with new counter
		subcounter=0
		for ((i=0; i<=${#temp1arraysrt[@]}; i++)); do
			line=${temp1arraysrt[$i]}
			if [[ $line =~ $regexinteger ]] && [[ ${temp1arraysrt[((i+1))]} =~ $regextime ]]; then
				((subcounter++))
				temp1arraysrt[$i]="$subcounter$cr"
			fi
		done

		# Remove an empty line at the end
		if [[ ${temp1arraysrt[-1]} =~ $regexemptyline ]]; then
			unset temp1arraysrt[-1]
		fi


		IFS=$'\r'

		# Make the first letter uppercase if previous line ends with . ! ? ;
		# Make the first letter of the first subtitle uppercase
		# Split dialogs in one line
		temparray=()
		temparray+=( $(printf "%s" "${temp1arraysrt[@]}" | sed -e s"/\([^.]\.['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}$cr['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\3\U\5\E/g"\
		-e s"/\([\!?]['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}$cr['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\3\U\5\E/g"\
		-e s"/\(;['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}$cr['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\([α-ωά-ώΐΰ]\)/\1\3\U\5\E/g"\
		-e s"/\([^.]\.['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}$cr$cr[0-9]\{1,\}$cr[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$cr['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\3\U\5\E/g"\
		-e s"/\([\!?]['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}$cr$cr[0-9]\{1,\}$cr[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$cr['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\3\U\5\E/g"\
		-e s"/\(\;['\"«»]\{0,\}\(<[^>]*>\)\{0,\}['\"«»]\{0,\}$cr$cr[0-9]\{1,\}$cr[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$cr['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\([α-ωά-ώΐΰ]\)/\1\3\U\5\E/g"\
		-e s"/\(^1$cr[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$cr['\"«»]\{0,\}\)\(\(<[^>]*>\)\{0,\}['\"«»]\{0,\}\)\(.\)/\1\2\U\4\E/g"\
		-e s"/\(- [^.]*[.]\) \(- \)/\1$cr\2/g"\
		-e s"/\(- [^.]*[.]\) \(- \)/\1$cr\2/g"\
		-e s"/\(- [^\!]*[\!]\) \(- \)/\1$cr\2/g"\
		-e s"/\(- [^\!]*[\!]\) \(- \)/\1$cr\2/g"\
		-e s"/\(- [^?]*[?]\) \(- \)/\1$cr\2/g"\
		-e s"/\(- [^?]*[?]\) \(- \)/\1$cr\2/g"\
		-e s"/\(- [^;]*[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ 0-9]*[;]\) \(- \)/\1$cr\2/g"\
		-e s"/\(- [^;]*[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ 0-9]*[;]\) \(- \)/\1$cr\2/g") )

		IFS=$old_IFS		# restore default field separator

		printf "%s\r\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
	elif [[ $subtitleis == "sub" ]]; then
		# Replace multiple whitespaces with one,
		# remove spaces between tags and text,
		# clean beginning and trailing spaces,
		# replace two single quotes with a double quote,
		# replace multiple quotes with one,
		# replace two single less-than/greater-that signs with double angle quotation mark,
		# remove spaces between double quotes and text (not in the middle of the sentence),
		# replace … with ...,
		# replace english characters with same-looking greek characters when necessary (x2),
		# remove spaces before punctuation marks (only for latin/greek text, when appropriate),
		# insert spaces after punctuation marks (only for latin/greek text, when appropriate),
		# remove unneeded periods,
		# fix missing '[',
		# capitalize the first letter after '.', '!' and '?',
		# capitalize the first letter, if it's greek, after ';',
		# replace 2 or more ',' with '...',
		# replace 2 or more '.' with '...',
		# replace ',...' and '...,' with '...',
		# replace various marks that are often used by ocr instead of greek tonos with single quote,
		# replace single quote + greek capital vowel with the same accented capital vowel,
		# replace double quotes with double angle quotation marks if the quoted text is greek,
		# replace '?' with the greek question mark ';', if it proceeds a greek letter
		# NOTE: Needs the system locale to be utf-8
		# If the file is not utf-8 then sed won't work OK so we convert to utf-8 first
		tempvar="$(cat "$inputfilename" | iconv -f $encoding -t utf-8 | sed -b -e s"/[[:blank:]]\{1,\}/ /g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/\({[cCsSfFPyY]:[^}]*}\) / \1/g"\
		-e s"/()\|\[\]\|{}//g"\
		-e s"/ \{1,\}/ /g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\) \{0,1\}\(\({[cCsSfFPyY]:[^}]*}\)*\) \{0,1\}/\1\2/g"\
		-e s"/ |/|/g"\
		-e s"/| \{0,1\}\(\({[cCsSfFPyY]:[^}]*}\)*\) \{0,1\}/|\1/g"\
		-e s"/[ ]\($cr\)$/\1/g"\
		-e s"/[ʼ’΄\`ˋ´ˊˈ`´′]/'/g"\
		-e s"/''/\"/g"\
		-e s"/\"\{2,\}/\"/g"\
		-e s"/<</«/g"\
		-e s"/>>/»/g"\
		-e s"/«\{2,\}/«/g"\
		-e s"/»\{2,\}/»/g"\
		-e s"/«»//g"\
		-e s"/  / /g"\
		-e s"/…/.../g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)A/\1Α/g"\
		-e s"/A\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)B/\1Β/g"\
		-e s"/B\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Β\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)E/\1Ε/g"\
		-e s"/E\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ε\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Z/\1Ζ/g"\
		-e s"/Z\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ζ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)H/\1Η/g"\
		-e s"/H\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)I/\1Ι/g"\
		-e s"/I\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)K/\1Κ/g"\
		-e s"/K\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)M/\1Μ/g"\
		-e s"/M\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Μ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)N/\1Ν/g"\
		-e s"/N\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)O/\1Ο/g"\
		-e s"/O\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)P/\1Ρ/g"\
		-e s"/P\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)T/\1Τ/g"\
		-e s"/T\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Τ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Y/\1Υ/g"\
		-e s"/Y\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)X/\1Χ/g"\
		-e s"/X\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)a/\1α/g"\
		-e s"/a\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)n/\1η/g"\
		-e s"/n\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)h/\1η/g"\
		-e s"/h\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)i/\1ι/g"\
		-e s"/i\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)k/\1κ/g"\
		-e s"/k\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)o/\1ο/g"\
		-e s"/o\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)v/\1ν/g"\
		-e s"/v\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)p/\1ρ/g"\
		-e s"/p\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)u/\1υ/g"\
		-e s"/u\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)x/\1χ/g"\
		-e s"/x\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)s/\1ς/g"\
		-e s"/s\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ς\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)H\([.,]\{0,\}\) /\1 \2Η\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)H\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Η\2 \3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)H\([.,]\{0,\}\) /\1 \2Ο\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)O\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Ο\2 \3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)n\([.,]\{0,\}\) /\1 \2η\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)n\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1η\2 \3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)o\([.,]\{0,\}\) /\1 \2ο\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)o\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1ο\2 \3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)A/\1Α/g"\
		-e s"/A\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)B/\1Β/g"\
		-e s"/B\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Β\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)E/\1Ε/g"\
		-e s"/E\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ε\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Z/\1Ζ/g"\
		-e s"/Z\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ζ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)H/\1Η/g"\
		-e s"/H\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)I/\1Ι/g"\
		-e s"/I\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)K/\1Κ/g"\
		-e s"/K\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)M/\1Μ/g"\
		-e s"/M\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Μ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)N/\1Ν/g"\
		-e s"/N\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)O/\1Ο/g"\
		-e s"/O\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)P/\1Ρ/g"\
		-e s"/P\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)T/\1Τ/g"\
		-e s"/T\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Τ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)Y/\1Υ/g"\
		-e s"/Y\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)X/\1Χ/g"\
		-e s"/X\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)a/\1α/g"\
		-e s"/a\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/α\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)n/\1η/g"\
		-e s"/n\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)h/\1η/g"\
		-e s"/h\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/η\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)i/\1ι/g"\
		-e s"/i\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ι\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)k/\1κ/g"\
		-e s"/k\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/κ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)o/\1ο/g"\
		-e s"/o\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ο\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)v/\1ν/g"\
		-e s"/v\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ν\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)p/\1ρ/g"\
		-e s"/p\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ρ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)u/\1υ/g"\
		-e s"/u\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/υ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)x/\1χ/g"\
		-e s"/x\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/χ\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)s/\1ς/g"\
		-e s"/s\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ς\1/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)H\([.,]\{0,\}\) /\1 \2Η\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)H\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Η\2 \3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)H\([.,]\{0,\}\) /\1 \2Ο\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)O\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1Ο\2 \3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)n\([.,]\{0,\}\) /\1 \2η\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)n\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1η\2 \3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][.,:;\!¡·?¿_@&°%‰\\'\"»-]\{0,\}\) \([.'\"«-]\{0,\}\)o\([.,]\{0,\}\) /\1 \2ο\3 /g"\
		-e s"/ \([.'\"«-]\{0,\}\)o\([.,]\{0,\}\) \([.'\"«-]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/ \1ο\2 \3/g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*[.,:;\!¡·?¿_@°%‰\\-]\{0,\}\)\([\"]\) /\1\3/g"\
		-e s"/\(|\({[cCsSfFPyY]:[^}]*}\)*[.,:;\!¡·?¿_@°%‰*\\+-]\{0,\}\)\([\"]\) /\1\3/g"\
		-e s"/[«] /«/g"\
		-e s"/ \([\"]\)\([.,:;\!¡·?¿_@&°%‰\\]\{0,\}\)\($cr\)$/\1\2\3/g"\
		-e s"/ \([\"]\)\([.,:;\!¡·?¿_@&°%‰\\]\{0,\}\)|/\1\2|/g"\
		-e s"/ [»]/»/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ][,:;\!¡·?¿]\{1,\}\)\.\([^.]\)/\1\2/g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*\)[({]\{0,1\}\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ.,:;\!¡·?¿[:blank:]]\{1,\}\]\)/\1[\3/g"\
		-e s"/\(|\({[cCsSfFPyY]:[^}]*}\)*\)[({]\{0,1\}\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ.,:;\!¡·?¿[:blank:]]\{1,\}\]\)/\1[\3/g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*[-]\{0,\}\)\( \?\(\. \?\)\{2,\}\+\.\?\)/\1.../g"\
		-e s"/\(|\({[cCsSfFPyY]:[^}]*}\)*[-]\{0,\}\)\( \?\(\. \?\)\{2,\}\+\.\?\)/\1.../g"\
		-e s"/\( \?\(\. \?\)\{2,\}\+\.\?\)|/...|/g"\
		-e s"/\( \?\(\. \?\)\{2,\}\+\.\?\)\($cr\)$/...\3/g"\
		-e s"/ \.\./  ../g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\) \([,:;\!¡·?¿@\\})]\)/\1\2/g"\
		-e s"/ ]/]/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\) \.\($cr\)$/\1.\2/g"\
		-e s"/\([0-9]\) \([°%‰]\)/\1\2/g"\
		-e s"/°\([%‰]\)/\1/g"\
		-e s"/°\/\([oο]\)/%/g"\
		-e s"/°\/\([oο][oο]\)/‰/g"\
		-e s"/\([).,:;\!¡·?¿_@\\]\) \([,:;\!¡·?¿@\\]\)/\1\2/g"\
		-e s"/\([).,:;\!¡·?¿_@\\]\) \([,:;\!¡·?¿@\\]\)/\1\2/g"\
		-e s"/\([,:;\!¡·?¿_@\\]\) \([.]\{1,\}[ ,:;\!¡·?¿_@\\]\{0,\}[0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1\2/g"\
		-e s"/  / /g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*\"\{0,1\}[-]\{1,\}\)/\1 /g"\
		-e s"/\(|\({[cCsSfFPyY]:[^}]*}\)*\"\{0,1\}[-]\{1,\}\)/\1 /g"\
		-e s"/\([;\!¡·?¿°%‰»)}\\]\)\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1 \2/g"\
		-e s"/\]\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/] \1/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)\([({«\[]\)/\1 \2/g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\) \{0,1\}\(\({[cCsSfFPyY]:[^}]*}\)*\) \{0,1\}/\1\2/g"\
		-e s"/| \{0,1\}\(\({[cCsSfFPyY]:[^}]*}\)*\) \{0,1\}/|\1/g"\
		-e s"/\([({\[]\) \([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1\2/g"\
		-e s"/\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\) \.\([ ,:;\!¡·?¿_@\\]\{0,\}\)\([0-9A-Za-zΑ-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1.\2 \3/g"\
		-e s"/\.\. /..  /g"\
		-e s"/\([^.]\.['\"«»]\{0,\}\( ['\"«»]\{0,\}[-]\)\{0,1\} ['\"«»]\{0,\}\)\(.\)/\1\U\3\E/g"\
		-e s"/\([^.]\.['\"«»]\{0,\}\(['\"«»]\{0,\}[-]\)['\"«»]\{0,\}\)\(.\)/\1\U\3\E/g"\
		-e s"/\(\!\|\?\)\(['\"«»]\{0,\}\( ['\"«»]\{0,\}[-]\)\{0,1\} ['\"«»]\{0,\}\)\(.\)/\1\2\U\4\E/g"\
		-e s"/\(;['\"«»]\{0,\}\( ['\"«»]\{0,\}[-]\)\{0,1\} ['\"«»]\{0,\}\)\([α-ωά-ώΐΰ]\)/\1\U\3\E/g"\
		-e s"/  / /g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*\- \)\(.\)/\1\U\3\E/g"\
		-e s"/\(|\({[cCsSfFPyY]:[^}]*}\)*\- \)\(.\)/\1\U\3\E/g"\
		-e s"/,\{2,\}/.../g"\
		-e s"/\.\{2,\}/.../g"\
		-e s"/,\.\.\.\|\.\.\.,/.../g"\
		-e s"/'Ι'/Ϊ/g"\
		-e s"/'Υ'/Ϋ/g"\
		-e s"/'Α/Ά/g"\
		-e s"/'Ε/Έ/g"\
		-e s"/'Η/Ή/g"\
		-e s"/'Ι/Ί/g"\
		-e s"/'Ο/Ό/g"\
		-e s"/'Υ/Ύ/g"\
		-e s"/'Ω/Ώ/g"\
		-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)\{0,\}[(.,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}\)\"\([(.,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}[0-9]\{0,\}[ ]\{0,1\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1«\3/g"\
		-e s"/\([ |]\({[cCsSfFPyY]:[^}]*}\)\{0,\}[(.,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}\)\"\([(.,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}[0-9]\{0,\}[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/\1«\3/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ ]\{0,1\}[).,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}\)\"\([).,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}$cr\{0,\}\)\{0,1\}$/\1»\2/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][).,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}\)\"\([).,:;\!¡·?¿_@&°%‰*\\+-]\{0,\}[ |]\)/\1»\2/g"\
		-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ 0-9).,:;\!¡·?¿_|@&°%‰*\\»+-]\{0,\}\)?/\1;/g")"

		# read_sub needs the new encoding
		encoding_old=$encoding
		encoding="utf-8"

		# Read text file to arraysub
		printf "%s\n" "$tempvar" > "$inputfilename"
		read_sub "$inputfilename"

		encoding=$encoding_old

		# We do not need this anymore
		unset tempvar

		# Remove subtitles with zero duration
		temp1arraysub=()

		if [[ ${arraysub[0]} =~ $regexsub1 ]]; then
			temp1arraysub+=(${arraysub[0]})
		fi

		for ((i=0; i<=${#arraysub[@]}; i++)); do
			line=${arraysub[$i]}

			if [[ $line =~ $regexsub ]]; then
				framesstart="${BASH_REMATCH[1]}"
				framesend="${BASH_REMATCH[2]}"

				if ((framesstart != framesend)); then
					temp1arraysub+=("$line")
				fi
			fi
		done

		# Remove subtitles that contain the key words in subeditrcarray
		if (( ${#subeditrcarray[@]} >= 1 )); then
			temp2arraysub=()

			for ((i=0; i<=${#temp1arraysub[@]}-1; i++)); do
				unset trashfound
				line=${temp1arraysub[$i]}
				for ((k=0; k<=${#subeditrcarray[@]}-1; k++)); do
					temptrash="${subeditrcarray[$k]}"
					if [[ ${line,,} == *"${temptrash,,}"* ]]; then
						trashfound="True"
						break
					fi
				done
				if ! [[ $trashfound ]]; then
					temp2arraysub+=("$line")
				fi
			done

			# Create temp1arraysub from temp2arraysub so that we can continue with the same array
			temp1arraysub=()
			temp1arraysub+=("${temp2arraysub[@]}")
			unset temp2arraysub
		fi


		IFS=$'\r'

		# Make the first letter uppercase if previous line ends with . ! ? ;
		# Make the first letter of the first subtitle uppercase
		# Split dialogs in one line
		temparray=()
		temparray+=( $(printf "%s" "${temp1arraysub[@]}" | sed -e s"/\([^.]\.['\"«»]\{0,\}|\({[cCsSfFPyY]:[^}]*}\)*['\"«»]\{0,\}\)\(.\)/\1\U\3\E/g"\
		-e s"/\([\!?]['\"«»]\{0,\}|\({[cCsSfFPyY]:[^}]*}\)*['\"«»]\{0,\}\)\(.\)/\1\U\3\E/g"\
		-e s"/\(;['\"«»]\{0,\}|\({[cCsSfFPyY]:[^}]*}\)*['\"«»]\{0,\}\)\([α-ωά-ώΐΰ]\)/\1\U\3\E/g"\
		-e s"/\([^.]\.['\"«»]\{0,\}$cr{[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*['\"«»]\{0,\}\)\(.\)/\1\U\3\E/g"\
		-e s"/\([\!?]['\"«»]\{0,\}$cr{[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*['\"«»]\{0,\}\)\(.\)/\1\U\3\E/g"\
		-e s"/\(;['\"«»]\{0,\}$cr{[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*['\"«»]\{0,\}\)\([α-ωά-ώΐΰ]\)/\1\U\3\E/g"\
		-e s"/\(^\({1}{1}[0-9]\{1,\}\.\{0,1\}[0-9]\{0,\}$cr\)\{0,1\}{[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*['\"«»]\{0,\}\)\(.\)/\1\U\4\E/g"\
		-e s"/\(- [^.]*[.]\) \(- \)/\1|\2/g"\
		-e s"/\(- [^.]*[.]\) \(- \)/\1|\2/g"\
		-e s"/\(- [^\!]*[\!]\) \(- \)/\1|\2/g"\
		-e s"/\(- [^\!]*[\!]\) \(- \)/\1|\2/g"\
		-e s"/\(- [^?]*[?]\) \(- \)/\1|\2/g"\
		-e s"/\(- [^?]*[?]\) \(- \)/\1|\2/g"\
		-e s"/\(- [^;]*[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ 0-9]*[;]\) \(- \)/\1|\2/g"\
		-e s"/\(- [^;]*[Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ][ 0-9]*[;]\) \(- \)/\1|\2/g") )

		printf "%s\r\n" "${temparray[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
	fi
}


delete_HI ()
{
	# Get the symbols that enclose the text to be removed
	regexHIsymbols="^([(\[{?mM]+)$"

	if [[ $deletetextsforHI =~ $regexHIsymbols ]]; then
		HIsymbols="${BASH_REMATCH[1]}"
	else
		echo -e "${red}Error: Syntax must be like '([{?mM'. The single quotes are necessary.\nThe ([{? characters are the symbols that the text for the hearing impaired is enclosed by.\n'm' and 'M' are for music symbols.\nWith 'm' only the music symbols are deleted.\nWith 'M' the text that is enclosed by the music symbols is deleted too.\nUse only the symbol(s) that are needed for each subtitle file.${normal}"
		exit 1
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the srt or sub is OK
	check_srt_and_sub "$inputfilename" "Deleting text for hearing impaired in \"$inputfilename\""

	# Exit this function if the return code of check_srt_and_sub is not 0
	if (($? != 0)); then
		return 1
	fi


	IFS=$'\n'			# new field separator, the end of line

	if [[ $subtitleis == "srt" ]]; then
		# Read text file to arraysrt
		arraysrt=()
		for line in $(iconv -f $encoding -t utf-8 "$inputfilename" 2> /dev/null); do
			arraysrt+=($line)
		done

		# Delete the text that is enclosed by the defined symbols
		tempvar=$(printf "%s\n" "${arraysrt[@]}")

		if [[ $HIsymbols == *"("* ]]; then
			tempvar=$(echo "$tempvar" |
			sed -e '/^[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}([^)]*)[[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}\($cr\)\{0,1\}$/d'\
			-e s'/[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}([^)]*)[[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}/ /'g\
			-e s'/^[ ]\|[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"["* ]]; then
			tempvar=$(echo "$tempvar" |
			sed -e '/^[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}\[[^]]*\][[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}\($cr\)\{0,1\}$/d'\
			-e s'/[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}\[[^]]*\][[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}/ /'g\
			-e s'/^[ ]\|[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"{"* ]]; then
			tempvar=$(echo "$tempvar" |
			sed -e '/^[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}{[^}]*}[[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}\($cr\)\{0,1\}$/d'\
			-e s'/[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}{[^}]*}[[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}/ /'g\
			-e s'/^[ ]\|[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"?"* ]]; then
			tempvar=$(echo "$tempvar" |
			sed -e '/^[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}?[^?]*?[[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}\($cr\)\{0,1\}$/d'\
			-e s'/[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}?[^?]*?[[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}/ /'g\
			-e s'/^[ ]\|[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"M"* ]]; then
			tempvar=$(echo "$tempvar" |
			sed -e '/^[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}[¶♪♫][^¶♪♫]*[¶♪♫][[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}\($cr\)\{0,1\}$/d'\
			-e s'/[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}[¶♪♫][^¶♪♫]*[¶♪♫][[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}/ /'g\
			-e '/^[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}[#][^#]*[#][[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}\($cr\)\{0,1\}$/d'\
			-e s'/[[:blank:]]\{0,\}\(<[^>]*>\)\{0,\}[[:blank:]]\{0,\}[#][^#]*[#][[:blank:]]\{0,\}\(<\/[^>]*>\)\{0,\}[[:blank:]]\{0,\}/ /'g\
			-e s'/^[ ]\|[ ]\($cr\)\{0,1\}$//g')
		fi

		# Delete the music symbols
		if [[ $HIsymbols == *"m"* ]]; then
			tempvar=$(echo "$tempvar" | sed -e s'/[[:blank:]]\{0,\}[¶♪♫][[:blank:]]\{0,\}/ /'g\
			-e s'/^[ ]\|[ ]\($cr\)\{0,1\}$//g')
		fi

		# Export what we have so far to inputfilename
		printf "%s\n" "$tempvar" > "$inputfilename"

		unset tempvar

		# We must unset this so that read_srt fixes the line endings
		unset subtitleis

		# read_srt needs the new encoding
		encoding_old=$encoding
		encoding="utf-8"

		# read_srt removes any empty subtitles
		read_srt "$inputfilename"

		encoding=$encoding_old

		# We must set this again, or the basic_clean_up will run after this
		subtitleis="srt"

		# Export to inputfilename
		printf "%s\n" "${arraysrt[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
	elif [[ $subtitleis == "sub" ]]; then
		# Read text file to arraysub
		arraysub=()
		for line in $(iconv -f $encoding -t utf-8 "$inputfilename" 2> /dev/null); do
			arraysub+=($line)
		done

		# Delete the text that is enclosed by the defined symbols
		tempvar=$(printf "%s\n" "${arraysub[@]}")

		if [[ $HIsymbols == *"("* ]]; then
			tempvar=$(echo "$tempvar" | sed -e s'/[[:blank:]]\{0,\}([^)]*)[[:blank:]]\{0,\}/ /'g\
			-e s'/\({[0-9]\+}{[0-9]\+}\)\({[cCsSfFPyY]:[^}]*}\)* \(.*\)/\1\2\3/g'\
			-e s'/[ ]\{0,1\}[|][ ]\{0,1\}/|/g'\
			-e s'/[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"["* ]]; then
			tempvar=$(echo "$tempvar" | sed -e s'/[[:blank:]]\{0,\}\[[^]]*\][[:blank:]]\{0,\}/ /'g\
			-e s'/\({[0-9]\+}{[0-9]\+}\)\({[cCsSfFPyY]:[^}]*}\)* \(.*\)/\1\2\3/g'\
			-e s'/[ ]\{0,1\}[|][ ]\{0,1\}/|/g'\
			-e s'/[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"{"* ]]; then
			tempvar=$(echo "$tempvar" | sed -e s'/^{\([0-9]\+\)}{\([0-9]\+\)}/*(*\1*)**(*\2*)*/'g\
			-e s'/{\([cCsSfFPyY]:[^}]*\)}/*(*\1*)*/'g\
			-e s'/[[:blank:]]\{0,\}{[^}]*}[[:blank:]]\{0,\}/ /'g\
			-e s'/^\*(\*\([0-9]\+\)\*)\*\*(\*\([0-9]\+\)\*)\*/{\1}{\2}/'g\
			-e s'/\*(\*\([cCsSfFPyY]:[^*]*\)\*)\*/{\1}/'g\
			-e s'/\({[0-9]\+}{[0-9]\+}\)\({[cCsSfFPyY]:[^}]*}\)* \(.*\)/\1\2\3/g'\
			-e s'/[ ]\{0,1\}[|][ ]\{0,1\}/|/g'\
			-e s'/[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"?"* ]]; then
			tempvar=$(echo "$tempvar" | sed -e s'/[[:blank:]]\{0,\}?[^?]*?[[:blank:]]\{0,\}/ /'g\
			-e s'/\({[0-9]\+}{[0-9]\+}\)\({[cCsSfFPyY]:[^}]*}\)* \(.*\)/\1\2\3/g'\
			-e s'/[ ]\{0,1\}[|][ ]\{0,1\}/|/g'\
			-e s'/[ ]\($cr\)\{0,1\}$//g')
		fi

		if [[ $HIsymbols == *"M"* ]]; then
			tempvar=$(echo "$tempvar" | sed -e s'/[[:blank:]]\{0,\}[¶♪♫][^¶♪♫]*[¶♪♫][[:blank:]]\{0,\}/ /'g\
			-e s'/[[:blank:]]\{0,\}[#][^#]*[#][[:blank:]]\{0,\}/ /'g\
			-e s'/\({[0-9]\+}{[0-9]\+}\)\({[cCsSfFPyY]:[^}]*}\)* \(.*\)/\1\2\3/g'\
			-e s'/[ ]\{0,1\}[|][ ]\{0,1\}/|/g'\
			-e s'/[ ]\($cr\)\{0,1\}$//g')
		fi

		# Delete the music symbols
		if [[ $HIsymbols == *"m"* ]]; then
			tempvar=$(echo "$tempvar" | sed -e s'/[[:blank:]]\{0,\}[¶♪♫][[:blank:]]\{0,\}/ /'g\
			-e s'/\({[0-9]\+}{[0-9]\+}\)\({[cCsSfFPyY]:[^}]*}\)* \(.*\)/\1\2\3/g'\
			-e s'/[ ]\{0,1\}[|][ ]\{0,1\}/|/g'\
			-e s'/[ ]\($cr\)\{0,1\}$//g')
		fi

		# Export what we have so far to inputfilename
		printf "%s\n" "$tempvar" > "$inputfilename"

		unset tempvar

		# We must unset this so that read_sub fixes the line endings
		unset subtitleis

		# read_sub needs the new encoding
		encoding_old=$encoding
		encoding="utf-8"

		# read_sub removes any empty subtitles
		read_sub "$inputfilename"

		encoding=$encoding_old

		# We must set this again, or the basic_clean_up will run after this
		subtitleis="sub"

		# Export to inputfilename
		printf "%s\n" "${arraysub[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
	fi

	IFS=$old_IFS		# restore default field separator
}


fix_common_errors ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the srt or sub is OK
	check_srt_and_sub "$inputfilename" "Fix common errors of \"$inputfilename\""

	# Exit this function if the return code of check_srt_and_sub is not 0
	if (($? != 0)); then
		return 1
	fi

	# Fix zero and capital 'o' ripping mistakes,
	# fixes for "I" at the beginning of the word before lowercase vowels,
	# replace "II" with "ll" at the end of a lowercase word,
	# replace "II" with "ll" at the beginning of a lowercase word,
	# replace "I" with "l" in the middle of a lowercase word,
	# replace "I" with "l" at the end of a lowercase word,
	# replace "l" with "I" in the middle of an uppercase word,
	# replace "l" with "I" at the end of an uppercase word,
	# replace a single "l" with "I",
	# replace "l'm" with "I'm",
	# replace "i'm" with "I'm",
	# replace "I'II"/"you'II" etc. with "I'll"/"you'll" etc. (with an optional space before or after the apostrophe),
	# "I" after an uppercase letter at the beginning and before a lowercase letter is most likely an "l".
	tempvar="$(cat "$inputfilename" | iconv -f $encoding -t utf-8 | sed -b -e s"/\([0-9]\)\([.,]\{0,1\}\)[OΟ]/\1\20/g"\
	-e s"/[OΟ]\([.,]\{0,1\}\)\([0-9]\)/0\1\2/g"\
	-e s"/\([A-Za-z]\)0/\1O/g"\
	-e s"/\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)0/\1Ο/g"\
	-e s"/\b0\([A-Za-z]\)/O\1/g"\
	-e s"/\b0\([Α-ΩΆ-ΏΪΫα-ωά-ώΐΰ]\)/Ο\1/g"\
	-e s"/^\(\(<[^>]*>\)\{0,\}\)III/\1Ill/g"\
	-e s"/^\({[0-9]\{1,\}}{[0-9]\{1,\}}\({[cCsSfFPyY]:[^}]*}\)*[-]\{0,\}\)III/\1Ill/g"\
	-e s"/\(|\({[cCsSfFPyY]:[^}]*}\)*[-]\{0,\}\)III/\1Ill/g"\
	-e s"/\([.?\!-][ ]\{0,1\}\)III/\1Ill/g"\
	-e s"/\([a-z]\)II/\1ll/g"\
	-e s"/II\([a-z]\)/ll\1/g"\
	-e s"/\([a-z]\)I\([a-z]\)/\1l\2/g"\
	-e s"/\([a-z]\)I\b/\1l/g"\
	-e s"/\([A-Z]\)l\([A-Z]\)/\1I\2/g"\
	-e s"/\([A-Z]\{2,\}\)l\b/\1I/g"\
	-e s"/\bl\b/I/g"\
	-e s"/\bl'm\b/I'm/g"\
	-e s"/\bi'm\b/I'm/g"\
	-e s"/\([A-Za-z][ ]\{0,1\}'[ ]\{0,1\}\)II\b/\1ll/g"\
	-e s"/\b\([A-Z]\)I\([a-z]\)/\1l\2/g")"

	# Export tempvar to the input subtitle
	printf "%s\n" "$tempvar" | iconv -f utf-8 -t $encoding > "$inputfilename"

	# We do not need this anymore
	unset tempvar

	if [[ $subtitleis == "srt" ]]; then
		# Read text file to arraysrt
		read_srt "$inputfilename"

		IFS=$'\n'

		# We need the arraysrt to be in utf-8
		arraysrt=( $(printf "%s\n" "${arraysrt[@]}" | iconv -f $encoding -t utf-8) )

		IFS=$'\r'

		regexremove="(.*)<[/]?([ibus]|font[^>]*)>(.*)"
		buffer=()
		buffer_prev1=()
		buffer_prev2=()

		# These go into functions because they need to run more than one time
		update_prev2_values ()
		{
			# Update the values
			if [[ ${buffer_prev2[1]}$cr =~ $regextime ]]; then
				h__1="${BASH_REMATCH[1]}"
				m__1="${BASH_REMATCH[2]}"
				s__1="${BASH_REMATCH[3]}"
				f__1="${BASH_REMATCH[4]}"

				h__2="${BASH_REMATCH[5]}"
				m__2="${BASH_REMATCH[6]}"
				s__2="${BASH_REMATCH[7]}"
				f__2="${BASH_REMATCH[8]}"

				start_prev2=$(($(($((10#$h__1)) * 3600000)) + $(($((10#$m__1)) * 60000)) + $(($((10#$s__1)) * 1000)) + $((10#$f__1))))
				stop_prev2=$(($(($((10#$h__2)) * 3600000)) + $(($((10#$m__2)) * 60000)) + $(($((10#$s__2)) * 1000)) + $((10#$f__2))))

				((duration_prev2 = stop_prev2 - start_prev2))
				((ms_per_char_prev2 = duration_prev2 / characters_prev2))
			fi
		}

		update_prev1_values ()
		{
			# Update the values
			if [[ ${buffer_prev1[1]}$cr =~ $regextime ]]; then
				h_1="${BASH_REMATCH[1]}"
				m_1="${BASH_REMATCH[2]}"
				s_1="${BASH_REMATCH[3]}"
				f_1="${BASH_REMATCH[4]}"

				h_2="${BASH_REMATCH[5]}"
				m_2="${BASH_REMATCH[6]}"
				s_2="${BASH_REMATCH[7]}"
				f_2="${BASH_REMATCH[8]}"

				start_prev1=$(($(($((10#$h_1)) * 3600000)) + $(($((10#$m_1)) * 60000)) + $(($((10#$s_1)) * 1000)) + $((10#$f_1))))
				stop_prev1=$(($(($((10#$h_2)) * 3600000)) + $(($((10#$m_2)) * 60000)) + $(($((10#$s_2)) * 1000)) + $((10#$f_2))))

				((duration_prev1 = stop_prev1 - start_prev1))
				((ms_per_char_prev1 = duration_prev1 / characters_prev1))
			fi
		}

		update_current_sub_values ()
		{
			# Update the values
			if [[ ${buffer[1]}$cr =~ $regextime ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				h2="${BASH_REMATCH[5]}"
				m2="${BASH_REMATCH[6]}"
				s2="${BASH_REMATCH[7]}"
				f2="${BASH_REMATCH[8]}"

				start=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
				stop=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

				((duration = stop - start))
				((ms_per_char = duration / characters))
			fi
		}

		# This was put inside a function because it needs to run twice
		fix_srt_subtitles ()
		{
			if [[ $buffer ]]; then
				# buffer_prev2 contains the third to current subtitle
				# buffer_prev1 contains the second to current subtitle
				# buffer contains the current subtitle

				if [[ $buffer_prev2 ]]; then
					# Duration of buffer_prev2
					if [[ ${buffer_prev2[1]}$cr =~ $regextime ]]; then
						h__1="${BASH_REMATCH[1]}"
						m__1="${BASH_REMATCH[2]}"
						s__1="${BASH_REMATCH[3]}"
						f__1="${BASH_REMATCH[4]}"

						h__2="${BASH_REMATCH[5]}"
						m__2="${BASH_REMATCH[6]}"
						s__2="${BASH_REMATCH[7]}"
						f__2="${BASH_REMATCH[8]}"

						start_prev2=$(($(($((10#$h__1)) * 3600000)) + $(($((10#$m__1)) * 60000)) + $(($((10#$s__1)) * 1000)) + $((10#$f__1))))
						stop_prev2=$(($(($((10#$h__2)) * 3600000)) + $(($((10#$m__2)) * 60000)) + $(($((10#$s__2)) * 1000)) + $((10#$f__2))))

						((duration_prev2 = stop_prev2 - start_prev2))
					fi

					# Number of characters of buffer_prev2
					characters_prev2=0
					for ((j=2; j<=${#buffer_prev2[@]}; j++)); do
						line=${buffer_prev2[$j]}
						while [[ $line =~ $regexremove ]]; do
							line=${BASH_REMATCH[1]}${BASH_REMATCH[3]}
						done
						((characters_prev2 += ${#line}))
					done

					# Milliseconds per character of buffer_prev2
					((ms_per_char_prev2 = duration_prev2 / characters_prev2))
				fi

				if [[ $buffer_prev1 ]]; then
					# Duration of buffer_prev1
					if [[ ${buffer_prev1[1]}$cr =~ $regextime ]]; then
						h_1="${BASH_REMATCH[1]}"
						m_1="${BASH_REMATCH[2]}"
						s_1="${BASH_REMATCH[3]}"
						f_1="${BASH_REMATCH[4]}"

						h_2="${BASH_REMATCH[5]}"
						m_2="${BASH_REMATCH[6]}"
						s_2="${BASH_REMATCH[7]}"
						f_2="${BASH_REMATCH[8]}"

						start_prev1=$(($(($((10#$h_1)) * 3600000)) + $(($((10#$m_1)) * 60000)) + $(($((10#$s_1)) * 1000)) + $((10#$f_1))))
						stop_prev1=$(($(($((10#$h_2)) * 3600000)) + $(($((10#$m_2)) * 60000)) + $(($((10#$s_2)) * 1000)) + $((10#$f_2))))

						((duration_prev1 = stop_prev1 - start_prev1))
					fi

					# Number of characters of buffer_prev1
					characters_prev1=0
					for ((j=2; j<=${#buffer_prev1[@]}; j++)); do
						line=${buffer_prev1[$j]}
						while [[ $line =~ $regexremove ]]; do
							line=${BASH_REMATCH[1]}${BASH_REMATCH[3]}
						done
						((characters_prev1 += ${#line}))
					done

					# Milliseconds per character of buffer_prev1
					((ms_per_char_prev1 = duration_prev1 / characters_prev1))
				fi

				# Duration of buffer
				if [[ ${buffer[1]}$cr =~ $regextime ]]; then
					h1="${BASH_REMATCH[1]}"
					m1="${BASH_REMATCH[2]}"
					s1="${BASH_REMATCH[3]}"
					f1="${BASH_REMATCH[4]}"

					h2="${BASH_REMATCH[5]}"
					m2="${BASH_REMATCH[6]}"
					s2="${BASH_REMATCH[7]}"
					f2="${BASH_REMATCH[8]}"

					start=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
					stop=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

					((duration = stop - start))
				fi

				# Number of characters of buffer
				characters=0
				for ((j=2; j<=${#buffer[@]}; j++)); do
					line=${buffer[$j]}
					while [[ $line =~ $regexremove ]]; do
						line=${BASH_REMATCH[1]}${BASH_REMATCH[3]}
					done
					((characters += ${#line}))
				done

				# Milliseconds per character of buffer
				((ms_per_char = duration / characters))


				# Fix invalid times (duration < 0) for buffer_prev1
				if [[ $buffer_prev1 ]] && ((duration_prev1 < 0)); then
					if ((start_prev1 > start)) && ((stop_prev1 > stop_prev2)) && ((stop_prev1 < start + duration/2)); then			# invalid start, OK stop
						((new_duration_prev1 = 60 * characters_prev1))
						if ((new_duration_prev1 < 1000)); then
							new_duration_prev1=1000
						fi
						((new_start_prev1 = stop_prev1 - new_duration_prev1))
						if ((new_start_prev1 <= stop_prev2)); then
							((new_start_prev1 = stop_prev2 + 40))
						fi

						j_1=$(printf "%02d:%02d:%02d,%03d" $(($new_start_prev1 / 3600000)) $(($(($new_start_prev1 % 3600000)) / 60000)) $(($(($new_start_prev1 % 60000)) / 1000)) $(($new_start_prev1 % 1000)))
						j_2="$h_2:$m_2:$s_2,$f_2"
						line_new="$j_1 --> $j_2"
						buffer_prev1[1]=$line_new

						# Update the values
						update_prev1_values
					elif ((start_prev1 > stop_prev2 - duration_prev2/2)) && ((start_prev1 < start)) && ((stop_prev1 < stop_prev2)); then	# OK start, invalid stop
						((new_duration_prev1 = 60 * characters_prev1))
						if ((new_duration_prev1 < 1000)); then
							new_duration_prev1=1000
						fi
						((new_stop_prev1 = start_prev1 + new_duration_prev1))
						if ((new_stop_prev1 >= start)); then
							((new_stop_prev1 = start - 40))
						fi

						j_1="$h_1:$m_1:$s_1,$f_1"
						j_2=$(printf "%02d:%02d:%02d,%03d" $(($new_stop_prev1 / 3600000)) $(($(($new_stop_prev1 % 3600000)) / 60000)) $(($(($new_stop_prev1 % 60000)) / 1000)) $(($new_stop_prev1 % 1000)))
						line_new="$j_1 --> $j_2"
						buffer_prev1[1]=$line_new

						# Update the values
						update_prev1_values
					elif ((start_prev1 > stop_prev2)) && ((start_prev1 < start)) && ((stop_prev1 > stop_prev2)) && ((stop_prev1 < start)); then		# OK start, OK stop
						j_1="$h_2:$m_2:$s_2,$f_2"
						j_2="$h_1:$m_1:$s_1,$f_1"
						line_new="$j_1 --> $j_2"
						buffer_prev1[1]=$line_new

						# Update the values
						update_prev1_values
					else		# invalid start, invalid stop
						((new_start_prev1 = stop_prev2 + 40))
						((new_duration_prev1 = 60 * characters_prev1))
						if ((new_duration_prev1 < 1000)); then
							new_duration_prev1=1000
						fi
						((new_stop_prev1 = new_start_prev1 + new_duration_prev1))
						if ((new_stop_prev1 >= start)); then
							((new_stop_prev1 = start - 40))
						fi

						j_1=$(printf "%02d:%02d:%02d,%03d" $(($new_start_prev1 / 3600000)) $(($(($new_start_prev1 % 3600000)) / 60000)) $(($(($new_start_prev1 % 60000)) / 1000)) $(($new_start_prev1 % 1000)))
						j_2=$(printf "%02d:%02d:%02d,%03d" $(($new_stop_prev1 / 3600000)) $(($(($new_stop_prev1 % 3600000)) / 60000)) $(($(($new_stop_prev1 % 60000)) / 1000)) $(($new_stop_prev1 % 1000)))
						line_new="$j_1 --> $j_2"
						buffer_prev1[1]=$line_new

						# Update the values
						update_prev1_values
					fi
				fi


				# Fix subtitle out of place for buffer_prev1
				if [[ $buffer_prev1 ]] && ((start_prev1 > start)) && ((stop_prev1 > start)) && ((duration_prev1 > 0)) && ((stop_prev2 < start)); then
					((new_start_prev1 = stop_prev2 + 40))
					((new_duration_prev1 = 60 * characters_prev1))
					if ((new_duration_prev1 < 1000)); then
						new_duration_prev1=1000
					fi
					((new_stop_prev1 = new_start_prev1 + new_duration_prev1))
					if ((new_stop_prev1 >= start)); then
						((new_stop_prev1 = start - 40))
					fi

					if ((new_stop_prev1 - new_start_prev1 <= 500)); then
						((new_start_prev1 = stop_prev2 + 1))
						((new_stop_prev1 = start - 1))
					fi

					if ((new_stop_prev1 - new_start_prev1 > 124)); then
						j_1=$(printf "%02d:%02d:%02d,%03d" $(($new_start_prev1 / 3600000)) $(($(($new_start_prev1 % 3600000)) / 60000)) $(($(($new_start_prev1 % 60000)) / 1000)) $(($new_start_prev1 % 1000)))
						j_2=$(printf "%02d:%02d:%02d,%03d" $(($new_stop_prev1 / 3600000)) $(($(($new_stop_prev1 % 3600000)) / 60000)) $(($(($new_stop_prev1 % 60000)) / 1000)) $(($new_stop_prev1 % 1000)))
						line_new="$j_1 --> $j_2"
						buffer_prev1[1]=$line_new

						# Update the values
						update_prev1_values
					fi
				elif [[ $buffer_prev2 ]] && ((start_prev1 < start_prev2)) && ((stop_prev1 < start_prev2)) && ((duration_prev1 > 0)); then
					((new_start_prev1 = stop_prev2 + 40))
					((new_duration_prev1 = 60 * characters_prev1))
					if ((new_duration_prev1 < 1000)); then
						new_duration_prev1=1000
					fi
					((new_stop_prev1 = new_start_prev1 + new_duration_prev1))
					if ((new_stop_prev1 >= start)); then
						((new_stop_prev1 = start - 40))
					fi

					if ((new_stop_prev1 - new_start_prev1 <= 500)); then
						((new_start_prev1 = stop_prev2 + 1))
						((new_stop_prev1 = start - 1))
					fi

					if ((new_stop_prev1 - new_start_prev1 > 124)); then
						j_1=$(printf "%02d:%02d:%02d,%03d" $(($new_start_prev1 / 3600000)) $(($(($new_start_prev1 % 3600000)) / 60000)) $(($(($new_start_prev1 % 60000)) / 1000)) $(($new_start_prev1 % 1000)))
						j_2=$(printf "%02d:%02d:%02d,%03d" $(($new_stop_prev1 / 3600000)) $(($(($new_stop_prev1 % 3600000)) / 60000)) $(($(($new_stop_prev1 % 60000)) / 1000)) $(($new_stop_prev1 % 1000)))
						line_new="$j_1 --> $j_2"
						buffer_prev1[1]=$line_new

						# Update the values
						update_prev1_values
					fi
				fi


				# Fix too long duration for buffer_prev1. Max of 7 seconds or 0.15 seconds per character
				# If there is overlapping with the buffer_prev2 but not with buffer, fix start time
				# else, fix stop time
				if [[ $buffer_prev2 ]] && ((stop_prev2 >= start_prev1)) && ((stop_prev1 <= start)) && ((duration_prev1 > 7000)); then
					((new_duration_prev1 = 150 * characters_prev1))
					if ((new_duration_prev1 < 7000)); then
						new_duration_prev1=7000
					fi

					if ((new_duration_prev1 < duration_prev1)); then
						((new_start_prev1 = stop_prev1 - new_duration_prev1))

						j_1=$(printf "%02d:%02d:%02d,%03d" $(($new_start_prev1 / 3600000)) $(($(($new_start_prev1 % 3600000)) / 60000)) $(($(($new_start_prev1 % 60000)) / 1000)) $(($new_start_prev1 % 1000)))
						j_2="$h_2:$m_2:$s_2,$f_2"
						line_new="$j_1 --> $j_2"
						buffer_prev1[1]=$line_new

						# Update the values
						update_prev1_values
					fi
				elif [[ $buffer_prev1 ]] && ((duration_prev1 > 7000)); then
					((new_duration_prev1 = 150 * characters_prev1))
					if ((new_duration_prev1 < 7000)); then
						new_duration_prev1=7000
					fi

					if ((new_duration_prev1 < duration_prev1)); then
						((new_stop_prev1 = start_prev1 + new_duration_prev1))

						j_1="$h_1:$m_1:$s_1,$f_1"
						j_2=$(printf "%02d:%02d:%02d,%03d" $(($new_stop_prev1 / 3600000)) $(($(($new_stop_prev1 % 3600000)) / 60000)) $(($(($new_stop_prev1 % 60000)) / 1000)) $(($new_stop_prev1 % 1000)))
						line_new="$j_1 --> $j_2"
						buffer_prev1[1]=$line_new

						# Update the values
						update_prev1_values
					fi
				fi


				# Fix overlapping between buffer_prev2 and buffer_prev1. Leave 40 millisecond time between subtitles.
				if [[ $buffer_prev2 ]] && ((stop_prev2 >= start_prev1)); then
					((overlapping = stop_prev2 - start_prev1))
					((new_stop_prev2 = stop_prev2 - 20 - ms_per_char_prev2 * overlapping / ((ms_per_char_prev2 + ms_per_char_prev1)) ))
					((new_start_prev1 = new_stop_prev2 + 40))

					if ((stop_prev1 > new_start_prev1)); then
						j__1="$h__1:$m__1:$s__1,$f__1"
						j__2=$(printf "%02d:%02d:%02d,%03d" $(($new_stop_prev2 / 3600000)) $(($(($new_stop_prev2 % 3600000)) / 60000)) $(($(($new_stop_prev2 % 60000)) / 1000)) $(($new_stop_prev2 % 1000)))
						line_new="$j__1 --> $j__2"
						buffer_prev2[1]=$line_new

						j_1=$(printf "%02d:%02d:%02d,%03d" $(($new_start_prev1 / 3600000)) $(($(($new_start_prev1 % 3600000)) / 60000)) $(($(($new_start_prev1 % 60000)) / 1000)) $(($new_start_prev1 % 1000)))
						j_2="$h_2:$m_2:$s_2,$f_2"
						line_new="$j_1 --> $j_2"
						buffer_prev1[1]=$line_new

						# Update the values
						update_prev2_values
						update_prev1_values
					fi
				fi


				# Fix too short duration for buffer_prev1. 0.06 seconds per character.
				if [[ $buffer_prev1 ]] && ((ms_per_char_prev1 < 60)); then
					((new_duration_prev1 = 60 * characters_prev1))
					if ((new_duration_prev1 < 500)); then
						new_duration_prev1=500
					fi
					((new_stop_prev1 = stop_prev1 + new_duration_prev1 - duration_prev1))

					if ((new_stop_prev1 >= start)); then
						((new_stop_prev1 = start - 40))
					fi

					if ((new_stop_prev1 > stop_prev1)); then
						j_1="$h_1:$m_1:$s_1,$f_1"
						j_2=$(printf "%02d:%02d:%02d,%03d" $(($new_stop_prev1 / 3600000)) $(($(($new_stop_prev1 % 3600000)) / 60000)) $(($(($new_stop_prev1 % 60000)) / 1000)) $(($new_stop_prev1 % 1000)))
						line_new="$j_1 --> $j_2"
						buffer_prev1[1]=$line_new

						# Update the values
						update_prev1_values
					fi
				fi


				# Merge subtitles with more than 2 lines into 1 line, except dialogs and empty lines (work in the current subtitle)
				if ((${#buffer[@]} >= 6)) || ! [[ ${buffer[-1]} =~ $regexemptyline ]]; then
					tempbuffer=()
					tempbuffer+=("${buffer[0]}")
					tempbuffer+=("${buffer[1]}")
					tempbuffer+=("${buffer[2]}")

					for ((j=3; j<${#buffer[@]}; j++)); do
						if [[ ${buffer[$j]} =~ ^- ]] || [[ ${buffer[$j]} =~ $regexemptyline ]] || [[ ${tempbuffer[-1]} =~ $regexemptyline ]]; then
							tempbuffer+=("${buffer[$j]}")
						else
							tempbuffer[-1]="${tempbuffer[-1]} ${buffer[$j]}"
							((characters += 1))
						fi
					done

					unset buffer
					buffer=("${tempbuffer[@]}")
					unset tempbuffer
				fi

				# Split too long lines with over 48 characters (work in the current subtitle)
				if ((${#buffer[@]} <= 4)) && [[ ${buffer[2]} == *" "* ]] && ((characters > 48)); then
					characters_with_tags=${#buffer[2]}
					((tag_characters = characters_with_tags - characters))

					((linecenter = characters_with_tags / 2))

					bigline=${buffer[2]}

					# Number of characters of tags in the first half of the line
					halfline1=${bigline:0:linecenter}

					tag_characters_part1=0
					line=$halfline1
					while [[ $line =~ $regexremove ]]; do
						line=${BASH_REMATCH[1]}${BASH_REMATCH[3]}
					done
					((tag_characters_part1 = ${#halfline1} - ${#line}))

					# Number of characters of tags in the second half of the line
					((tag_characters_part2 = tag_characters - tag_characters_part1))
					((linecenter = 1 + linecenter + ((tag_characters_part1 - tag_characters_part2))/2))


					if [[ ${bigline:linecenter:1} == " " ]]; then
						splitspace=$linecenter
					else
						# Find the first space before center
						spacebefore=0
						for ((k=${#halfline1}-1; k>=0; k--)); do
							((spacebefore++))
							if [[ ${halfline1:k:1} == " " ]]; then
								break
							fi
						done

						# Find the first space after center
						halfline2=${bigline:$((linecenter - 1))}
						centertospace="${halfline2%% *}"
						((spaceafter = ${#centertospace}))

						if ((spaceafter <= spacebefore)); then
							((splitspace = linecenter + spaceafter - 1))
						else
							((splitspace = linecenter - spacebefore - 1))
						fi
					fi

					# Split the long line
					if [[ ${buffer[-1]} =~ $regexemptyline ]]; then
						unset buffer[-1]
					fi

					buffer[2]=${bigline:0:splitspace}
					buffer+=("${bigline:splitspace+1}")
					buffer+=("$nl")
				fi


				# Add buffer_prev2 to temp1arraysrt
				temp1arraysrt+=("${buffer_prev2[@]}")
			fi
		}

		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			if [[ ${arraysrt[$i]} =~ $regexinteger ]] && [[ ${arraysrt[((i+1))]} =~ $regextime ]]; then
				fix_srt_subtitles

				buffer_prev2=()
				buffer_prev2+=("${buffer_prev1[@]}")
				buffer_prev1=()
				buffer_prev1+=("${buffer[@]}")
				buffer=()
			fi
			buffer+=(${arraysrt[$i]})
		done

		# Everything inside the previous for-loop must run one last time for the last subtitle
		fix_srt_subtitles

		# Fix invalid times (duration < 0) for the last subtitle
		if ((duration < 0)); then
			if ((start > stop_prev1 - duration_prev1/2)) && ((stop < stop_prev1)); then		# OK start, invalid stop
				((new_duration = 60 * characters))
				if ((new_duration < 1000)); then
					new_duration=1000
				fi
				((new_stop = start + new_duration))

				j1="$h1:$m1:$s1,$f1"
				j2=$(printf "%02d:%02d:%02d,%03d" $(($new_stop / 3600000)) $(($(($new_stop % 3600000)) / 60000)) $(($(($new_stop % 60000)) / 1000)) $(($new_stop % 1000)))
				line_new="$j1 --> $j2"
				buffer[1]=$line_new

				# Update the values
				update_current_sub_values
			elif ((start > stop_prev1)) && ((stop > stop_prev1)); then		# OK start, OK stop
				j1="$h2:$m2:$s2,$f2"
				j2="$h1:$m1:$s1,$f1"
				line_new="$j1 --> $j2"
				buffer[1]=$line_new

				# Update the values
				update_current_sub_values
			fi
		fi

		# Fix subtitle out of place for the last subtitle
		if [[ $buffer_prev1 ]] && ((start < start_prev1)) && ((stop < start_prev1)) && ((duration > 0)); then
			((new_start = stop_prev1 + 40))
			((new_duration = 60 * characters))
			if ((new_duration < 1000)); then
				new_duration=1000
			fi
			((new_stop = new_start + new_duration))

			j1=$(printf "%02d:%02d:%02d,%03d" $(($new_start / 3600000)) $(($(($new_start % 3600000)) / 60000)) $(($(($new_start % 60000)) / 1000)) $(($new_start % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($new_stop / 3600000)) $(($(($new_stop % 3600000)) / 60000)) $(($(($new_stop % 60000)) / 1000)) $(($new_stop % 1000)))
			line_new="$j1 --> $j2"
			buffer[1]=$line_new

			# Update the values
			update_current_sub_values
		fi

		# Fix too long duration for the last subtitle
		if [[ $buffer_prev1 ]] && ((stop_prev1 >= start)) && ((duration > 7000)); then
			((new_duration = 150 * characters))
			if ((new_duration < 7000)); then
				new_duration=7000
			fi

			if ((new_duration < duration)); then
				((new_start = stop - new_duration))

				j1=$(printf "%02d:%02d:%02d,%03d" $(($new_start / 3600000)) $(($(($new_start % 3600000)) / 60000)) $(($(($new_start % 60000)) / 1000)) $(($new_start % 1000)))
				j2="$h2:$m2:$s2,$f2"
				line_new="$j1 --> $j2"
				buffer[1]=$line_new

				# Update the values
				update_current_sub_values
			fi
		elif ((duration > 7000)); then
			((new_duration = 150 * characters))
			if ((new_duration < 7000)); then
				new_duration=7000
			fi

			if ((new_duration < duration)); then
				((new_stop = start + new_duration))

				j1="$h1:$m1:$s1,$f1"
				j2=$(printf "%02d:%02d:%02d,%03d" $(($new_stop / 3600000)) $(($(($new_stop % 3600000)) / 60000)) $(($(($new_stop % 60000)) / 1000)) $(($new_stop % 1000)))
				line_new="$j1 --> $j2"
				buffer[1]=$line_new

				# Update the values
				update_current_sub_values
			fi
		fi

		# Fix overlapping between buffer_prev1 and the last subtitle
		if [[ $buffer_prev1 ]] && ((stop_prev1 >= start)); then
			((overlapping = stop_prev1 - start))
			((new_stop_prev1 = stop_prev1 - 20 - ms_per_char_prev1 * overlapping / ((ms_per_char_prev1 + ms_per_char)) ))
			((new_start = new_stop_prev1 + 40))

			if ((stop > new_start)); then
				j_1="$h_1:$m_1:$s_1,$f_1"
				j_2=$(printf "%02d:%02d:%02d,%03d" $(($new_stop_prev1 / 3600000)) $(($(($new_stop_prev1 % 3600000)) / 60000)) $(($(($new_stop_prev1 % 60000)) / 1000)) $(($new_stop_prev1 % 1000)))
				line_new="$j_1 --> $j_2"
				buffer_prev1[1]=$line_new

				j1=$(printf "%02d:%02d:%02d,%03d" $(($new_start / 3600000)) $(($(($new_start % 3600000)) / 60000)) $(($(($new_start % 60000)) / 1000)) $(($new_start % 1000)))
				j2="$h2:$m2:$s2,$f2"
				line_new="$j1 --> $j2"
				buffer[1]=$line_new

				# Update the values
				update_prev1_values
				update_current_sub_values
			fi
		fi

		# Fix too short duration for the last subtitle
		if ((ms_per_char < 60)); then
			((new_duration = 60 * characters))
			if ((new_duration < 500)); then
				new_duration=500
			fi
			((new_stop = stop + new_duration - duration))

			if ((new_stop > stop)); then
				j1="$h1:$m1:$s1,$f1"
				j2=$(printf "%02d:%02d:%02d,%03d" $(($new_stop / 3600000)) $(($(($new_stop % 3600000)) / 60000)) $(($(($new_stop % 60000)) / 1000)) $(($new_stop % 1000)))
				line_new="$j1 --> $j2"
				buffer[1]=$line_new
			fi
		fi

		temp1arraysrt+=("${buffer_prev1[@]}")
		temp1arraysrt+=("${buffer[@]}")

		IFS=$old_IFS		# restore default field separator

		# Write to the txt file the contents of array.
		printf "%s\r\n" "${temp1arraysrt[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
	elif [[ $subtitleis == "sub" ]]; then
		# Read text file to arraysub
		read_sub "$inputfilename"

		IFS=$'\r'

		regex_sub_remove1="(.*){[cCsSfFPyY]:[^}]*}(.*)"
		regex_sub_remove2="(.*)\|(.*)"
		unset sub_last
		unset sub_prev1
		unset sub_prev2

		# These go into functions because they need to run more than one time
		update_sub_prev2_values ()
		{
			# Update the values
			if ! [[ $sub_prev2 =~ $regexsub1 ]] && [[ $sub_prev2 =~ $regexsub ]]; then
				start_sub_prev2="${BASH_REMATCH[1]}"
				stop_sub_prev2="${BASH_REMATCH[2]}"
				((duration_sub_prev2 = 100 * ((stop_sub_prev2 - start_sub_prev2))))
				((frames_per_char_sub_prev2 = duration_sub_prev2 / characters_sub_prev2))
			fi
		}

		update_sub_prev1_values ()
		{
			# Update the values
			if ! [[ $sub_prev1 =~ $regexsub1 ]] && [[ $sub_prev1 =~ $regexsub ]]; then
				start_sub_prev1="${BASH_REMATCH[1]}"
				stop_sub_prev1="${BASH_REMATCH[2]}"
				((duration_sub_prev1 = 100 * ((stop_sub_prev1 - start_sub_prev1))))
				((frames_per_char_sub_prev1 = duration_sub_prev1 / characters_sub_prev1))
			fi
		}

		update_sub_last_values ()
		{
			# Update the values
			if ! [[ $sub_last =~ $regexsub1 ]] && [[ $sub_last =~ $regexsub ]]; then
				start_sub_last="${BASH_REMATCH[1]}"
				stop_sub_last="${BASH_REMATCH[2]}"
				((duration_sub_last = 100 * ((stop_sub_last - start_sub_last))))
				((frames_per_char_sub_last = duration_sub_last / characters_sub_last))
			fi
		}

		# This was put inside a function because it needs to run twice
		fix_sub_subtitles ()
		{
			if [[ $sub_last ]]; then
				# sub_prev2 contains the third to current subtitle
				# sub_prev1 contains the second to current subtitle
				# sub_last contains the current subtitle

				if ! [[ $sub_prev2 =~ $regexsub1 ]] && [[ $sub_prev2 =~ $regexsub ]]; then
					# Duration of sub_prev2 (in frames * 100)
					start_sub_prev2="${BASH_REMATCH[1]}"
					stop_sub_prev2="${BASH_REMATCH[2]}"
					((duration_sub_prev2 = 100 * ((stop_sub_prev2 - start_sub_prev2))))

					# Text of sub_prev2
					text_sub_prev_2="${BASH_REMATCH[3]}"

					# Number of characters of sub_prev2
					characters_sub_prev2=0
					line="${BASH_REMATCH[3]}"
					while [[ $line =~ $regex_sub_remove1 ]]; do
						line=${BASH_REMATCH[1]}${BASH_REMATCH[2]}
					done
					while [[ $line =~ $regex_sub_remove2 ]]; do
						line=${BASH_REMATCH[1]}${BASH_REMATCH[2]}
					done
					characters_sub_prev2=${#line}

					# Frames (* 100) per character of sub_prev2
					((frames_per_char_sub_prev2 = duration_sub_prev2 / characters_sub_prev2))
				fi

				if ! [[ $sub_prev1 =~ $regexsub1 ]] && [[ $sub_prev1 =~ $regexsub ]]; then
					# Duration of sub_prev1 (in frames * 100)
					start_sub_prev1="${BASH_REMATCH[1]}"
					stop_sub_prev1="${BASH_REMATCH[2]}"
					((duration_sub_prev1 = 100 * ((stop_sub_prev1 - start_sub_prev1))))

					# Text of sub_prev1
					text_sub_prev_1="${BASH_REMATCH[3]}"

					# Number of characters of sub_prev1
					characters_sub_prev1=0
					line="${BASH_REMATCH[3]}"
					while [[ $line =~ $regex_sub_remove1 ]]; do
						line=${BASH_REMATCH[1]}${BASH_REMATCH[2]}
					done
					while [[ $line =~ $regex_sub_remove2 ]]; do
						line=${BASH_REMATCH[1]}${BASH_REMATCH[2]}
					done
					characters_sub_prev1=${#line}

					# Frames (* 100) per character of sub_prev1
					((frames_per_char_sub_prev1 = duration_sub_prev1 / characters_sub_prev1))
				fi

				if ! [[ $sub_last =~ $regexsub1 ]] && [[ $sub_last =~ $regexsub ]]; then
					# Duration of sub_last (in frames * 100)
					start_sub_last="${BASH_REMATCH[1]}"
					stop_sub_last="${BASH_REMATCH[2]}"
					((duration_sub_last = 100 * ((stop_sub_last - start_sub_last))))

					# Text of sub_last
					text_sub_last="${BASH_REMATCH[3]}"

					# Number of characters of sub_last
					characters_sub_last=0
					line="${BASH_REMATCH[3]}"
					while [[ $line =~ $regex_sub_remove1 ]]; do
						line=${BASH_REMATCH[1]}${BASH_REMATCH[2]}
					done
					while [[ $line =~ $regex_sub_remove2 ]]; do
						line=${BASH_REMATCH[1]}${BASH_REMATCH[2]}
					done
					characters_sub_last=${#line}

					# Frames (* 100) per character of sub_last
					((frames_per_char_sub_last = duration_sub_last / characters_sub_last))
				fi


				# Fix invalid times (duration < 0) for sub_prev1
				if [[ $sub_prev1 ]] && ((duration_sub_prev1 < 0)); then
					if ((start_sub_prev1 > start_sub_last)) && ((stop_sub_prev1 > stop_sub_prev2)) && ((stop_sub_prev1 < start_sub_last + duration_sub_last/200)); then			# invalid start, OK stop
						((new_duration_sub_prev1 = 144 * characters_sub_prev1))		# duration is in frames * 100
						if ((new_duration_sub_prev1 < 2400)); then
							new_duration_sub_prev1=2400
						fi
						((new_start_sub_prev1 = stop_sub_prev1 - new_duration_sub_prev1/100))
						if ((new_start_sub_prev1 <= stop_sub_prev2)); then
							((new_start_sub_prev1 = stop_sub_prev2 + 1))
						fi

						sub_prev1="{$new_start_sub_prev1}{$stop_sub_prev1}$text_sub_prev_1"

						# Update the values
						update_sub_prev1_values
					elif ((start_sub_prev1 > stop_sub_prev2 - duration_sub_prev2/200)) && ((start_sub_prev1 < start_sub_last)) && ((stop_sub_prev1 < stop_sub_prev2)); then		# OK start, invalid stop
						((new_duration_sub_prev1 = 144 * characters_sub_prev1))		# duration is in frames * 100
						if ((new_duration_sub_prev1 < 2400)); then
							new_duration_sub_prev1=2400
						fi
						((new_stop_sub_prev1 = start_sub_prev1 + new_duration_sub_prev1/100))
						if ((new_stop_sub_prev1 >= start_sub_last)); then
							((new_stop_sub_prev1 = start_sub_last - 1))
						fi

						sub_prev1="{$start_sub_prev1}{$new_stop_sub_prev1}$text_sub_prev_1"

						# Update the values
						update_sub_prev1_values
					elif ((start_sub_prev1 > stop_sub_prev2)) && ((start_sub_prev1 < start_sub_last)) && ((stop_sub_prev1 > stop_sub_prev2)) && ((stop_sub_prev1 < start_sub_last)); then		# OK start, OK stop
						new_start_sub_prev1=$stop_sub_prev1
						new_stop_sub_prev1=$start_sub_prev1

						sub_prev1="{$new_start_sub_prev1}{$new_stop_sub_prev1}$text_sub_prev_1"

						# Update the values
						update_sub_prev1_values
					else		# invalid start, invalid stop
						((new_start_sub_prev1 = stop_sub_prev2 + 1))
						((new_duration_sub_prev1 = 144 * characters_sub_prev1))		# duration is in frames * 100
						if ((new_duration_sub_prev1 < 2400)); then
							new_duration_sub_prev1=2400
						fi
						((new_stop_sub_prev1 = new_start_sub_prev1 + new_duration_sub_prev1/100))
						if ((new_stop_sub_prev1 >= start_sub_last)); then
							((new_stop_sub_prev1 = start_sub_last - 1))
						fi

						sub_prev1="{$new_start_sub_prev1}{$new_stop_sub_prev1}$text_sub_prev_1"

						# Update the values
						update_sub_prev1_values
					fi
				fi


				# Fix subtitle out of place for sub_prev1
				if [[ $sub_prev1 ]] && ((start_sub_prev1 > start_sub_last)) && ((stop_sub_prev1 > start_sub_last)) && ((duration_sub_prev1 > 0)) && ((stop_sub_prev2 < start_sub_last)); then
					((new_start_sub_prev1 = stop_sub_prev2 + 1))
					((new_duration_sub_prev1 = 144 * characters_sub_prev1))		# 60 milliseconds * 24 frames / 1000 milliseconds = 1.44
					if ((new_duration_sub_prev1 < 2400)); then
						new_duration_sub_prev1=2400
					fi
					((new_stop_sub_prev1 = new_start_sub_prev1 + new_duration_sub_prev1/100))
					if ((new_stop_sub_prev1 >= start_sub_last)); then
						((new_stop_sub_prev1 = start_sub_last - 1))
					fi

					if ((new_stop_sub_prev1 - new_start_sub_prev1 > 2)); then
						sub_prev1="{$new_start_sub_prev1}{$new_stop_sub_prev1}$text_sub_prev_1"

						# Update the values
						update_sub_prev1_values
					fi
				elif [[ $sub_prev1 ]] && ((start_sub_prev1 < start_sub_prev2)) && ((stop_sub_prev1 < start_sub_prev2)) && ((duration_sub_prev1 > 0)); then
					((new_start_sub_prev1 = stop_sub_prev2 + 1))
					((new_duration_sub_prev1 = 144 * characters_sub_prev1))		# duration is in frames * 100
					if ((new_duration_sub_prev1 < 2400)); then
						new_duration_sub_prev1=2400
					fi
					((new_stop_sub_prev1 = new_start_sub_prev1 + new_duration_sub_prev1/100))
					if ((new_stop_sub_prev1 >= start_sub_last)); then
						((new_stop_sub_prev1 = start_sub_last - 1))
					fi

					if ((new_stop_sub_prev1 - new_start_sub_prev1 > 2)); then
						sub_prev1="{$new_start_sub_prev1}{$new_stop_sub_prev1}$text_sub_prev_1"

						# Update the values
						update_sub_prev1_values
					fi
				fi


				# Fix too long duration for sub_prev1. Max of 7 seconds or 0.15 seconds per character (assuming 24 frames per second)
				# If there is overlapping with the sub_prev2 but not with sub_last, fix start time
				# else, fix stop time
				if [[ $sub_prev2 ]] && ((stop_sub_prev2 >= start_sub_prev1)) && ((stop_sub_prev1 <= start_sub_last)) && ((duration_sub_prev1/100 > 168)); then
					((new_duration_sub_prev1 = 360 * characters_sub_prev1))		# 150 milliseconds * 24 frames / 1000 milliseconds = 3.6
					if ((new_duration_sub_prev1 < 16800)); then
						new_duration_sub_prev1=16800
					fi

					if ((new_duration_sub_prev1 < duration_sub_prev1)); then
						((new_start_sub_prev1 = stop_sub_prev1 - new_duration_sub_prev1/100))

						sub_prev1="{$new_start_sub_prev1}{$stop_sub_prev1}$text_sub_prev_1"

						# Update the values
						update_sub_prev1_values
					fi
				elif [[ $sub_prev1 ]] && ((duration_sub_prev1/100 > 168)); then
					((new_duration_sub_prev1 = 360 * characters_sub_prev1))		# 150 milliseconds * 24 frames / 1000 milliseconds = 3.6
					if ((new_duration_sub_prev1 < 16800)); then
						new_duration_sub_prev1=16800
					fi

					if ((new_duration_sub_prev1 < duration_sub_prev1)); then
						((new_stop_sub_prev1 = start_sub_prev1 + new_duration_sub_prev1/100))

						sub_prev1="{$start_sub_prev1}{$new_stop_sub_prev1}$text_sub_prev_1"

						# Update the values
						update_sub_prev1_values
					fi
				fi


				# Fix overlapping between sub_prev2 and sub_prev1. Leave 1 frame between subtitles.
				if [[ $sub_prev2 ]] && ((stop_sub_prev2 >= start_sub_prev1)); then
					((overlapping = stop_sub_prev2 - start_sub_prev1))
					((new_stop_sub_prev2 = stop_sub_prev2 - frames_per_char_sub_prev2 * overlapping / ((frames_per_char_sub_prev2 + frames_per_char_sub_prev1)) ))
					((new_start_sub_prev1 = new_stop_sub_prev2 + 1))

					if ((stop_sub_prev1 > new_start_sub_prev1)); then
						sub_prev2="{$start_sub_prev2}{$new_stop_sub_prev2}$text_sub_prev_2"
						sub_prev1="{$new_start_sub_prev1}{$stop_sub_prev1}$text_sub_prev_1"

						# Update the values
						update_sub_prev2_values
						update_sub_prev1_values
					fi
				fi


				# Fix too short duration for sub_prev1. 0.06 seconds (1.44 frames) per character.
				if [[ $sub_prev1 ]] && [[ $frames_per_char_sub_prev1 ]] && ((frames_per_char_sub_prev1 < 144)); then
					((new_duration_sub_prev1 = 144 * characters_sub_prev1))
					if ((new_duration_sub_prev1 < 1200)); then
						new_duration_sub_prev1=1200
					fi
					((new_stop_sub_prev1 = stop_sub_prev1 + new_duration_sub_prev1/100 - duration_sub_prev1/100))

					if ((new_stop_sub_prev1 >= start_sub_last)); then
						((new_stop_sub_prev1 = start_sub_last - 1))
					fi

					if ((new_stop_sub_prev1 > stop_sub_prev1)); then
						sub_prev1="{$start_sub_prev1}{$new_stop_sub_prev1}$text_sub_prev_1"

						# Update the values
						update_sub_prev1_values
					fi
				fi


				# Merge subtitles with more than 2 lines into 1 line, except dialogs, empty lines and lines that start with a lowercase tag (work in sub_last)
				IFS=$'|'
				read -r -a array_text_sub_last <<< "$text_sub_last"
				IFS=$'\r'

				if ((${#array_text_sub_last[@]} >= 3)); then
					unset text_sub_last
					text_sub_last="${array_text_sub_last[0]}"

					for ((j=1; j<${#array_text_sub_last[@]}; j++)); do
						if [[ ${array_text_sub_last[((j-1))]} =~ ^{[csfy]:[^}]*} ]] || [[ ${array_text_sub_last[$j]} =~ ^{[csfy]:[^}]*} ]] || [[ ${array_text_sub_last[$j]} =~ ^- ]] || [[ ${array_text_sub_last[$j]} =~ $regexemptyline ]] || [[ $text_sub_last == *"|" ]]; then
							text_sub_last="$text_sub_last|${array_text_sub_last[$j]}"
						else
							text_sub_last="$text_sub_last ${array_text_sub_last[$j]}"
							((characters_sub_last += 1))
						fi
					done

					sub_last="{$start_sub_last}{$stop_sub_last}$text_sub_last$cr"
				fi


				# Split too long lines with over 48 characters (work in sub_last)
				if ((${#array_text_sub_last[@]} == 1)) && [[ ${array_text_sub_last[0]} == *" "* ]] && ((characters_sub_last > 48)); then
					characters_with_tags=${#array_text_sub_last[0]}
					((tag_characters = characters_with_tags - characters_sub_last))

					((linecenter = 1 + characters_with_tags/2 + tag_characters/2))

					# Replace lowercase tags with uppercase tags. The tags must change to affect both lines
					if [[ ${array_text_sub_last[0]} =~ ^({[CSFPY]:[^}]*})*(({[csfy]:[^}]*})+) ]]; then
						unset tagsforreplace
						IFS=$'}'
						read -r -a array_tagsforreplace <<< "${BASH_REMATCH[2]}"
						IFS=$'\r'

						for ((m=0; m<${#array_tagsforreplace[@]}; m++)); do
							if [[ "${array_tagsforreplace[$m]}}" =~ ^({[csfy])(:[^}]*}) ]]; then
								tagsforreplace="$tagsforreplace${BASH_REMATCH[1]^^}${BASH_REMATCH[2]}"
							fi
						done

						if [[ ${array_text_sub_last[0]} =~ ^(({[CSFPY]:[^}]*})*)(({[csfy]:[^}]*})+)(.*) ]]; then
							bigline="${BASH_REMATCH[1]}$tagsforreplace${BASH_REMATCH[5]}"
						fi
					else
						bigline=${array_text_sub_last[0]}
					fi

					halfline1=${bigline:0:linecenter}

					if [[ ${bigline:linecenter:1} == " " ]]; then
						splitspace=$linecenter
					else
						# Find the first space before center
						spacebefore=0
						for ((k=${#halfline1}-1; k>=0; k--)); do
							((spacebefore++))
							if [[ ${halfline1:k:1} == " " ]]; then
								break
							fi
						done

						# Find the first space after center
						halfline2=${bigline:linecenter}
						centertospace="${halfline2%% *}"
						((spaceafter = ${#centertospace}))

						if ((spaceafter <= spacebefore)); then
							((splitspace = linecenter + spaceafter))
						else
							((splitspace = linecenter - spacebefore))
						fi
					fi

					# Split the long line
					text_sub_last="${bigline:0:splitspace}|${bigline:splitspace+1}"

					sub_last="{$start_sub_last}{$stop_sub_last}$text_sub_last$cr"
				fi

				unset array_text_sub_last

				# Add sub_prev2 to temp1arraysub
				temp1arraysub+=($sub_prev2)
			fi
		}

		for ((i=0; i<=${#arraysub[@]}; i++)); do
			if [[ ${arraysub[$i]} =~ $regexsub ]]; then

				fix_sub_subtitles

				sub_prev2=$sub_prev1
				sub_prev1=$sub_last
				sub_last=${arraysub[$i]}
			fi
		done

		# Everything inside the previous for-loop must run one last time for the last subtitle
		fix_sub_subtitles

		# Fix invalid times (duration < 0) for the last subtitle
		if ((duration_sub_last < 0)); then
			if ((start_sub_last > stop_sub_prev1 - duration_sub_prev1/200)) && ((stop_sub_last < stop_sub_prev1)); then		# OK start, invalid stop
				((new_duration_sub_last = 144 * characters_sub_last))		# duration is in frames * 100
				if ((new_duration_sub_last < 2400)); then
					new_duration_sub_last=2400
				fi
				((new_stop_sub_last = start_sub_last + new_duration_sub_last/100))

				sub_last="{$start_sub_last}{$new_stop_sub_last}$text_sub_last"

				# Update the values
				update_sub_last_values
			elif ((start_sub_last > stop_sub_prev1)) && ((stop_sub_last > stop_sub_prev1)); then		# OK start, OK stop
				new_start_sub_last=$stop_sub_last
				new_stop_sub_last=$start_sub_last

				sub_last="{$new_start_sub_last}{$new_stop_sub_last}$text_sub_last"

				# Update the values
				update_sub_last_values
			fi
		fi

		# Fix subtitle out of place for the last subtitle
		if [[ $sub_prev1 ]] && ((start_sub_last < start_sub_prev1)) && ((stop_sub_last < start_sub_prev1)) && ((duration_sub_last > 0)); then
			((new_start_sub_last = stop_sub_prev1 + 1))
			((new_duration_sub_last = 144 * characters_sub_last))		# duration is in frames * 100
			if ((new_duration_sub_last < 2400)); then
				new_duration_sub_last=2400
			fi
			((new_stop_sub_last = new_start_sub_last + new_duration_sub_last/100))

			if ((new_stop_sub_last - new_start_sub_last > 2)); then
				sub_last="{$new_start_sub_last}{$new_stop_sub_last}$text_sub_last"

				# Update the values
				update_sub_last_values
			fi
		fi

		# Fix too long duration for the last subtitle
		if [[ $sub_prev1 ]] && ((stop_sub_prev1 >= start_sub_last)) && ((duration_sub_last/100 > 168)); then
			((new_duration_sub_last = 360 * characters_sub_last))		# 150 milliseconds * 24 frames / 1000 milliseconds = 3.6
			if ((new_duration_sub_last < 16800)); then
				new_duration_sub_last=16800
			fi

			if ((new_duration_sub_last < duration_sub_last)); then
				((new_start_sub_last = stop_sub_last - new_duration_sub_last/100))

				sub_last="{$new_start_sub_last}{$stop_sub_last}$text_sub_last"

				# Update the values
				update_sub_last_values
			fi
		elif ((duration_sub_last/100 > 168)); then
			((new_duration_sub_last = 360 * characters_sub_last))		# 150 milliseconds * 24 frames / 1000 milliseconds = 3.6
			if ((new_duration_sub_last < 16800)); then
				new_duration_sub_last=16800
			fi

			if ((new_duration_sub_last < duration_sub_last)); then
				((new_stop_sub_last = start_sub_last + new_duration_sub_last/100))

				sub_last="{$start_sub_last}{$new_stop_sub_last}$text_sub_last"

				# Update the values
				update_sub_last_values
			fi
		fi

		# Fix overlapping between sub_prev1 and the last subtitle
		if [[ $sub_prev1 ]] && ((stop_sub_prev1 >= start_sub_last)); then
			((overlapping = stop_sub_prev1 - start_sub_last))
			((new_stop_sub_prev1 = stop_sub_prev1 - frames_per_char_sub_prev1 * overlapping / ((frames_per_char_sub_prev1 + frames_per_char_sub_last)) ))
			((new_start_sub_last = new_stop_sub_prev1 + 1))

			if ((stop_sub_last > new_start_sub_last)); then
				sub_prev1="{$start_sub_prev1}{$new_stop_sub_prev1}$text_sub_prev_1"
				sub_last="{$new_start_sub_last}{$stop_sub_last}$text_sub_last"

				# Update the values
				update_sub_prev1_values
				update_sub_last_values
			fi
		fi

		# Fix too short duration for the last subtitle
		if [[ $frames_per_char_sub_last ]] && ((frames_per_char_sub_last < 144)); then
			((new_duration_sub_last = 144 * characters_sub_last))
			if ((new_duration_sub_last < 1200)); then
				new_duration_sub_last=1200
			fi
			((new_stop_sub_last = stop_sub_last + new_duration_sub_last/100 - duration_sub_last/100))

			if ((new_stop_sub_last > stop_sub_last)); then
				sub_last="{$start_sub_last}{$new_stop_sub_last}$text_sub_last"

				# Update the values
				update_sub_last_values
			fi
		fi


		temp1arraysub+=($sub_prev1)
		temp1arraysub+=($sub_last)

		IFS=$old_IFS		# restore default field separator

		# Write to the txt file the contents of array.
		printf "%s\r\n" "${temp1arraysub[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
	fi
}


sort_subs ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Exit this function if the return code of check_file is not 0
	if (($? != 0)); then
		return 1
	fi

	# Check if the srt or sub is OK
	check_srt_and_sub "$inputfilename" "Sorting subtitles in \"$inputfilename\" by start time."

	# Exit this function if the return code of check_srt_and_sub is not 0
	if (($? != 0)); then
		return 1
	fi


	IFS=$'\n'			# new field separator, the end of line

	if [[ $subtitleis == "srt" ]]; then
		# Read text file to arraysrt
		read_srt "$inputfilename"

		# The encoding must be UTF-8
		IFS=$'\n'
		temparraysrt=( $(printf "%s\n" "${arraysrt[@]}" | iconv -f $encoding -t utf-8) )
		unset arraysrt
		arraysrt+=("${temparraysrt[@]}")
		unset temparraysrt

		# Remove non necessary lines and create newarraysrt
		newarraysrt=()
		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			if [[ ${arraysrt[$(($i + 1))]} =~ $regextime ]] || [[ ${arraysrt[$(($i + 2))]} =~ $regextime ]]; then
				:
			else
				newarraysrt+=(${arraysrt[$i]})
			fi
		done


		# Process the newarraysrt and at the same time create the arrayfakesub
		IFS=$'\r'
		elementsub=()
		stringsub=()
		timefakesub=""
		arrayfakesub=()
		for ((i=0; i<${#newarraysrt[@]}; i++)); do
			line=${newarraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				# Remove empty lines at the end
				while :; do
					if (( ${#elementsub[@]} > 0 )) && (( ${#elementsub[-1]} == 1 )); then
						unset elementsub[-1]
					else
						break
					fi
				done

				for k in "${elementsub[@]}"; do
					stringsub=${stringsub:+$stringsub}$k
				done
				arrayfakesub+=($timefakesub$stringsub)

				unset elementsub
				stringsub=""
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				h2="${BASH_REMATCH[5]}"
				m2="${BASH_REMATCH[6]}"
				s2="${BASH_REMATCH[7]}"
				f2="${BASH_REMATCH[8]}"

				starttime="$h1:$m1:$s1,$f1"
				endtime="$h2:$m2:$s2,$f2"

				timefakesub="{$starttime}{$endtime}"

			elif [[ $elementsub ]]; then
				elementsub+=(\|$line)
			else
				elementsub+=($line)
			fi
		done

		# Remove empty lines at the end
		while :; do
			if (( ${#elementsub[@]} > 0 )) && (( ${#elementsub[-1]} == 1 )); then
				unset elementsub[-1]
			else
				break
			fi
		done

		for k in "${elementsub[@]}"; do
			stringsub=${stringsub:+$stringsub}$k
		done
		arrayfakesub+=($timefakesub$stringsub)


		# Sort the array elements by the start time
		readarray -t arrayfakesub < <(printf '%s\0' "${arrayfakesub[@]}" | sort -V -z | xargs -0n1)


		# Process the arrayfakesub and at the same time create the arraysrt
		unset arraysrt
		arraysrt=()

		regexfakesub="^\{([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])\}\{([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])\}(.+)$"

		linecounter=0
		IFS=$'|'			# new field separator, the new line character in sub file

		for ((i=0; i<=${#arrayfakesub[@]}-1; i++)); do
			line=${arrayfakesub[$i]}

			if [[ $line =~ $regexfakesub ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				h2="${BASH_REMATCH[5]}"
				m2="${BASH_REMATCH[6]}"
				s2="${BASH_REMATCH[7]}"
				f2="${BASH_REMATCH[8]}"

				starttime="$h1:$m1:$s1,$f1"
				endtime="$h2:$m2:$s2,$f2"
				subs="${BASH_REMATCH[9]}"

				read -r -a arraysubs <<< "$subs"

				((linecounter++))
				arraysrt+=("$linecounter")
				arraysrt+=("$starttime --> $endtime")
				arraysrt+=("${arraysubs[@]}")
				arraysrt+=("")
			elif [[ $line == "" ]] || (( ${#line} == 1 )); then
				:
			else
				echo "Warning: There's something wrong with line $(($i+1)) in the sub file"
			fi
		done


		# Export to inputfilename
		printf "%s\n" "${arraysrt[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
	elif [[ $subtitleis == "sub" ]]; then
		# Read text file to arraysub
		read_sub "$inputfilename"

		# Sort the array elements by the start time
		readarray -t arraysub < <(printf '%s\0' "${arraysub[@]}" | sort -V -z | xargs -0n1)

		# Export to inputfilename
		printf "%s\n" "${arraysub[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename"
	fi
}


# Check for incompatible parameters
if [[ $inputfilename ]] && [[ $inputdirectory ]]; then
	echo "${red}Error: The parameters -i (Input file) and -d (Input directory) cannot be used together.${normal}"; exit 1
fi

if [[ $inputfilename ]] && [[ $synchronizedirectory ]]; then
	echo "${red}Error: The parameters -i (Input file) and -D (Synchronize with directory.) cannot be used together.${normal}"
	echo "Instead of \"Synchronize with directory\" you can use \"Synchronize with file\" (-y parameter)."; exit 1
fi


# Input file with wildcard support
master_function ()
{
	if [[ $shifttime ]]; then
		shift_time; (($? != 0)) && return 1
	fi

	if [[ $pal2ntsc ]] || [[ $ntsc2pal ]]; then
		change_fps; (($? != 0)) && return 1
	fi

	if [[ $adjustfirst ]]; then
		adjust_time; (($? != 0)) && return 1
	fi

	if [[ $adjustonlyfirst ]] || [[ $adjustonlylast ]]; then
		adjust_time_v2; (($? != 0)) && return 1
	fi

	if [[ $synchronizefile ]]; then
		synchronize_with_file; (($? != 0)) && return 1
	fi

	if [[ $findci ]] || [[ $findcs ]]; then
		find_text; (($? != 0)) && return 1
	fi

	if [[ $replace1 ]] || [[ $replace3 ]]; then
		replace_text; (($? != 0)) && return 1
	fi

	if [[ $sub2srt ]]; then
		sub2_srt; (($? != 0)) && return 1
	elif [[ $srt2sub ]]; then
		srt2_sub; (($? != 0)) && return 1
	fi

	if [[ $joinsrt ]]; then
		join_srt; (($? != 0)) && return 1
	fi

	if [[ $splitsrt ]]; then
		split_srt; (($? != 0)) && return 1
	fi

	if [[ $cleantrash ]]; then
		clean_trash; (($? != 0)) && return 1
	fi

	if [[ $deletetextsforHI ]]; then
		delete_HI; (($? != 0)) && return 1
	fi

	if [[ $fixerrors ]]; then
		fix_common_errors; (($? != 0)) && return 1
	fi

	if [[ $sortsubs ]]; then
		sort_subs; (($? != 0)) && return 1
	fi

	if ! [[ $srtok ]] && ! [[ $subok ]] && ! [[ $subtitleis ]]; then
		basic_clean_up; (($? != 0)) && return 1
	fi
}

if [[ $inputfilename ]]; then
	# Set globbing to case insensitive
	shopt -s nocaseglob

	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	# Capture the output of ls to an array
	filesarray=( $(ls $inputfilename -p -d 2> /dev/null | grep -v /) )

	IFS=$old_IFS		# restore default field separator

	# Restore globbing to case sensitive
	shopt -u nocaseglob

	if ((${#filesarray[@]} == 0)); then
		echo "${red}Error: No file found.${normal}"; exit 1
	elif ((${#filesarray[@]} == 1)); then
		master_function

		# Exit if the return code of anything in the master_function is not 0
		if (($? != 0)); then
			exit 1
		else
			exit 0
		fi
	else
		numberofsrt=$(printf "%s\n" "${filesarray[@]}" | grep -i "\.srt$" -c)
		numberofsub=$(printf "%s\n" "${filesarray[@]}" | grep -i "\.sub$" -c)
		echo "$numberofsrt .srt & $numberofsub .sub file(s) found"
		((numberofother = ${#filesarray[@]} - $numberofsrt - $numberofsub))
		if ((numberofother > 0)); then
			echo "$numberofother other file(s) were also found. These will be checked too and processed if they are subtitles."
		fi

		batchcounter=0
		numberofsubtitles=${#filesarray[@]}
		numberofsubtitleslength=${#numberofsubtitles}
		for inputfilename in "${filesarray[@]}"; do
			((batchcounter++))
			batchcounterlength=${#batchcounter}
			spaceslength=$((numberofsubtitleslength-batchcounterlength))
			case "$spaceslength" in
				0) precedingspaces="" ;;
				1) precedingspaces=" " ;;
				2) precedingspaces="  " ;;
				3) precedingspaces="   " ;;
				?) precedingspaces=$(eval printf "\ %.0s" {1..$spaceslength}) ;;
			esac
			printf "${bold}${green}[$precedingspaces$batchcounter/${#filesarray[@]}]${normal} "

			master_function
		done
		exit 0
	fi
fi


# Input directory with wildcard support
if [[ $inputdirectory ]]; then
	# Set globbing to case insensitive
	shopt -s nocaseglob

	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	# Check if directory/ies exist
	if ! [[ $(ls -p -d $inputdirectory 2> /dev/null | grep /) ]]; then
		echo "${red}Error: No directory found.${normal}"; exit 1
	fi

	# Capture the output of ls to an array
	if [[ $shifttime ]] || [[ $pal2ntsc ]] || [[ $ntsc2pal ]] || [[ $adjustfirst ]] || [[ $adjustonlyfirst ]] || [[ $adjustonlylast ]] || [[ $synchronizedirectory ]] || [[ $srt2sub ]] || [[ $splitsrt ]]; then
		if [[ $recurse ]]; then
			filesarray=( $(find $inputdirectory -type f -iname "*.srt" 2> /dev/null | sort) )
		else
			filesarray=( $(ls $inputdirectory/*.srt 2> /dev/null) )
		fi
		echo "${#filesarray[@]} .srt file(s) found"
	elif [[ $sub2srt ]]; then
		if [[ $recurse ]]; then
			filesarray=( $(find $inputdirectory -type f -iname "*.sub" 2> /dev/null | sort) )
		else
			filesarray=( $(ls $inputdirectory/*.sub 2> /dev/null) )
		fi
		echo "${#filesarray[@]} .sub file(s) found"
	elif [[ $synchronizefile ]] || [[ $joinsrt ]]; then
		echo "${red}Error: Synchronize with file and Join srt cannot be used in batch mode.${normal}"
		echo "Instead of Synchronize with file you can use Synchronize with directory (-D parameter)."; exit 1
	else
		if [[ $recurse ]]; then
			filesarray=( $(find $inputdirectory -type f -iname "*.srt" -o -iname "*.sub" 2> /dev/null | sort) )
		else
			filesarray=( $(ls $inputdirectory/*.srt $inputdirectory/*.sub 2> /dev/null) )
		fi
		echo "$(printf "%s\n" "${filesarray[@]}" | grep -i "\.srt$" -c) .srt & $(printf "%s\n" "${filesarray[@]}" | grep -i "\.sub$" -c) .sub file(s) found"
	fi

	IFS=$old_IFS		# restore default field separator

	# Restore globbing to case sensitive
	shopt -u nocaseglob

	batchcounter=0
	numberofsubtitles=${#filesarray[@]}
	numberofsubtitleslength=${#numberofsubtitles}
	for inputfilename in "${filesarray[@]}"; do
		((batchcounter++))
		batchcounterlength=${#batchcounter}
		spaceslength=$((numberofsubtitleslength-batchcounterlength))
		case "$spaceslength" in
			0) precedingspaces="" ;;
			1) precedingspaces=" " ;;
			2) precedingspaces="  " ;;
			3) precedingspaces="   " ;;
			?) precedingspaces=$(eval printf "\ %.0s" {1..$spaceslength}) ;;
		esac
		printf "${bold}${green}[$precedingspaces$batchcounter/${#filesarray[@]}]${normal} "

		if [[ $shifttime ]]; then
			shift_time
		fi

		if [[ $pal2ntsc ]] || [[ $ntsc2pal ]]; then
			change_fps
		fi

		if [[ $adjustfirst ]]; then
			adjust_time
		fi

		if [[ $adjustonlyfirst ]] || [[ $adjustonlylast ]]; then
			adjust_time_v2
		fi

		if [[ $synchronizedirectory ]]; then
			synchronize_with_file
		fi

		if [[ $findci ]] || [[ $findcs ]]; then
			find_text
		fi

		if [[ $replace1 ]] || [[ $replace3 ]]; then
			replace_text
		fi

		if [[ $sub2srt ]]; then
			sub2_srt
		elif [[ $srt2sub ]]; then
			srt2_sub
		fi

		if [[ $splitsrt ]]; then
			split_srt
		fi

		if [[ $cleantrash ]]; then
			clean_trash
		fi

		if [[ $deletetextsforHI ]]; then
			delete_HI
		fi

		if [[ $fixerrors ]]; then
			fix_common_errors
		fi

		if [[ $sortsubs ]]; then
			sort_subs
		fi

		if ! [[ $srtok ]] && ! [[ $subok ]] && ! [[ $subtitleis ]]; then
			basic_clean_up
		fi
	done
	exit 0
fi
